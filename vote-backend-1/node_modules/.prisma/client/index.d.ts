
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Nomination
 * 
 */
export type Nomination = $Result.DefaultSelection<Prisma.$NominationPayload>
/**
 * Model NominatorVerification
 * 
 */
export type NominatorVerification = $Result.DefaultSelection<Prisma.$NominatorVerificationPayload>
/**
 * Model GuarantorVerification
 * 
 */
export type GuarantorVerification = $Result.DefaultSelection<Prisma.$GuarantorVerificationPayload>
/**
 * Model EcReview
 * 
 */
export type EcReview = $Result.DefaultSelection<Prisma.$EcReviewPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Candidate
 * 
 */
export type Candidate = $Result.DefaultSelection<Prisma.$CandidatePayload>
/**
 * Model VotingSession
 * 
 */
export type VotingSession = $Result.DefaultSelection<Prisma.$VotingSessionPayload>
/**
 * Model Vote
 * 
 */
export type Vote = $Result.DefaultSelection<Prisma.$VotePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Subgroup
 * 
 */
export type Subgroup = $Result.DefaultSelection<Prisma.$SubgroupPayload>
/**
 * Model Programme
 * 
 */
export type Programme = $Result.DefaultSelection<Prisma.$ProgrammePayload>
/**
 * Model SystemConfig
 * 
 */
export type SystemConfig = $Result.DefaultSelection<Prisma.$SystemConfigPayload>
/**
 * Model ElectionTimeline
 * 
 */
export type ElectionTimeline = $Result.DefaultSelection<Prisma.$ElectionTimelinePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Candidate_Position: {
  PRESIDENT: 'PRESIDENT',
  VICE_PRESIDENT: 'VICE_PRESIDENT',
  GEN_SECRETARY: 'GEN_SECRETARY',
  FINANCIAL_SECRETARY: 'FINANCIAL_SECRETARY',
  ORGANIZING_SECRETARY_MAIN: 'ORGANIZING_SECRETARY_MAIN',
  ORGANIZING_SECRETARY_ASST: 'ORGANIZING_SECRETARY_ASST',
  PRO_MAIN: 'PRO_MAIN',
  PRO_ASSISTANT: 'PRO_ASSISTANT',
  WOMEN_COMMISSIONER: 'WOMEN_COMMISSIONER'
};

export type Candidate_Position = (typeof Candidate_Position)[keyof typeof Candidate_Position]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const NominationStatus: {
  PENDING: 'PENDING',
  AWAITING_VERIFICATION: 'AWAITING_VERIFICATION',
  PARTIALLY_VERIFIED: 'PARTIALLY_VERIFIED',
  VERIFIED: 'VERIFIED',
  UNDER_REVIEW: 'UNDER_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  WITHDRAWN: 'WITHDRAWN'
};

export type NominationStatus = (typeof NominationStatus)[keyof typeof NominationStatus]


export const TokenType: {
  NOMINATOR_VERIFICATION: 'NOMINATOR_VERIFICATION',
  GUARANTOR_VERIFICATION: 'GUARANTOR_VERIFICATION',
  ONE_VERIFICATION: 'ONE_VERIFICATION',
  PASSWORD_RESET: 'PASSWORD_RESET'
};

export type TokenType = (typeof TokenType)[keyof typeof TokenType]


export const UserRole: {
  VOTER: 'VOTER',
  ASPIRANT: 'ASPIRANT',
  EC_MEMBER: 'EC_MEMBER',
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const VotingStatus: {
  NOT_STARTED: 'NOT_STARTED',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  SUSPENDED: 'SUSPENDED'
};

export type VotingStatus = (typeof VotingStatus)[keyof typeof VotingStatus]


export const VerificationStatus: {
  PENDING: 'PENDING',
  VERIFIED: 'VERIFIED',
  DECLINED: 'DECLINED',
  EXPIRED: 'EXPIRED'
};

export type VerificationStatus = (typeof VerificationStatus)[keyof typeof VerificationStatus]

}

export type Candidate_Position = $Enums.Candidate_Position

export const Candidate_Position: typeof $Enums.Candidate_Position

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type NominationStatus = $Enums.NominationStatus

export const NominationStatus: typeof $Enums.NominationStatus

export type TokenType = $Enums.TokenType

export const TokenType: typeof $Enums.TokenType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type VotingStatus = $Enums.VotingStatus

export const VotingStatus: typeof $Enums.VotingStatus

export type VerificationStatus = $Enums.VerificationStatus

export const VerificationStatus: typeof $Enums.VerificationStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nomination`: Exposes CRUD operations for the **Nomination** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Nominations
    * const nominations = await prisma.nomination.findMany()
    * ```
    */
  get nomination(): Prisma.NominationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nominatorVerification`: Exposes CRUD operations for the **NominatorVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NominatorVerifications
    * const nominatorVerifications = await prisma.nominatorVerification.findMany()
    * ```
    */
  get nominatorVerification(): Prisma.NominatorVerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guarantorVerification`: Exposes CRUD operations for the **GuarantorVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuarantorVerifications
    * const guarantorVerifications = await prisma.guarantorVerification.findMany()
    * ```
    */
  get guarantorVerification(): Prisma.GuarantorVerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ecReview`: Exposes CRUD operations for the **EcReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EcReviews
    * const ecReviews = await prisma.ecReview.findMany()
    * ```
    */
  get ecReview(): Prisma.EcReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.candidate`: Exposes CRUD operations for the **Candidate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Candidates
    * const candidates = await prisma.candidate.findMany()
    * ```
    */
  get candidate(): Prisma.CandidateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.votingSession`: Exposes CRUD operations for the **VotingSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VotingSessions
    * const votingSessions = await prisma.votingSession.findMany()
    * ```
    */
  get votingSession(): Prisma.VotingSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vote`: Exposes CRUD operations for the **Vote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Votes
    * const votes = await prisma.vote.findMany()
    * ```
    */
  get vote(): Prisma.VoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subgroup`: Exposes CRUD operations for the **Subgroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subgroups
    * const subgroups = await prisma.subgroup.findMany()
    * ```
    */
  get subgroup(): Prisma.SubgroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.programme`: Exposes CRUD operations for the **Programme** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Programmes
    * const programmes = await prisma.programme.findMany()
    * ```
    */
  get programme(): Prisma.ProgrammeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemConfig`: Exposes CRUD operations for the **SystemConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemConfigs
    * const systemConfigs = await prisma.systemConfig.findMany()
    * ```
    */
  get systemConfig(): Prisma.SystemConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.electionTimeline`: Exposes CRUD operations for the **ElectionTimeline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ElectionTimelines
    * const electionTimelines = await prisma.electionTimeline.findMany()
    * ```
    */
  get electionTimeline(): Prisma.ElectionTimelineDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Nomination: 'Nomination',
    NominatorVerification: 'NominatorVerification',
    GuarantorVerification: 'GuarantorVerification',
    EcReview: 'EcReview',
    VerificationToken: 'VerificationToken',
    Candidate: 'Candidate',
    VotingSession: 'VotingSession',
    Vote: 'Vote',
    AuditLog: 'AuditLog',
    Subgroup: 'Subgroup',
    Programme: 'Programme',
    SystemConfig: 'SystemConfig',
    ElectionTimeline: 'ElectionTimeline'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "nomination" | "nominatorVerification" | "guarantorVerification" | "ecReview" | "verificationToken" | "candidate" | "votingSession" | "vote" | "auditLog" | "subgroup" | "programme" | "systemConfig" | "electionTimeline"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Nomination: {
        payload: Prisma.$NominationPayload<ExtArgs>
        fields: Prisma.NominationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NominationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NominationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NominationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NominationPayload>
          }
          findFirst: {
            args: Prisma.NominationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NominationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NominationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NominationPayload>
          }
          findMany: {
            args: Prisma.NominationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NominationPayload>[]
          }
          create: {
            args: Prisma.NominationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NominationPayload>
          }
          createMany: {
            args: Prisma.NominationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NominationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NominationPayload>[]
          }
          delete: {
            args: Prisma.NominationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NominationPayload>
          }
          update: {
            args: Prisma.NominationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NominationPayload>
          }
          deleteMany: {
            args: Prisma.NominationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NominationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NominationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NominationPayload>[]
          }
          upsert: {
            args: Prisma.NominationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NominationPayload>
          }
          aggregate: {
            args: Prisma.NominationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNomination>
          }
          groupBy: {
            args: Prisma.NominationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NominationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NominationCountArgs<ExtArgs>
            result: $Utils.Optional<NominationCountAggregateOutputType> | number
          }
        }
      }
      NominatorVerification: {
        payload: Prisma.$NominatorVerificationPayload<ExtArgs>
        fields: Prisma.NominatorVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NominatorVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NominatorVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NominatorVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NominatorVerificationPayload>
          }
          findFirst: {
            args: Prisma.NominatorVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NominatorVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NominatorVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NominatorVerificationPayload>
          }
          findMany: {
            args: Prisma.NominatorVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NominatorVerificationPayload>[]
          }
          create: {
            args: Prisma.NominatorVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NominatorVerificationPayload>
          }
          createMany: {
            args: Prisma.NominatorVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NominatorVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NominatorVerificationPayload>[]
          }
          delete: {
            args: Prisma.NominatorVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NominatorVerificationPayload>
          }
          update: {
            args: Prisma.NominatorVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NominatorVerificationPayload>
          }
          deleteMany: {
            args: Prisma.NominatorVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NominatorVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NominatorVerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NominatorVerificationPayload>[]
          }
          upsert: {
            args: Prisma.NominatorVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NominatorVerificationPayload>
          }
          aggregate: {
            args: Prisma.NominatorVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNominatorVerification>
          }
          groupBy: {
            args: Prisma.NominatorVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NominatorVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NominatorVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<NominatorVerificationCountAggregateOutputType> | number
          }
        }
      }
      GuarantorVerification: {
        payload: Prisma.$GuarantorVerificationPayload<ExtArgs>
        fields: Prisma.GuarantorVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuarantorVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuarantorVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuarantorVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuarantorVerificationPayload>
          }
          findFirst: {
            args: Prisma.GuarantorVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuarantorVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuarantorVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuarantorVerificationPayload>
          }
          findMany: {
            args: Prisma.GuarantorVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuarantorVerificationPayload>[]
          }
          create: {
            args: Prisma.GuarantorVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuarantorVerificationPayload>
          }
          createMany: {
            args: Prisma.GuarantorVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GuarantorVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuarantorVerificationPayload>[]
          }
          delete: {
            args: Prisma.GuarantorVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuarantorVerificationPayload>
          }
          update: {
            args: Prisma.GuarantorVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuarantorVerificationPayload>
          }
          deleteMany: {
            args: Prisma.GuarantorVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuarantorVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GuarantorVerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuarantorVerificationPayload>[]
          }
          upsert: {
            args: Prisma.GuarantorVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuarantorVerificationPayload>
          }
          aggregate: {
            args: Prisma.GuarantorVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuarantorVerification>
          }
          groupBy: {
            args: Prisma.GuarantorVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuarantorVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuarantorVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<GuarantorVerificationCountAggregateOutputType> | number
          }
        }
      }
      EcReview: {
        payload: Prisma.$EcReviewPayload<ExtArgs>
        fields: Prisma.EcReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EcReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EcReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcReviewPayload>
          }
          findFirst: {
            args: Prisma.EcReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EcReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcReviewPayload>
          }
          findMany: {
            args: Prisma.EcReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcReviewPayload>[]
          }
          create: {
            args: Prisma.EcReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcReviewPayload>
          }
          createMany: {
            args: Prisma.EcReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EcReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcReviewPayload>[]
          }
          delete: {
            args: Prisma.EcReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcReviewPayload>
          }
          update: {
            args: Prisma.EcReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcReviewPayload>
          }
          deleteMany: {
            args: Prisma.EcReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EcReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EcReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcReviewPayload>[]
          }
          upsert: {
            args: Prisma.EcReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcReviewPayload>
          }
          aggregate: {
            args: Prisma.EcReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEcReview>
          }
          groupBy: {
            args: Prisma.EcReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<EcReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.EcReviewCountArgs<ExtArgs>
            result: $Utils.Optional<EcReviewCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Candidate: {
        payload: Prisma.$CandidatePayload<ExtArgs>
        fields: Prisma.CandidateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CandidateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CandidateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatePayload>
          }
          findFirst: {
            args: Prisma.CandidateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CandidateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatePayload>
          }
          findMany: {
            args: Prisma.CandidateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatePayload>[]
          }
          create: {
            args: Prisma.CandidateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatePayload>
          }
          createMany: {
            args: Prisma.CandidateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CandidateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatePayload>[]
          }
          delete: {
            args: Prisma.CandidateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatePayload>
          }
          update: {
            args: Prisma.CandidateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatePayload>
          }
          deleteMany: {
            args: Prisma.CandidateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CandidateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CandidateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatePayload>[]
          }
          upsert: {
            args: Prisma.CandidateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatePayload>
          }
          aggregate: {
            args: Prisma.CandidateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCandidate>
          }
          groupBy: {
            args: Prisma.CandidateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CandidateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CandidateCountArgs<ExtArgs>
            result: $Utils.Optional<CandidateCountAggregateOutputType> | number
          }
        }
      }
      VotingSession: {
        payload: Prisma.$VotingSessionPayload<ExtArgs>
        fields: Prisma.VotingSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VotingSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotingSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VotingSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotingSessionPayload>
          }
          findFirst: {
            args: Prisma.VotingSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotingSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VotingSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotingSessionPayload>
          }
          findMany: {
            args: Prisma.VotingSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotingSessionPayload>[]
          }
          create: {
            args: Prisma.VotingSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotingSessionPayload>
          }
          createMany: {
            args: Prisma.VotingSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VotingSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotingSessionPayload>[]
          }
          delete: {
            args: Prisma.VotingSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotingSessionPayload>
          }
          update: {
            args: Prisma.VotingSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotingSessionPayload>
          }
          deleteMany: {
            args: Prisma.VotingSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VotingSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VotingSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotingSessionPayload>[]
          }
          upsert: {
            args: Prisma.VotingSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotingSessionPayload>
          }
          aggregate: {
            args: Prisma.VotingSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVotingSession>
          }
          groupBy: {
            args: Prisma.VotingSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<VotingSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.VotingSessionCountArgs<ExtArgs>
            result: $Utils.Optional<VotingSessionCountAggregateOutputType> | number
          }
        }
      }
      Vote: {
        payload: Prisma.$VotePayload<ExtArgs>
        fields: Prisma.VoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          findFirst: {
            args: Prisma.VoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          findMany: {
            args: Prisma.VoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[]
          }
          create: {
            args: Prisma.VoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          createMany: {
            args: Prisma.VoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[]
          }
          delete: {
            args: Prisma.VoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          update: {
            args: Prisma.VoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          deleteMany: {
            args: Prisma.VoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[]
          }
          upsert: {
            args: Prisma.VoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          aggregate: {
            args: Prisma.VoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVote>
          }
          groupBy: {
            args: Prisma.VoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoteCountArgs<ExtArgs>
            result: $Utils.Optional<VoteCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Subgroup: {
        payload: Prisma.$SubgroupPayload<ExtArgs>
        fields: Prisma.SubgroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubgroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubgroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubgroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubgroupPayload>
          }
          findFirst: {
            args: Prisma.SubgroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubgroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubgroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubgroupPayload>
          }
          findMany: {
            args: Prisma.SubgroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubgroupPayload>[]
          }
          create: {
            args: Prisma.SubgroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubgroupPayload>
          }
          createMany: {
            args: Prisma.SubgroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubgroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubgroupPayload>[]
          }
          delete: {
            args: Prisma.SubgroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubgroupPayload>
          }
          update: {
            args: Prisma.SubgroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubgroupPayload>
          }
          deleteMany: {
            args: Prisma.SubgroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubgroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubgroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubgroupPayload>[]
          }
          upsert: {
            args: Prisma.SubgroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubgroupPayload>
          }
          aggregate: {
            args: Prisma.SubgroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubgroup>
          }
          groupBy: {
            args: Prisma.SubgroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubgroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubgroupCountArgs<ExtArgs>
            result: $Utils.Optional<SubgroupCountAggregateOutputType> | number
          }
        }
      }
      Programme: {
        payload: Prisma.$ProgrammePayload<ExtArgs>
        fields: Prisma.ProgrammeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgrammeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgrammePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgrammeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgrammePayload>
          }
          findFirst: {
            args: Prisma.ProgrammeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgrammePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgrammeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgrammePayload>
          }
          findMany: {
            args: Prisma.ProgrammeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgrammePayload>[]
          }
          create: {
            args: Prisma.ProgrammeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgrammePayload>
          }
          createMany: {
            args: Prisma.ProgrammeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgrammeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgrammePayload>[]
          }
          delete: {
            args: Prisma.ProgrammeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgrammePayload>
          }
          update: {
            args: Prisma.ProgrammeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgrammePayload>
          }
          deleteMany: {
            args: Prisma.ProgrammeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgrammeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProgrammeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgrammePayload>[]
          }
          upsert: {
            args: Prisma.ProgrammeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgrammePayload>
          }
          aggregate: {
            args: Prisma.ProgrammeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgramme>
          }
          groupBy: {
            args: Prisma.ProgrammeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgrammeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgrammeCountArgs<ExtArgs>
            result: $Utils.Optional<ProgrammeCountAggregateOutputType> | number
          }
        }
      }
      SystemConfig: {
        payload: Prisma.$SystemConfigPayload<ExtArgs>
        fields: Prisma.SystemConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findFirst: {
            args: Prisma.SystemConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findMany: {
            args: Prisma.SystemConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          create: {
            args: Prisma.SystemConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          createMany: {
            args: Prisma.SystemConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          delete: {
            args: Prisma.SystemConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          update: {
            args: Prisma.SystemConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          deleteMany: {
            args: Prisma.SystemConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          upsert: {
            args: Prisma.SystemConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          aggregate: {
            args: Prisma.SystemConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemConfig>
          }
          groupBy: {
            args: Prisma.SystemConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigCountAggregateOutputType> | number
          }
        }
      }
      ElectionTimeline: {
        payload: Prisma.$ElectionTimelinePayload<ExtArgs>
        fields: Prisma.ElectionTimelineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ElectionTimelineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionTimelinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ElectionTimelineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionTimelinePayload>
          }
          findFirst: {
            args: Prisma.ElectionTimelineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionTimelinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ElectionTimelineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionTimelinePayload>
          }
          findMany: {
            args: Prisma.ElectionTimelineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionTimelinePayload>[]
          }
          create: {
            args: Prisma.ElectionTimelineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionTimelinePayload>
          }
          createMany: {
            args: Prisma.ElectionTimelineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ElectionTimelineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionTimelinePayload>[]
          }
          delete: {
            args: Prisma.ElectionTimelineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionTimelinePayload>
          }
          update: {
            args: Prisma.ElectionTimelineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionTimelinePayload>
          }
          deleteMany: {
            args: Prisma.ElectionTimelineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ElectionTimelineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ElectionTimelineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionTimelinePayload>[]
          }
          upsert: {
            args: Prisma.ElectionTimelineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionTimelinePayload>
          }
          aggregate: {
            args: Prisma.ElectionTimelineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateElectionTimeline>
          }
          groupBy: {
            args: Prisma.ElectionTimelineGroupByArgs<ExtArgs>
            result: $Utils.Optional<ElectionTimelineGroupByOutputType>[]
          }
          count: {
            args: Prisma.ElectionTimelineCountArgs<ExtArgs>
            result: $Utils.Optional<ElectionTimelineCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    nomination?: NominationOmit
    nominatorVerification?: NominatorVerificationOmit
    guarantorVerification?: GuarantorVerificationOmit
    ecReview?: EcReviewOmit
    verificationToken?: VerificationTokenOmit
    candidate?: CandidateOmit
    votingSession?: VotingSessionOmit
    vote?: VoteOmit
    auditLog?: AuditLogOmit
    subgroup?: SubgroupOmit
    programme?: ProgrammeOmit
    systemConfig?: SystemConfigOmit
    electionTimeline?: ElectionTimelineOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    nominations: number
    ecReviews: number
    Nomination: number
    NominatorVerification: number
    GuarantorVerification: number
    EcReview: number
    VotingSession: number
    AuditLog: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nominations?: boolean | UserCountOutputTypeCountNominationsArgs
    ecReviews?: boolean | UserCountOutputTypeCountEcReviewsArgs
    Nomination?: boolean | UserCountOutputTypeCountNominationArgs
    NominatorVerification?: boolean | UserCountOutputTypeCountNominatorVerificationArgs
    GuarantorVerification?: boolean | UserCountOutputTypeCountGuarantorVerificationArgs
    EcReview?: boolean | UserCountOutputTypeCountEcReviewArgs
    VotingSession?: boolean | UserCountOutputTypeCountVotingSessionArgs
    AuditLog?: boolean | UserCountOutputTypeCountAuditLogArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNominationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NominationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEcReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EcReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNominationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NominationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNominatorVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NominatorVerificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGuarantorVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuarantorVerificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEcReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EcReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVotingSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VotingSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type NominationCountOutputType
   */

  export type NominationCountOutputType = {
    guarantorVerifications: number
    EcReview: number
  }

  export type NominationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guarantorVerifications?: boolean | NominationCountOutputTypeCountGuarantorVerificationsArgs
    EcReview?: boolean | NominationCountOutputTypeCountEcReviewArgs
  }

  // Custom InputTypes
  /**
   * NominationCountOutputType without action
   */
  export type NominationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NominationCountOutputType
     */
    select?: NominationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NominationCountOutputType without action
   */
  export type NominationCountOutputTypeCountGuarantorVerificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuarantorVerificationWhereInput
  }

  /**
   * NominationCountOutputType without action
   */
  export type NominationCountOutputTypeCountEcReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EcReviewWhereInput
  }


  /**
   * Count Type VotingSessionCountOutputType
   */

  export type VotingSessionCountOutputType = {
    votes: number
  }

  export type VotingSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    votes?: boolean | VotingSessionCountOutputTypeCountVotesArgs
  }

  // Custom InputTypes
  /**
   * VotingSessionCountOutputType without action
   */
  export type VotingSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VotingSessionCountOutputType
     */
    select?: VotingSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VotingSessionCountOutputType without action
   */
  export type VotingSessionCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
  }


  /**
   * Count Type SubgroupCountOutputType
   */

  export type SubgroupCountOutputType = {
    users: number
    nominations: number
  }

  export type SubgroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | SubgroupCountOutputTypeCountUsersArgs
    nominations?: boolean | SubgroupCountOutputTypeCountNominationsArgs
  }

  // Custom InputTypes
  /**
   * SubgroupCountOutputType without action
   */
  export type SubgroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubgroupCountOutputType
     */
    select?: SubgroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubgroupCountOutputType without action
   */
  export type SubgroupCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * SubgroupCountOutputType without action
   */
  export type SubgroupCountOutputTypeCountNominationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NominationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    role: $Enums.UserRole | null
    programme: string | null
    level: string | null
    subgroup: string | null
    college: string | null
    phoneVerified: boolean | null
    emailVerified: boolean | null
    isActive: boolean | null
    hasVoted: boolean | null
    inkVerified: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    subgroupId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    role: $Enums.UserRole | null
    programme: string | null
    level: string | null
    subgroup: string | null
    college: string | null
    phoneVerified: boolean | null
    emailVerified: boolean | null
    isActive: boolean | null
    hasVoted: boolean | null
    inkVerified: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    subgroupId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    password: number
    role: number
    programme: number
    level: number
    subgroup: number
    college: number
    phoneVerified: number
    emailVerified: number
    isActive: number
    hasVoted: number
    inkVerified: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    subgroupId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    role?: true
    programme?: true
    level?: true
    subgroup?: true
    college?: true
    phoneVerified?: true
    emailVerified?: true
    isActive?: true
    hasVoted?: true
    inkVerified?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    subgroupId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    role?: true
    programme?: true
    level?: true
    subgroup?: true
    college?: true
    phoneVerified?: true
    emailVerified?: true
    isActive?: true
    hasVoted?: true
    inkVerified?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    subgroupId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    role?: true
    programme?: true
    level?: true
    subgroup?: true
    college?: true
    phoneVerified?: true
    emailVerified?: true
    isActive?: true
    hasVoted?: true
    inkVerified?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    subgroupId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string | null
    password: string | null
    role: $Enums.UserRole
    programme: string | null
    level: string | null
    subgroup: string | null
    college: string | null
    phoneVerified: boolean
    emailVerified: boolean
    isActive: boolean
    hasVoted: boolean
    inkVerified: boolean
    lastLoginAt: Date | null
    createdAt: Date
    updatedAt: Date
    subgroupId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role?: boolean
    programme?: boolean
    level?: boolean
    subgroup?: boolean
    college?: boolean
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subgroupId?: boolean
    nominations?: boolean | User$nominationsArgs<ExtArgs>
    ecReviews?: boolean | User$ecReviewsArgs<ExtArgs>
    Nomination?: boolean | User$NominationArgs<ExtArgs>
    NominatorVerification?: boolean | User$NominatorVerificationArgs<ExtArgs>
    GuarantorVerification?: boolean | User$GuarantorVerificationArgs<ExtArgs>
    EcReview?: boolean | User$EcReviewArgs<ExtArgs>
    VotingSession?: boolean | User$VotingSessionArgs<ExtArgs>
    AuditLog?: boolean | User$AuditLogArgs<ExtArgs>
    Subgroup?: boolean | User$SubgroupArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role?: boolean
    programme?: boolean
    level?: boolean
    subgroup?: boolean
    college?: boolean
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subgroupId?: boolean
    Subgroup?: boolean | User$SubgroupArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role?: boolean
    programme?: boolean
    level?: boolean
    subgroup?: boolean
    college?: boolean
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subgroupId?: boolean
    Subgroup?: boolean | User$SubgroupArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role?: boolean
    programme?: boolean
    level?: boolean
    subgroup?: boolean
    college?: boolean
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subgroupId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "password" | "role" | "programme" | "level" | "subgroup" | "college" | "phoneVerified" | "emailVerified" | "isActive" | "hasVoted" | "inkVerified" | "lastLoginAt" | "createdAt" | "updatedAt" | "subgroupId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nominations?: boolean | User$nominationsArgs<ExtArgs>
    ecReviews?: boolean | User$ecReviewsArgs<ExtArgs>
    Nomination?: boolean | User$NominationArgs<ExtArgs>
    NominatorVerification?: boolean | User$NominatorVerificationArgs<ExtArgs>
    GuarantorVerification?: boolean | User$GuarantorVerificationArgs<ExtArgs>
    EcReview?: boolean | User$EcReviewArgs<ExtArgs>
    VotingSession?: boolean | User$VotingSessionArgs<ExtArgs>
    AuditLog?: boolean | User$AuditLogArgs<ExtArgs>
    Subgroup?: boolean | User$SubgroupArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Subgroup?: boolean | User$SubgroupArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Subgroup?: boolean | User$SubgroupArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      nominations: Prisma.$NominationPayload<ExtArgs>[]
      ecReviews: Prisma.$EcReviewPayload<ExtArgs>[]
      Nomination: Prisma.$NominationPayload<ExtArgs>[]
      NominatorVerification: Prisma.$NominatorVerificationPayload<ExtArgs>[]
      GuarantorVerification: Prisma.$GuarantorVerificationPayload<ExtArgs>[]
      EcReview: Prisma.$EcReviewPayload<ExtArgs>[]
      VotingSession: Prisma.$VotingSessionPayload<ExtArgs>[]
      AuditLog: Prisma.$AuditLogPayload<ExtArgs>[]
      Subgroup: Prisma.$SubgroupPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string | null
      password: string | null
      role: $Enums.UserRole
      programme: string | null
      level: string | null
      subgroup: string | null
      college: string | null
      phoneVerified: boolean
      emailVerified: boolean
      isActive: boolean
      hasVoted: boolean
      inkVerified: boolean
      lastLoginAt: Date | null
      createdAt: Date
      updatedAt: Date
      subgroupId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nominations<T extends User$nominationsArgs<ExtArgs> = {}>(args?: Subset<T, User$nominationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NominationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ecReviews<T extends User$ecReviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$ecReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EcReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Nomination<T extends User$NominationArgs<ExtArgs> = {}>(args?: Subset<T, User$NominationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NominationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    NominatorVerification<T extends User$NominatorVerificationArgs<ExtArgs> = {}>(args?: Subset<T, User$NominatorVerificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NominatorVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    GuarantorVerification<T extends User$GuarantorVerificationArgs<ExtArgs> = {}>(args?: Subset<T, User$GuarantorVerificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuarantorVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    EcReview<T extends User$EcReviewArgs<ExtArgs> = {}>(args?: Subset<T, User$EcReviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EcReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    VotingSession<T extends User$VotingSessionArgs<ExtArgs> = {}>(args?: Subset<T, User$VotingSessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotingSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AuditLog<T extends User$AuditLogArgs<ExtArgs> = {}>(args?: Subset<T, User$AuditLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Subgroup<T extends User$SubgroupArgs<ExtArgs> = {}>(args?: Subset<T, User$SubgroupArgs<ExtArgs>>): Prisma__SubgroupClient<$Result.GetResult<Prisma.$SubgroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly programme: FieldRef<"User", 'String'>
    readonly level: FieldRef<"User", 'String'>
    readonly subgroup: FieldRef<"User", 'String'>
    readonly college: FieldRef<"User", 'String'>
    readonly phoneVerified: FieldRef<"User", 'Boolean'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly hasVoted: FieldRef<"User", 'Boolean'>
    readonly inkVerified: FieldRef<"User", 'Boolean'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly subgroupId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.nominations
   */
  export type User$nominationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nomination
     */
    select?: NominationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nomination
     */
    omit?: NominationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominationInclude<ExtArgs> | null
    where?: NominationWhereInput
    orderBy?: NominationOrderByWithRelationInput | NominationOrderByWithRelationInput[]
    cursor?: NominationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NominationScalarFieldEnum | NominationScalarFieldEnum[]
  }

  /**
   * User.ecReviews
   */
  export type User$ecReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcReview
     */
    select?: EcReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcReview
     */
    omit?: EcReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcReviewInclude<ExtArgs> | null
    where?: EcReviewWhereInput
    orderBy?: EcReviewOrderByWithRelationInput | EcReviewOrderByWithRelationInput[]
    cursor?: EcReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EcReviewScalarFieldEnum | EcReviewScalarFieldEnum[]
  }

  /**
   * User.Nomination
   */
  export type User$NominationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nomination
     */
    select?: NominationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nomination
     */
    omit?: NominationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominationInclude<ExtArgs> | null
    where?: NominationWhereInput
    orderBy?: NominationOrderByWithRelationInput | NominationOrderByWithRelationInput[]
    cursor?: NominationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NominationScalarFieldEnum | NominationScalarFieldEnum[]
  }

  /**
   * User.NominatorVerification
   */
  export type User$NominatorVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NominatorVerification
     */
    select?: NominatorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NominatorVerification
     */
    omit?: NominatorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominatorVerificationInclude<ExtArgs> | null
    where?: NominatorVerificationWhereInput
    orderBy?: NominatorVerificationOrderByWithRelationInput | NominatorVerificationOrderByWithRelationInput[]
    cursor?: NominatorVerificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NominatorVerificationScalarFieldEnum | NominatorVerificationScalarFieldEnum[]
  }

  /**
   * User.GuarantorVerification
   */
  export type User$GuarantorVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuarantorVerification
     */
    select?: GuarantorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuarantorVerification
     */
    omit?: GuarantorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorVerificationInclude<ExtArgs> | null
    where?: GuarantorVerificationWhereInput
    orderBy?: GuarantorVerificationOrderByWithRelationInput | GuarantorVerificationOrderByWithRelationInput[]
    cursor?: GuarantorVerificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GuarantorVerificationScalarFieldEnum | GuarantorVerificationScalarFieldEnum[]
  }

  /**
   * User.EcReview
   */
  export type User$EcReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcReview
     */
    select?: EcReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcReview
     */
    omit?: EcReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcReviewInclude<ExtArgs> | null
    where?: EcReviewWhereInput
    orderBy?: EcReviewOrderByWithRelationInput | EcReviewOrderByWithRelationInput[]
    cursor?: EcReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EcReviewScalarFieldEnum | EcReviewScalarFieldEnum[]
  }

  /**
   * User.VotingSession
   */
  export type User$VotingSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VotingSession
     */
    select?: VotingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VotingSession
     */
    omit?: VotingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VotingSessionInclude<ExtArgs> | null
    where?: VotingSessionWhereInput
    orderBy?: VotingSessionOrderByWithRelationInput | VotingSessionOrderByWithRelationInput[]
    cursor?: VotingSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VotingSessionScalarFieldEnum | VotingSessionScalarFieldEnum[]
  }

  /**
   * User.AuditLog
   */
  export type User$AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.Subgroup
   */
  export type User$SubgroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null
    where?: SubgroupWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Nomination
   */

  export type AggregateNomination = {
    _count: NominationCountAggregateOutputType | null
    _avg: NominationAvgAggregateOutputType | null
    _sum: NominationSumAggregateOutputType | null
    _min: NominationMinAggregateOutputType | null
    _max: NominationMaxAggregateOutputType | null
  }

  export type NominationAvgAggregateOutputType = {
    approvalCount: number | null
    rejectionCount: number | null
  }

  export type NominationSumAggregateOutputType = {
    approvalCount: number | null
    rejectionCount: number | null
  }

  export type NominationMinAggregateOutputType = {
    id: string | null
    aspirantId: string | null
    nomineeName: string | null
    nomineeEmail: string | null
    nomineeContact: string | null
    nomineePosition: $Enums.Candidate_Position | null
    photoUrl: string | null
    photoPublicId: string | null
    status: $Enums.NominationStatus | null
    nomineeCollege: string | null
    nomineeDepartment: string | null
    nomineeDateOfBirth: Date | null
    nomineeHostel: string | null
    nomineeRoom: string | null
    nomineeSex: string | null
    nomineeCwa: string | null
    nomineeProgramme: string | null
    nomineeLevel: string | null
    nomineeParish: string | null
    nomineeNationality: string | null
    nomineeRegion: string | null
    hasLeadershipPosition: boolean | null
    hasServedCommittee: boolean | null
    approvalCount: number | null
    rejectionCount: number | null
    reviewedAt: Date | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    subgroupId: string | null
  }

  export type NominationMaxAggregateOutputType = {
    id: string | null
    aspirantId: string | null
    nomineeName: string | null
    nomineeEmail: string | null
    nomineeContact: string | null
    nomineePosition: $Enums.Candidate_Position | null
    photoUrl: string | null
    photoPublicId: string | null
    status: $Enums.NominationStatus | null
    nomineeCollege: string | null
    nomineeDepartment: string | null
    nomineeDateOfBirth: Date | null
    nomineeHostel: string | null
    nomineeRoom: string | null
    nomineeSex: string | null
    nomineeCwa: string | null
    nomineeProgramme: string | null
    nomineeLevel: string | null
    nomineeParish: string | null
    nomineeNationality: string | null
    nomineeRegion: string | null
    hasLeadershipPosition: boolean | null
    hasServedCommittee: boolean | null
    approvalCount: number | null
    rejectionCount: number | null
    reviewedAt: Date | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    subgroupId: string | null
  }

  export type NominationCountAggregateOutputType = {
    id: number
    aspirantId: number
    nomineeName: number
    nomineeEmail: number
    nomineeContact: number
    nomineePosition: number
    photoUrl: number
    photoPublicId: number
    status: number
    nomineeCollege: number
    nomineeDepartment: number
    nomineeDateOfBirth: number
    nomineeHostel: number
    nomineeRoom: number
    nomineeSex: number
    nomineeCwa: number
    nomineeProgramme: number
    nomineeLevel: number
    nomineeParish: number
    nomineeNationality: number
    nomineeRegion: number
    nomineeSubgroups: number
    nomineeEducation: number
    hasLeadershipPosition: number
    leadershipPositions: number
    hasServedCommittee: number
    committees: number
    skills: number
    visionForOffice: number
    knowledgeAboutOffice: number
    approvalCount: number
    rejectionCount: number
    reviewedAt: number
    rejectionReason: number
    createdAt: number
    updatedAt: number
    userId: number
    subgroupId: number
    _all: number
  }


  export type NominationAvgAggregateInputType = {
    approvalCount?: true
    rejectionCount?: true
  }

  export type NominationSumAggregateInputType = {
    approvalCount?: true
    rejectionCount?: true
  }

  export type NominationMinAggregateInputType = {
    id?: true
    aspirantId?: true
    nomineeName?: true
    nomineeEmail?: true
    nomineeContact?: true
    nomineePosition?: true
    photoUrl?: true
    photoPublicId?: true
    status?: true
    nomineeCollege?: true
    nomineeDepartment?: true
    nomineeDateOfBirth?: true
    nomineeHostel?: true
    nomineeRoom?: true
    nomineeSex?: true
    nomineeCwa?: true
    nomineeProgramme?: true
    nomineeLevel?: true
    nomineeParish?: true
    nomineeNationality?: true
    nomineeRegion?: true
    hasLeadershipPosition?: true
    hasServedCommittee?: true
    approvalCount?: true
    rejectionCount?: true
    reviewedAt?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    subgroupId?: true
  }

  export type NominationMaxAggregateInputType = {
    id?: true
    aspirantId?: true
    nomineeName?: true
    nomineeEmail?: true
    nomineeContact?: true
    nomineePosition?: true
    photoUrl?: true
    photoPublicId?: true
    status?: true
    nomineeCollege?: true
    nomineeDepartment?: true
    nomineeDateOfBirth?: true
    nomineeHostel?: true
    nomineeRoom?: true
    nomineeSex?: true
    nomineeCwa?: true
    nomineeProgramme?: true
    nomineeLevel?: true
    nomineeParish?: true
    nomineeNationality?: true
    nomineeRegion?: true
    hasLeadershipPosition?: true
    hasServedCommittee?: true
    approvalCount?: true
    rejectionCount?: true
    reviewedAt?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    subgroupId?: true
  }

  export type NominationCountAggregateInputType = {
    id?: true
    aspirantId?: true
    nomineeName?: true
    nomineeEmail?: true
    nomineeContact?: true
    nomineePosition?: true
    photoUrl?: true
    photoPublicId?: true
    status?: true
    nomineeCollege?: true
    nomineeDepartment?: true
    nomineeDateOfBirth?: true
    nomineeHostel?: true
    nomineeRoom?: true
    nomineeSex?: true
    nomineeCwa?: true
    nomineeProgramme?: true
    nomineeLevel?: true
    nomineeParish?: true
    nomineeNationality?: true
    nomineeRegion?: true
    nomineeSubgroups?: true
    nomineeEducation?: true
    hasLeadershipPosition?: true
    leadershipPositions?: true
    hasServedCommittee?: true
    committees?: true
    skills?: true
    visionForOffice?: true
    knowledgeAboutOffice?: true
    approvalCount?: true
    rejectionCount?: true
    reviewedAt?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    subgroupId?: true
    _all?: true
  }

  export type NominationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nomination to aggregate.
     */
    where?: NominationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nominations to fetch.
     */
    orderBy?: NominationOrderByWithRelationInput | NominationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NominationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nominations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nominations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Nominations
    **/
    _count?: true | NominationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NominationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NominationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NominationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NominationMaxAggregateInputType
  }

  export type GetNominationAggregateType<T extends NominationAggregateArgs> = {
        [P in keyof T & keyof AggregateNomination]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNomination[P]>
      : GetScalarType<T[P], AggregateNomination[P]>
  }




  export type NominationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NominationWhereInput
    orderBy?: NominationOrderByWithAggregationInput | NominationOrderByWithAggregationInput[]
    by: NominationScalarFieldEnum[] | NominationScalarFieldEnum
    having?: NominationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NominationCountAggregateInputType | true
    _avg?: NominationAvgAggregateInputType
    _sum?: NominationSumAggregateInputType
    _min?: NominationMinAggregateInputType
    _max?: NominationMaxAggregateInputType
  }

  export type NominationGroupByOutputType = {
    id: string
    aspirantId: string
    nomineeName: string
    nomineeEmail: string
    nomineeContact: string
    nomineePosition: $Enums.Candidate_Position
    photoUrl: string | null
    photoPublicId: string | null
    status: $Enums.NominationStatus
    nomineeCollege: string
    nomineeDepartment: string
    nomineeDateOfBirth: Date
    nomineeHostel: string
    nomineeRoom: string
    nomineeSex: string
    nomineeCwa: string
    nomineeProgramme: string
    nomineeLevel: string
    nomineeParish: string
    nomineeNationality: string
    nomineeRegion: string
    nomineeSubgroups: string[]
    nomineeEducation: string[]
    hasLeadershipPosition: boolean
    leadershipPositions: string[]
    hasServedCommittee: boolean
    committees: string[]
    skills: string[]
    visionForOffice: string[]
    knowledgeAboutOffice: string[]
    approvalCount: number
    rejectionCount: number
    reviewedAt: Date | null
    rejectionReason: string | null
    createdAt: Date
    updatedAt: Date
    userId: string | null
    subgroupId: string | null
    _count: NominationCountAggregateOutputType | null
    _avg: NominationAvgAggregateOutputType | null
    _sum: NominationSumAggregateOutputType | null
    _min: NominationMinAggregateOutputType | null
    _max: NominationMaxAggregateOutputType | null
  }

  type GetNominationGroupByPayload<T extends NominationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NominationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NominationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NominationGroupByOutputType[P]>
            : GetScalarType<T[P], NominationGroupByOutputType[P]>
        }
      >
    >


  export type NominationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    aspirantId?: boolean
    nomineeName?: boolean
    nomineeEmail?: boolean
    nomineeContact?: boolean
    nomineePosition?: boolean
    photoUrl?: boolean
    photoPublicId?: boolean
    status?: boolean
    nomineeCollege?: boolean
    nomineeDepartment?: boolean
    nomineeDateOfBirth?: boolean
    nomineeHostel?: boolean
    nomineeRoom?: boolean
    nomineeSex?: boolean
    nomineeCwa?: boolean
    nomineeProgramme?: boolean
    nomineeLevel?: boolean
    nomineeParish?: boolean
    nomineeNationality?: boolean
    nomineeRegion?: boolean
    nomineeSubgroups?: boolean
    nomineeEducation?: boolean
    hasLeadershipPosition?: boolean
    leadershipPositions?: boolean
    hasServedCommittee?: boolean
    committees?: boolean
    skills?: boolean
    visionForOffice?: boolean
    knowledgeAboutOffice?: boolean
    approvalCount?: boolean
    rejectionCount?: boolean
    reviewedAt?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    subgroupId?: boolean
    aspirant?: boolean | UserDefaultArgs<ExtArgs>
    nominatorVerification?: boolean | Nomination$nominatorVerificationArgs<ExtArgs>
    guarantorVerifications?: boolean | Nomination$guarantorVerificationsArgs<ExtArgs>
    EcReview?: boolean | Nomination$EcReviewArgs<ExtArgs>
    candidate?: boolean | Nomination$candidateArgs<ExtArgs>
    User?: boolean | Nomination$UserArgs<ExtArgs>
    Subgroup?: boolean | Nomination$SubgroupArgs<ExtArgs>
    _count?: boolean | NominationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nomination"]>

  export type NominationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    aspirantId?: boolean
    nomineeName?: boolean
    nomineeEmail?: boolean
    nomineeContact?: boolean
    nomineePosition?: boolean
    photoUrl?: boolean
    photoPublicId?: boolean
    status?: boolean
    nomineeCollege?: boolean
    nomineeDepartment?: boolean
    nomineeDateOfBirth?: boolean
    nomineeHostel?: boolean
    nomineeRoom?: boolean
    nomineeSex?: boolean
    nomineeCwa?: boolean
    nomineeProgramme?: boolean
    nomineeLevel?: boolean
    nomineeParish?: boolean
    nomineeNationality?: boolean
    nomineeRegion?: boolean
    nomineeSubgroups?: boolean
    nomineeEducation?: boolean
    hasLeadershipPosition?: boolean
    leadershipPositions?: boolean
    hasServedCommittee?: boolean
    committees?: boolean
    skills?: boolean
    visionForOffice?: boolean
    knowledgeAboutOffice?: boolean
    approvalCount?: boolean
    rejectionCount?: boolean
    reviewedAt?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    subgroupId?: boolean
    aspirant?: boolean | UserDefaultArgs<ExtArgs>
    User?: boolean | Nomination$UserArgs<ExtArgs>
    Subgroup?: boolean | Nomination$SubgroupArgs<ExtArgs>
  }, ExtArgs["result"]["nomination"]>

  export type NominationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    aspirantId?: boolean
    nomineeName?: boolean
    nomineeEmail?: boolean
    nomineeContact?: boolean
    nomineePosition?: boolean
    photoUrl?: boolean
    photoPublicId?: boolean
    status?: boolean
    nomineeCollege?: boolean
    nomineeDepartment?: boolean
    nomineeDateOfBirth?: boolean
    nomineeHostel?: boolean
    nomineeRoom?: boolean
    nomineeSex?: boolean
    nomineeCwa?: boolean
    nomineeProgramme?: boolean
    nomineeLevel?: boolean
    nomineeParish?: boolean
    nomineeNationality?: boolean
    nomineeRegion?: boolean
    nomineeSubgroups?: boolean
    nomineeEducation?: boolean
    hasLeadershipPosition?: boolean
    leadershipPositions?: boolean
    hasServedCommittee?: boolean
    committees?: boolean
    skills?: boolean
    visionForOffice?: boolean
    knowledgeAboutOffice?: boolean
    approvalCount?: boolean
    rejectionCount?: boolean
    reviewedAt?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    subgroupId?: boolean
    aspirant?: boolean | UserDefaultArgs<ExtArgs>
    User?: boolean | Nomination$UserArgs<ExtArgs>
    Subgroup?: boolean | Nomination$SubgroupArgs<ExtArgs>
  }, ExtArgs["result"]["nomination"]>

  export type NominationSelectScalar = {
    id?: boolean
    aspirantId?: boolean
    nomineeName?: boolean
    nomineeEmail?: boolean
    nomineeContact?: boolean
    nomineePosition?: boolean
    photoUrl?: boolean
    photoPublicId?: boolean
    status?: boolean
    nomineeCollege?: boolean
    nomineeDepartment?: boolean
    nomineeDateOfBirth?: boolean
    nomineeHostel?: boolean
    nomineeRoom?: boolean
    nomineeSex?: boolean
    nomineeCwa?: boolean
    nomineeProgramme?: boolean
    nomineeLevel?: boolean
    nomineeParish?: boolean
    nomineeNationality?: boolean
    nomineeRegion?: boolean
    nomineeSubgroups?: boolean
    nomineeEducation?: boolean
    hasLeadershipPosition?: boolean
    leadershipPositions?: boolean
    hasServedCommittee?: boolean
    committees?: boolean
    skills?: boolean
    visionForOffice?: boolean
    knowledgeAboutOffice?: boolean
    approvalCount?: boolean
    rejectionCount?: boolean
    reviewedAt?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    subgroupId?: boolean
  }

  export type NominationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "aspirantId" | "nomineeName" | "nomineeEmail" | "nomineeContact" | "nomineePosition" | "photoUrl" | "photoPublicId" | "status" | "nomineeCollege" | "nomineeDepartment" | "nomineeDateOfBirth" | "nomineeHostel" | "nomineeRoom" | "nomineeSex" | "nomineeCwa" | "nomineeProgramme" | "nomineeLevel" | "nomineeParish" | "nomineeNationality" | "nomineeRegion" | "nomineeSubgroups" | "nomineeEducation" | "hasLeadershipPosition" | "leadershipPositions" | "hasServedCommittee" | "committees" | "skills" | "visionForOffice" | "knowledgeAboutOffice" | "approvalCount" | "rejectionCount" | "reviewedAt" | "rejectionReason" | "createdAt" | "updatedAt" | "userId" | "subgroupId", ExtArgs["result"]["nomination"]>
  export type NominationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aspirant?: boolean | UserDefaultArgs<ExtArgs>
    nominatorVerification?: boolean | Nomination$nominatorVerificationArgs<ExtArgs>
    guarantorVerifications?: boolean | Nomination$guarantorVerificationsArgs<ExtArgs>
    EcReview?: boolean | Nomination$EcReviewArgs<ExtArgs>
    candidate?: boolean | Nomination$candidateArgs<ExtArgs>
    User?: boolean | Nomination$UserArgs<ExtArgs>
    Subgroup?: boolean | Nomination$SubgroupArgs<ExtArgs>
    _count?: boolean | NominationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NominationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aspirant?: boolean | UserDefaultArgs<ExtArgs>
    User?: boolean | Nomination$UserArgs<ExtArgs>
    Subgroup?: boolean | Nomination$SubgroupArgs<ExtArgs>
  }
  export type NominationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aspirant?: boolean | UserDefaultArgs<ExtArgs>
    User?: boolean | Nomination$UserArgs<ExtArgs>
    Subgroup?: boolean | Nomination$SubgroupArgs<ExtArgs>
  }

  export type $NominationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Nomination"
    objects: {
      aspirant: Prisma.$UserPayload<ExtArgs>
      nominatorVerification: Prisma.$NominatorVerificationPayload<ExtArgs> | null
      guarantorVerifications: Prisma.$GuarantorVerificationPayload<ExtArgs>[]
      EcReview: Prisma.$EcReviewPayload<ExtArgs>[]
      candidate: Prisma.$CandidatePayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs> | null
      Subgroup: Prisma.$SubgroupPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      aspirantId: string
      nomineeName: string
      nomineeEmail: string
      nomineeContact: string
      nomineePosition: $Enums.Candidate_Position
      photoUrl: string | null
      photoPublicId: string | null
      status: $Enums.NominationStatus
      nomineeCollege: string
      nomineeDepartment: string
      nomineeDateOfBirth: Date
      nomineeHostel: string
      nomineeRoom: string
      nomineeSex: string
      nomineeCwa: string
      nomineeProgramme: string
      nomineeLevel: string
      nomineeParish: string
      nomineeNationality: string
      nomineeRegion: string
      nomineeSubgroups: string[]
      nomineeEducation: string[]
      hasLeadershipPosition: boolean
      leadershipPositions: string[]
      hasServedCommittee: boolean
      committees: string[]
      skills: string[]
      visionForOffice: string[]
      knowledgeAboutOffice: string[]
      approvalCount: number
      rejectionCount: number
      reviewedAt: Date | null
      rejectionReason: string | null
      createdAt: Date
      updatedAt: Date
      userId: string | null
      subgroupId: string | null
    }, ExtArgs["result"]["nomination"]>
    composites: {}
  }

  type NominationGetPayload<S extends boolean | null | undefined | NominationDefaultArgs> = $Result.GetResult<Prisma.$NominationPayload, S>

  type NominationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NominationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NominationCountAggregateInputType | true
    }

  export interface NominationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Nomination'], meta: { name: 'Nomination' } }
    /**
     * Find zero or one Nomination that matches the filter.
     * @param {NominationFindUniqueArgs} args - Arguments to find a Nomination
     * @example
     * // Get one Nomination
     * const nomination = await prisma.nomination.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NominationFindUniqueArgs>(args: SelectSubset<T, NominationFindUniqueArgs<ExtArgs>>): Prisma__NominationClient<$Result.GetResult<Prisma.$NominationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Nomination that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NominationFindUniqueOrThrowArgs} args - Arguments to find a Nomination
     * @example
     * // Get one Nomination
     * const nomination = await prisma.nomination.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NominationFindUniqueOrThrowArgs>(args: SelectSubset<T, NominationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NominationClient<$Result.GetResult<Prisma.$NominationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Nomination that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NominationFindFirstArgs} args - Arguments to find a Nomination
     * @example
     * // Get one Nomination
     * const nomination = await prisma.nomination.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NominationFindFirstArgs>(args?: SelectSubset<T, NominationFindFirstArgs<ExtArgs>>): Prisma__NominationClient<$Result.GetResult<Prisma.$NominationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Nomination that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NominationFindFirstOrThrowArgs} args - Arguments to find a Nomination
     * @example
     * // Get one Nomination
     * const nomination = await prisma.nomination.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NominationFindFirstOrThrowArgs>(args?: SelectSubset<T, NominationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NominationClient<$Result.GetResult<Prisma.$NominationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Nominations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NominationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Nominations
     * const nominations = await prisma.nomination.findMany()
     * 
     * // Get first 10 Nominations
     * const nominations = await prisma.nomination.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nominationWithIdOnly = await prisma.nomination.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NominationFindManyArgs>(args?: SelectSubset<T, NominationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NominationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Nomination.
     * @param {NominationCreateArgs} args - Arguments to create a Nomination.
     * @example
     * // Create one Nomination
     * const Nomination = await prisma.nomination.create({
     *   data: {
     *     // ... data to create a Nomination
     *   }
     * })
     * 
     */
    create<T extends NominationCreateArgs>(args: SelectSubset<T, NominationCreateArgs<ExtArgs>>): Prisma__NominationClient<$Result.GetResult<Prisma.$NominationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Nominations.
     * @param {NominationCreateManyArgs} args - Arguments to create many Nominations.
     * @example
     * // Create many Nominations
     * const nomination = await prisma.nomination.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NominationCreateManyArgs>(args?: SelectSubset<T, NominationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Nominations and returns the data saved in the database.
     * @param {NominationCreateManyAndReturnArgs} args - Arguments to create many Nominations.
     * @example
     * // Create many Nominations
     * const nomination = await prisma.nomination.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Nominations and only return the `id`
     * const nominationWithIdOnly = await prisma.nomination.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NominationCreateManyAndReturnArgs>(args?: SelectSubset<T, NominationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NominationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Nomination.
     * @param {NominationDeleteArgs} args - Arguments to delete one Nomination.
     * @example
     * // Delete one Nomination
     * const Nomination = await prisma.nomination.delete({
     *   where: {
     *     // ... filter to delete one Nomination
     *   }
     * })
     * 
     */
    delete<T extends NominationDeleteArgs>(args: SelectSubset<T, NominationDeleteArgs<ExtArgs>>): Prisma__NominationClient<$Result.GetResult<Prisma.$NominationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Nomination.
     * @param {NominationUpdateArgs} args - Arguments to update one Nomination.
     * @example
     * // Update one Nomination
     * const nomination = await prisma.nomination.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NominationUpdateArgs>(args: SelectSubset<T, NominationUpdateArgs<ExtArgs>>): Prisma__NominationClient<$Result.GetResult<Prisma.$NominationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Nominations.
     * @param {NominationDeleteManyArgs} args - Arguments to filter Nominations to delete.
     * @example
     * // Delete a few Nominations
     * const { count } = await prisma.nomination.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NominationDeleteManyArgs>(args?: SelectSubset<T, NominationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nominations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NominationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Nominations
     * const nomination = await prisma.nomination.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NominationUpdateManyArgs>(args: SelectSubset<T, NominationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nominations and returns the data updated in the database.
     * @param {NominationUpdateManyAndReturnArgs} args - Arguments to update many Nominations.
     * @example
     * // Update many Nominations
     * const nomination = await prisma.nomination.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Nominations and only return the `id`
     * const nominationWithIdOnly = await prisma.nomination.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NominationUpdateManyAndReturnArgs>(args: SelectSubset<T, NominationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NominationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Nomination.
     * @param {NominationUpsertArgs} args - Arguments to update or create a Nomination.
     * @example
     * // Update or create a Nomination
     * const nomination = await prisma.nomination.upsert({
     *   create: {
     *     // ... data to create a Nomination
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Nomination we want to update
     *   }
     * })
     */
    upsert<T extends NominationUpsertArgs>(args: SelectSubset<T, NominationUpsertArgs<ExtArgs>>): Prisma__NominationClient<$Result.GetResult<Prisma.$NominationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Nominations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NominationCountArgs} args - Arguments to filter Nominations to count.
     * @example
     * // Count the number of Nominations
     * const count = await prisma.nomination.count({
     *   where: {
     *     // ... the filter for the Nominations we want to count
     *   }
     * })
    **/
    count<T extends NominationCountArgs>(
      args?: Subset<T, NominationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NominationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Nomination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NominationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NominationAggregateArgs>(args: Subset<T, NominationAggregateArgs>): Prisma.PrismaPromise<GetNominationAggregateType<T>>

    /**
     * Group by Nomination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NominationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NominationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NominationGroupByArgs['orderBy'] }
        : { orderBy?: NominationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NominationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNominationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Nomination model
   */
  readonly fields: NominationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Nomination.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NominationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aspirant<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    nominatorVerification<T extends Nomination$nominatorVerificationArgs<ExtArgs> = {}>(args?: Subset<T, Nomination$nominatorVerificationArgs<ExtArgs>>): Prisma__NominatorVerificationClient<$Result.GetResult<Prisma.$NominatorVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    guarantorVerifications<T extends Nomination$guarantorVerificationsArgs<ExtArgs> = {}>(args?: Subset<T, Nomination$guarantorVerificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuarantorVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    EcReview<T extends Nomination$EcReviewArgs<ExtArgs> = {}>(args?: Subset<T, Nomination$EcReviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EcReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    candidate<T extends Nomination$candidateArgs<ExtArgs> = {}>(args?: Subset<T, Nomination$candidateArgs<ExtArgs>>): Prisma__CandidateClient<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User<T extends Nomination$UserArgs<ExtArgs> = {}>(args?: Subset<T, Nomination$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Subgroup<T extends Nomination$SubgroupArgs<ExtArgs> = {}>(args?: Subset<T, Nomination$SubgroupArgs<ExtArgs>>): Prisma__SubgroupClient<$Result.GetResult<Prisma.$SubgroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Nomination model
   */
  interface NominationFieldRefs {
    readonly id: FieldRef<"Nomination", 'String'>
    readonly aspirantId: FieldRef<"Nomination", 'String'>
    readonly nomineeName: FieldRef<"Nomination", 'String'>
    readonly nomineeEmail: FieldRef<"Nomination", 'String'>
    readonly nomineeContact: FieldRef<"Nomination", 'String'>
    readonly nomineePosition: FieldRef<"Nomination", 'Candidate_Position'>
    readonly photoUrl: FieldRef<"Nomination", 'String'>
    readonly photoPublicId: FieldRef<"Nomination", 'String'>
    readonly status: FieldRef<"Nomination", 'NominationStatus'>
    readonly nomineeCollege: FieldRef<"Nomination", 'String'>
    readonly nomineeDepartment: FieldRef<"Nomination", 'String'>
    readonly nomineeDateOfBirth: FieldRef<"Nomination", 'DateTime'>
    readonly nomineeHostel: FieldRef<"Nomination", 'String'>
    readonly nomineeRoom: FieldRef<"Nomination", 'String'>
    readonly nomineeSex: FieldRef<"Nomination", 'String'>
    readonly nomineeCwa: FieldRef<"Nomination", 'String'>
    readonly nomineeProgramme: FieldRef<"Nomination", 'String'>
    readonly nomineeLevel: FieldRef<"Nomination", 'String'>
    readonly nomineeParish: FieldRef<"Nomination", 'String'>
    readonly nomineeNationality: FieldRef<"Nomination", 'String'>
    readonly nomineeRegion: FieldRef<"Nomination", 'String'>
    readonly nomineeSubgroups: FieldRef<"Nomination", 'String[]'>
    readonly nomineeEducation: FieldRef<"Nomination", 'String[]'>
    readonly hasLeadershipPosition: FieldRef<"Nomination", 'Boolean'>
    readonly leadershipPositions: FieldRef<"Nomination", 'String[]'>
    readonly hasServedCommittee: FieldRef<"Nomination", 'Boolean'>
    readonly committees: FieldRef<"Nomination", 'String[]'>
    readonly skills: FieldRef<"Nomination", 'String[]'>
    readonly visionForOffice: FieldRef<"Nomination", 'String[]'>
    readonly knowledgeAboutOffice: FieldRef<"Nomination", 'String[]'>
    readonly approvalCount: FieldRef<"Nomination", 'Int'>
    readonly rejectionCount: FieldRef<"Nomination", 'Int'>
    readonly reviewedAt: FieldRef<"Nomination", 'DateTime'>
    readonly rejectionReason: FieldRef<"Nomination", 'String'>
    readonly createdAt: FieldRef<"Nomination", 'DateTime'>
    readonly updatedAt: FieldRef<"Nomination", 'DateTime'>
    readonly userId: FieldRef<"Nomination", 'String'>
    readonly subgroupId: FieldRef<"Nomination", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Nomination findUnique
   */
  export type NominationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nomination
     */
    select?: NominationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nomination
     */
    omit?: NominationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominationInclude<ExtArgs> | null
    /**
     * Filter, which Nomination to fetch.
     */
    where: NominationWhereUniqueInput
  }

  /**
   * Nomination findUniqueOrThrow
   */
  export type NominationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nomination
     */
    select?: NominationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nomination
     */
    omit?: NominationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominationInclude<ExtArgs> | null
    /**
     * Filter, which Nomination to fetch.
     */
    where: NominationWhereUniqueInput
  }

  /**
   * Nomination findFirst
   */
  export type NominationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nomination
     */
    select?: NominationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nomination
     */
    omit?: NominationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominationInclude<ExtArgs> | null
    /**
     * Filter, which Nomination to fetch.
     */
    where?: NominationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nominations to fetch.
     */
    orderBy?: NominationOrderByWithRelationInput | NominationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nominations.
     */
    cursor?: NominationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nominations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nominations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nominations.
     */
    distinct?: NominationScalarFieldEnum | NominationScalarFieldEnum[]
  }

  /**
   * Nomination findFirstOrThrow
   */
  export type NominationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nomination
     */
    select?: NominationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nomination
     */
    omit?: NominationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominationInclude<ExtArgs> | null
    /**
     * Filter, which Nomination to fetch.
     */
    where?: NominationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nominations to fetch.
     */
    orderBy?: NominationOrderByWithRelationInput | NominationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nominations.
     */
    cursor?: NominationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nominations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nominations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nominations.
     */
    distinct?: NominationScalarFieldEnum | NominationScalarFieldEnum[]
  }

  /**
   * Nomination findMany
   */
  export type NominationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nomination
     */
    select?: NominationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nomination
     */
    omit?: NominationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominationInclude<ExtArgs> | null
    /**
     * Filter, which Nominations to fetch.
     */
    where?: NominationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nominations to fetch.
     */
    orderBy?: NominationOrderByWithRelationInput | NominationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Nominations.
     */
    cursor?: NominationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nominations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nominations.
     */
    skip?: number
    distinct?: NominationScalarFieldEnum | NominationScalarFieldEnum[]
  }

  /**
   * Nomination create
   */
  export type NominationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nomination
     */
    select?: NominationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nomination
     */
    omit?: NominationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominationInclude<ExtArgs> | null
    /**
     * The data needed to create a Nomination.
     */
    data: XOR<NominationCreateInput, NominationUncheckedCreateInput>
  }

  /**
   * Nomination createMany
   */
  export type NominationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Nominations.
     */
    data: NominationCreateManyInput | NominationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Nomination createManyAndReturn
   */
  export type NominationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nomination
     */
    select?: NominationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Nomination
     */
    omit?: NominationOmit<ExtArgs> | null
    /**
     * The data used to create many Nominations.
     */
    data: NominationCreateManyInput | NominationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Nomination update
   */
  export type NominationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nomination
     */
    select?: NominationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nomination
     */
    omit?: NominationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominationInclude<ExtArgs> | null
    /**
     * The data needed to update a Nomination.
     */
    data: XOR<NominationUpdateInput, NominationUncheckedUpdateInput>
    /**
     * Choose, which Nomination to update.
     */
    where: NominationWhereUniqueInput
  }

  /**
   * Nomination updateMany
   */
  export type NominationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Nominations.
     */
    data: XOR<NominationUpdateManyMutationInput, NominationUncheckedUpdateManyInput>
    /**
     * Filter which Nominations to update
     */
    where?: NominationWhereInput
    /**
     * Limit how many Nominations to update.
     */
    limit?: number
  }

  /**
   * Nomination updateManyAndReturn
   */
  export type NominationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nomination
     */
    select?: NominationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Nomination
     */
    omit?: NominationOmit<ExtArgs> | null
    /**
     * The data used to update Nominations.
     */
    data: XOR<NominationUpdateManyMutationInput, NominationUncheckedUpdateManyInput>
    /**
     * Filter which Nominations to update
     */
    where?: NominationWhereInput
    /**
     * Limit how many Nominations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Nomination upsert
   */
  export type NominationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nomination
     */
    select?: NominationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nomination
     */
    omit?: NominationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominationInclude<ExtArgs> | null
    /**
     * The filter to search for the Nomination to update in case it exists.
     */
    where: NominationWhereUniqueInput
    /**
     * In case the Nomination found by the `where` argument doesn't exist, create a new Nomination with this data.
     */
    create: XOR<NominationCreateInput, NominationUncheckedCreateInput>
    /**
     * In case the Nomination was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NominationUpdateInput, NominationUncheckedUpdateInput>
  }

  /**
   * Nomination delete
   */
  export type NominationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nomination
     */
    select?: NominationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nomination
     */
    omit?: NominationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominationInclude<ExtArgs> | null
    /**
     * Filter which Nomination to delete.
     */
    where: NominationWhereUniqueInput
  }

  /**
   * Nomination deleteMany
   */
  export type NominationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nominations to delete
     */
    where?: NominationWhereInput
    /**
     * Limit how many Nominations to delete.
     */
    limit?: number
  }

  /**
   * Nomination.nominatorVerification
   */
  export type Nomination$nominatorVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NominatorVerification
     */
    select?: NominatorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NominatorVerification
     */
    omit?: NominatorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominatorVerificationInclude<ExtArgs> | null
    where?: NominatorVerificationWhereInput
  }

  /**
   * Nomination.guarantorVerifications
   */
  export type Nomination$guarantorVerificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuarantorVerification
     */
    select?: GuarantorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuarantorVerification
     */
    omit?: GuarantorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorVerificationInclude<ExtArgs> | null
    where?: GuarantorVerificationWhereInput
    orderBy?: GuarantorVerificationOrderByWithRelationInput | GuarantorVerificationOrderByWithRelationInput[]
    cursor?: GuarantorVerificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GuarantorVerificationScalarFieldEnum | GuarantorVerificationScalarFieldEnum[]
  }

  /**
   * Nomination.EcReview
   */
  export type Nomination$EcReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcReview
     */
    select?: EcReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcReview
     */
    omit?: EcReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcReviewInclude<ExtArgs> | null
    where?: EcReviewWhereInput
    orderBy?: EcReviewOrderByWithRelationInput | EcReviewOrderByWithRelationInput[]
    cursor?: EcReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EcReviewScalarFieldEnum | EcReviewScalarFieldEnum[]
  }

  /**
   * Nomination.candidate
   */
  export type Nomination$candidateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateInclude<ExtArgs> | null
    where?: CandidateWhereInput
  }

  /**
   * Nomination.User
   */
  export type Nomination$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Nomination.Subgroup
   */
  export type Nomination$SubgroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null
    where?: SubgroupWhereInput
  }

  /**
   * Nomination without action
   */
  export type NominationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nomination
     */
    select?: NominationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nomination
     */
    omit?: NominationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominationInclude<ExtArgs> | null
  }


  /**
   * Model NominatorVerification
   */

  export type AggregateNominatorVerification = {
    _count: NominatorVerificationCountAggregateOutputType | null
    _min: NominatorVerificationMinAggregateOutputType | null
    _max: NominatorVerificationMaxAggregateOutputType | null
  }

  export type NominatorVerificationMinAggregateOutputType = {
    id: string | null
    nominationId: string | null
    name: string | null
    email: string | null
    contact: string | null
    programme: string | null
    level: string | null
    subgroup: string | null
    status: string | null
    comments: string | null
    verifiedAt: Date | null
    declinedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type NominatorVerificationMaxAggregateOutputType = {
    id: string | null
    nominationId: string | null
    name: string | null
    email: string | null
    contact: string | null
    programme: string | null
    level: string | null
    subgroup: string | null
    status: string | null
    comments: string | null
    verifiedAt: Date | null
    declinedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type NominatorVerificationCountAggregateOutputType = {
    id: number
    nominationId: number
    name: number
    email: number
    contact: number
    programme: number
    level: number
    subgroup: number
    status: number
    comments: number
    verifiedAt: number
    declinedAt: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type NominatorVerificationMinAggregateInputType = {
    id?: true
    nominationId?: true
    name?: true
    email?: true
    contact?: true
    programme?: true
    level?: true
    subgroup?: true
    status?: true
    comments?: true
    verifiedAt?: true
    declinedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type NominatorVerificationMaxAggregateInputType = {
    id?: true
    nominationId?: true
    name?: true
    email?: true
    contact?: true
    programme?: true
    level?: true
    subgroup?: true
    status?: true
    comments?: true
    verifiedAt?: true
    declinedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type NominatorVerificationCountAggregateInputType = {
    id?: true
    nominationId?: true
    name?: true
    email?: true
    contact?: true
    programme?: true
    level?: true
    subgroup?: true
    status?: true
    comments?: true
    verifiedAt?: true
    declinedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type NominatorVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NominatorVerification to aggregate.
     */
    where?: NominatorVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NominatorVerifications to fetch.
     */
    orderBy?: NominatorVerificationOrderByWithRelationInput | NominatorVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NominatorVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NominatorVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NominatorVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NominatorVerifications
    **/
    _count?: true | NominatorVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NominatorVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NominatorVerificationMaxAggregateInputType
  }

  export type GetNominatorVerificationAggregateType<T extends NominatorVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNominatorVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNominatorVerification[P]>
      : GetScalarType<T[P], AggregateNominatorVerification[P]>
  }




  export type NominatorVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NominatorVerificationWhereInput
    orderBy?: NominatorVerificationOrderByWithAggregationInput | NominatorVerificationOrderByWithAggregationInput[]
    by: NominatorVerificationScalarFieldEnum[] | NominatorVerificationScalarFieldEnum
    having?: NominatorVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NominatorVerificationCountAggregateInputType | true
    _min?: NominatorVerificationMinAggregateInputType
    _max?: NominatorVerificationMaxAggregateInputType
  }

  export type NominatorVerificationGroupByOutputType = {
    id: string
    nominationId: string
    name: string
    email: string
    contact: string
    programme: string
    level: string
    subgroup: string
    status: string
    comments: string | null
    verifiedAt: Date | null
    declinedAt: Date | null
    createdAt: Date
    updatedAt: Date
    userId: string | null
    _count: NominatorVerificationCountAggregateOutputType | null
    _min: NominatorVerificationMinAggregateOutputType | null
    _max: NominatorVerificationMaxAggregateOutputType | null
  }

  type GetNominatorVerificationGroupByPayload<T extends NominatorVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NominatorVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NominatorVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NominatorVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], NominatorVerificationGroupByOutputType[P]>
        }
      >
    >


  export type NominatorVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nominationId?: boolean
    name?: boolean
    email?: boolean
    contact?: boolean
    programme?: boolean
    level?: boolean
    subgroup?: boolean
    status?: boolean
    comments?: boolean
    verifiedAt?: boolean
    declinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
    verificationToken?: boolean | NominatorVerification$verificationTokenArgs<ExtArgs>
    User?: boolean | NominatorVerification$UserArgs<ExtArgs>
  }, ExtArgs["result"]["nominatorVerification"]>

  export type NominatorVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nominationId?: boolean
    name?: boolean
    email?: boolean
    contact?: boolean
    programme?: boolean
    level?: boolean
    subgroup?: boolean
    status?: boolean
    comments?: boolean
    verifiedAt?: boolean
    declinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
    User?: boolean | NominatorVerification$UserArgs<ExtArgs>
  }, ExtArgs["result"]["nominatorVerification"]>

  export type NominatorVerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nominationId?: boolean
    name?: boolean
    email?: boolean
    contact?: boolean
    programme?: boolean
    level?: boolean
    subgroup?: boolean
    status?: boolean
    comments?: boolean
    verifiedAt?: boolean
    declinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
    User?: boolean | NominatorVerification$UserArgs<ExtArgs>
  }, ExtArgs["result"]["nominatorVerification"]>

  export type NominatorVerificationSelectScalar = {
    id?: boolean
    nominationId?: boolean
    name?: boolean
    email?: boolean
    contact?: boolean
    programme?: boolean
    level?: boolean
    subgroup?: boolean
    status?: boolean
    comments?: boolean
    verifiedAt?: boolean
    declinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type NominatorVerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nominationId" | "name" | "email" | "contact" | "programme" | "level" | "subgroup" | "status" | "comments" | "verifiedAt" | "declinedAt" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["nominatorVerification"]>
  export type NominatorVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
    verificationToken?: boolean | NominatorVerification$verificationTokenArgs<ExtArgs>
    User?: boolean | NominatorVerification$UserArgs<ExtArgs>
  }
  export type NominatorVerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
    User?: boolean | NominatorVerification$UserArgs<ExtArgs>
  }
  export type NominatorVerificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
    User?: boolean | NominatorVerification$UserArgs<ExtArgs>
  }

  export type $NominatorVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NominatorVerification"
    objects: {
      nomination: Prisma.$NominationPayload<ExtArgs>
      verificationToken: Prisma.$VerificationTokenPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nominationId: string
      name: string
      email: string
      contact: string
      programme: string
      level: string
      subgroup: string
      status: string
      comments: string | null
      verifiedAt: Date | null
      declinedAt: Date | null
      createdAt: Date
      updatedAt: Date
      userId: string | null
    }, ExtArgs["result"]["nominatorVerification"]>
    composites: {}
  }

  type NominatorVerificationGetPayload<S extends boolean | null | undefined | NominatorVerificationDefaultArgs> = $Result.GetResult<Prisma.$NominatorVerificationPayload, S>

  type NominatorVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NominatorVerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NominatorVerificationCountAggregateInputType | true
    }

  export interface NominatorVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NominatorVerification'], meta: { name: 'NominatorVerification' } }
    /**
     * Find zero or one NominatorVerification that matches the filter.
     * @param {NominatorVerificationFindUniqueArgs} args - Arguments to find a NominatorVerification
     * @example
     * // Get one NominatorVerification
     * const nominatorVerification = await prisma.nominatorVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NominatorVerificationFindUniqueArgs>(args: SelectSubset<T, NominatorVerificationFindUniqueArgs<ExtArgs>>): Prisma__NominatorVerificationClient<$Result.GetResult<Prisma.$NominatorVerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NominatorVerification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NominatorVerificationFindUniqueOrThrowArgs} args - Arguments to find a NominatorVerification
     * @example
     * // Get one NominatorVerification
     * const nominatorVerification = await prisma.nominatorVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NominatorVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NominatorVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NominatorVerificationClient<$Result.GetResult<Prisma.$NominatorVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NominatorVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NominatorVerificationFindFirstArgs} args - Arguments to find a NominatorVerification
     * @example
     * // Get one NominatorVerification
     * const nominatorVerification = await prisma.nominatorVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NominatorVerificationFindFirstArgs>(args?: SelectSubset<T, NominatorVerificationFindFirstArgs<ExtArgs>>): Prisma__NominatorVerificationClient<$Result.GetResult<Prisma.$NominatorVerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NominatorVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NominatorVerificationFindFirstOrThrowArgs} args - Arguments to find a NominatorVerification
     * @example
     * // Get one NominatorVerification
     * const nominatorVerification = await prisma.nominatorVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NominatorVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NominatorVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NominatorVerificationClient<$Result.GetResult<Prisma.$NominatorVerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NominatorVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NominatorVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NominatorVerifications
     * const nominatorVerifications = await prisma.nominatorVerification.findMany()
     * 
     * // Get first 10 NominatorVerifications
     * const nominatorVerifications = await prisma.nominatorVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nominatorVerificationWithIdOnly = await prisma.nominatorVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NominatorVerificationFindManyArgs>(args?: SelectSubset<T, NominatorVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NominatorVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NominatorVerification.
     * @param {NominatorVerificationCreateArgs} args - Arguments to create a NominatorVerification.
     * @example
     * // Create one NominatorVerification
     * const NominatorVerification = await prisma.nominatorVerification.create({
     *   data: {
     *     // ... data to create a NominatorVerification
     *   }
     * })
     * 
     */
    create<T extends NominatorVerificationCreateArgs>(args: SelectSubset<T, NominatorVerificationCreateArgs<ExtArgs>>): Prisma__NominatorVerificationClient<$Result.GetResult<Prisma.$NominatorVerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NominatorVerifications.
     * @param {NominatorVerificationCreateManyArgs} args - Arguments to create many NominatorVerifications.
     * @example
     * // Create many NominatorVerifications
     * const nominatorVerification = await prisma.nominatorVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NominatorVerificationCreateManyArgs>(args?: SelectSubset<T, NominatorVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NominatorVerifications and returns the data saved in the database.
     * @param {NominatorVerificationCreateManyAndReturnArgs} args - Arguments to create many NominatorVerifications.
     * @example
     * // Create many NominatorVerifications
     * const nominatorVerification = await prisma.nominatorVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NominatorVerifications and only return the `id`
     * const nominatorVerificationWithIdOnly = await prisma.nominatorVerification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NominatorVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NominatorVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NominatorVerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NominatorVerification.
     * @param {NominatorVerificationDeleteArgs} args - Arguments to delete one NominatorVerification.
     * @example
     * // Delete one NominatorVerification
     * const NominatorVerification = await prisma.nominatorVerification.delete({
     *   where: {
     *     // ... filter to delete one NominatorVerification
     *   }
     * })
     * 
     */
    delete<T extends NominatorVerificationDeleteArgs>(args: SelectSubset<T, NominatorVerificationDeleteArgs<ExtArgs>>): Prisma__NominatorVerificationClient<$Result.GetResult<Prisma.$NominatorVerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NominatorVerification.
     * @param {NominatorVerificationUpdateArgs} args - Arguments to update one NominatorVerification.
     * @example
     * // Update one NominatorVerification
     * const nominatorVerification = await prisma.nominatorVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NominatorVerificationUpdateArgs>(args: SelectSubset<T, NominatorVerificationUpdateArgs<ExtArgs>>): Prisma__NominatorVerificationClient<$Result.GetResult<Prisma.$NominatorVerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NominatorVerifications.
     * @param {NominatorVerificationDeleteManyArgs} args - Arguments to filter NominatorVerifications to delete.
     * @example
     * // Delete a few NominatorVerifications
     * const { count } = await prisma.nominatorVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NominatorVerificationDeleteManyArgs>(args?: SelectSubset<T, NominatorVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NominatorVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NominatorVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NominatorVerifications
     * const nominatorVerification = await prisma.nominatorVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NominatorVerificationUpdateManyArgs>(args: SelectSubset<T, NominatorVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NominatorVerifications and returns the data updated in the database.
     * @param {NominatorVerificationUpdateManyAndReturnArgs} args - Arguments to update many NominatorVerifications.
     * @example
     * // Update many NominatorVerifications
     * const nominatorVerification = await prisma.nominatorVerification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NominatorVerifications and only return the `id`
     * const nominatorVerificationWithIdOnly = await prisma.nominatorVerification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NominatorVerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NominatorVerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NominatorVerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NominatorVerification.
     * @param {NominatorVerificationUpsertArgs} args - Arguments to update or create a NominatorVerification.
     * @example
     * // Update or create a NominatorVerification
     * const nominatorVerification = await prisma.nominatorVerification.upsert({
     *   create: {
     *     // ... data to create a NominatorVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NominatorVerification we want to update
     *   }
     * })
     */
    upsert<T extends NominatorVerificationUpsertArgs>(args: SelectSubset<T, NominatorVerificationUpsertArgs<ExtArgs>>): Prisma__NominatorVerificationClient<$Result.GetResult<Prisma.$NominatorVerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NominatorVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NominatorVerificationCountArgs} args - Arguments to filter NominatorVerifications to count.
     * @example
     * // Count the number of NominatorVerifications
     * const count = await prisma.nominatorVerification.count({
     *   where: {
     *     // ... the filter for the NominatorVerifications we want to count
     *   }
     * })
    **/
    count<T extends NominatorVerificationCountArgs>(
      args?: Subset<T, NominatorVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NominatorVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NominatorVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NominatorVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NominatorVerificationAggregateArgs>(args: Subset<T, NominatorVerificationAggregateArgs>): Prisma.PrismaPromise<GetNominatorVerificationAggregateType<T>>

    /**
     * Group by NominatorVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NominatorVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NominatorVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NominatorVerificationGroupByArgs['orderBy'] }
        : { orderBy?: NominatorVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NominatorVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNominatorVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NominatorVerification model
   */
  readonly fields: NominatorVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NominatorVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NominatorVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nomination<T extends NominationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NominationDefaultArgs<ExtArgs>>): Prisma__NominationClient<$Result.GetResult<Prisma.$NominationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    verificationToken<T extends NominatorVerification$verificationTokenArgs<ExtArgs> = {}>(args?: Subset<T, NominatorVerification$verificationTokenArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User<T extends NominatorVerification$UserArgs<ExtArgs> = {}>(args?: Subset<T, NominatorVerification$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NominatorVerification model
   */
  interface NominatorVerificationFieldRefs {
    readonly id: FieldRef<"NominatorVerification", 'String'>
    readonly nominationId: FieldRef<"NominatorVerification", 'String'>
    readonly name: FieldRef<"NominatorVerification", 'String'>
    readonly email: FieldRef<"NominatorVerification", 'String'>
    readonly contact: FieldRef<"NominatorVerification", 'String'>
    readonly programme: FieldRef<"NominatorVerification", 'String'>
    readonly level: FieldRef<"NominatorVerification", 'String'>
    readonly subgroup: FieldRef<"NominatorVerification", 'String'>
    readonly status: FieldRef<"NominatorVerification", 'String'>
    readonly comments: FieldRef<"NominatorVerification", 'String'>
    readonly verifiedAt: FieldRef<"NominatorVerification", 'DateTime'>
    readonly declinedAt: FieldRef<"NominatorVerification", 'DateTime'>
    readonly createdAt: FieldRef<"NominatorVerification", 'DateTime'>
    readonly updatedAt: FieldRef<"NominatorVerification", 'DateTime'>
    readonly userId: FieldRef<"NominatorVerification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NominatorVerification findUnique
   */
  export type NominatorVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NominatorVerification
     */
    select?: NominatorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NominatorVerification
     */
    omit?: NominatorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominatorVerificationInclude<ExtArgs> | null
    /**
     * Filter, which NominatorVerification to fetch.
     */
    where: NominatorVerificationWhereUniqueInput
  }

  /**
   * NominatorVerification findUniqueOrThrow
   */
  export type NominatorVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NominatorVerification
     */
    select?: NominatorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NominatorVerification
     */
    omit?: NominatorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominatorVerificationInclude<ExtArgs> | null
    /**
     * Filter, which NominatorVerification to fetch.
     */
    where: NominatorVerificationWhereUniqueInput
  }

  /**
   * NominatorVerification findFirst
   */
  export type NominatorVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NominatorVerification
     */
    select?: NominatorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NominatorVerification
     */
    omit?: NominatorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominatorVerificationInclude<ExtArgs> | null
    /**
     * Filter, which NominatorVerification to fetch.
     */
    where?: NominatorVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NominatorVerifications to fetch.
     */
    orderBy?: NominatorVerificationOrderByWithRelationInput | NominatorVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NominatorVerifications.
     */
    cursor?: NominatorVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NominatorVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NominatorVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NominatorVerifications.
     */
    distinct?: NominatorVerificationScalarFieldEnum | NominatorVerificationScalarFieldEnum[]
  }

  /**
   * NominatorVerification findFirstOrThrow
   */
  export type NominatorVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NominatorVerification
     */
    select?: NominatorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NominatorVerification
     */
    omit?: NominatorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominatorVerificationInclude<ExtArgs> | null
    /**
     * Filter, which NominatorVerification to fetch.
     */
    where?: NominatorVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NominatorVerifications to fetch.
     */
    orderBy?: NominatorVerificationOrderByWithRelationInput | NominatorVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NominatorVerifications.
     */
    cursor?: NominatorVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NominatorVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NominatorVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NominatorVerifications.
     */
    distinct?: NominatorVerificationScalarFieldEnum | NominatorVerificationScalarFieldEnum[]
  }

  /**
   * NominatorVerification findMany
   */
  export type NominatorVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NominatorVerification
     */
    select?: NominatorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NominatorVerification
     */
    omit?: NominatorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominatorVerificationInclude<ExtArgs> | null
    /**
     * Filter, which NominatorVerifications to fetch.
     */
    where?: NominatorVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NominatorVerifications to fetch.
     */
    orderBy?: NominatorVerificationOrderByWithRelationInput | NominatorVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NominatorVerifications.
     */
    cursor?: NominatorVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NominatorVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NominatorVerifications.
     */
    skip?: number
    distinct?: NominatorVerificationScalarFieldEnum | NominatorVerificationScalarFieldEnum[]
  }

  /**
   * NominatorVerification create
   */
  export type NominatorVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NominatorVerification
     */
    select?: NominatorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NominatorVerification
     */
    omit?: NominatorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominatorVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a NominatorVerification.
     */
    data: XOR<NominatorVerificationCreateInput, NominatorVerificationUncheckedCreateInput>
  }

  /**
   * NominatorVerification createMany
   */
  export type NominatorVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NominatorVerifications.
     */
    data: NominatorVerificationCreateManyInput | NominatorVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NominatorVerification createManyAndReturn
   */
  export type NominatorVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NominatorVerification
     */
    select?: NominatorVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NominatorVerification
     */
    omit?: NominatorVerificationOmit<ExtArgs> | null
    /**
     * The data used to create many NominatorVerifications.
     */
    data: NominatorVerificationCreateManyInput | NominatorVerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominatorVerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NominatorVerification update
   */
  export type NominatorVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NominatorVerification
     */
    select?: NominatorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NominatorVerification
     */
    omit?: NominatorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominatorVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a NominatorVerification.
     */
    data: XOR<NominatorVerificationUpdateInput, NominatorVerificationUncheckedUpdateInput>
    /**
     * Choose, which NominatorVerification to update.
     */
    where: NominatorVerificationWhereUniqueInput
  }

  /**
   * NominatorVerification updateMany
   */
  export type NominatorVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NominatorVerifications.
     */
    data: XOR<NominatorVerificationUpdateManyMutationInput, NominatorVerificationUncheckedUpdateManyInput>
    /**
     * Filter which NominatorVerifications to update
     */
    where?: NominatorVerificationWhereInput
    /**
     * Limit how many NominatorVerifications to update.
     */
    limit?: number
  }

  /**
   * NominatorVerification updateManyAndReturn
   */
  export type NominatorVerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NominatorVerification
     */
    select?: NominatorVerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NominatorVerification
     */
    omit?: NominatorVerificationOmit<ExtArgs> | null
    /**
     * The data used to update NominatorVerifications.
     */
    data: XOR<NominatorVerificationUpdateManyMutationInput, NominatorVerificationUncheckedUpdateManyInput>
    /**
     * Filter which NominatorVerifications to update
     */
    where?: NominatorVerificationWhereInput
    /**
     * Limit how many NominatorVerifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominatorVerificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NominatorVerification upsert
   */
  export type NominatorVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NominatorVerification
     */
    select?: NominatorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NominatorVerification
     */
    omit?: NominatorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominatorVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the NominatorVerification to update in case it exists.
     */
    where: NominatorVerificationWhereUniqueInput
    /**
     * In case the NominatorVerification found by the `where` argument doesn't exist, create a new NominatorVerification with this data.
     */
    create: XOR<NominatorVerificationCreateInput, NominatorVerificationUncheckedCreateInput>
    /**
     * In case the NominatorVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NominatorVerificationUpdateInput, NominatorVerificationUncheckedUpdateInput>
  }

  /**
   * NominatorVerification delete
   */
  export type NominatorVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NominatorVerification
     */
    select?: NominatorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NominatorVerification
     */
    omit?: NominatorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominatorVerificationInclude<ExtArgs> | null
    /**
     * Filter which NominatorVerification to delete.
     */
    where: NominatorVerificationWhereUniqueInput
  }

  /**
   * NominatorVerification deleteMany
   */
  export type NominatorVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NominatorVerifications to delete
     */
    where?: NominatorVerificationWhereInput
    /**
     * Limit how many NominatorVerifications to delete.
     */
    limit?: number
  }

  /**
   * NominatorVerification.verificationToken
   */
  export type NominatorVerification$verificationTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    where?: VerificationTokenWhereInput
  }

  /**
   * NominatorVerification.User
   */
  export type NominatorVerification$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * NominatorVerification without action
   */
  export type NominatorVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NominatorVerification
     */
    select?: NominatorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NominatorVerification
     */
    omit?: NominatorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominatorVerificationInclude<ExtArgs> | null
  }


  /**
   * Model GuarantorVerification
   */

  export type AggregateGuarantorVerification = {
    _count: GuarantorVerificationCountAggregateOutputType | null
    _min: GuarantorVerificationMinAggregateOutputType | null
    _max: GuarantorVerificationMaxAggregateOutputType | null
  }

  export type GuarantorVerificationMinAggregateOutputType = {
    id: string | null
    nominationId: string | null
    name: string | null
    email: string | null
    contact: string | null
    programme: string | null
    subgroup: string | null
    status: string | null
    comments: string | null
    verifiedAt: Date | null
    declinedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    verificationTokenId: string | null
    userId: string | null
  }

  export type GuarantorVerificationMaxAggregateOutputType = {
    id: string | null
    nominationId: string | null
    name: string | null
    email: string | null
    contact: string | null
    programme: string | null
    subgroup: string | null
    status: string | null
    comments: string | null
    verifiedAt: Date | null
    declinedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    verificationTokenId: string | null
    userId: string | null
  }

  export type GuarantorVerificationCountAggregateOutputType = {
    id: number
    nominationId: number
    name: number
    email: number
    contact: number
    programme: number
    subgroup: number
    status: number
    comments: number
    verifiedAt: number
    declinedAt: number
    createdAt: number
    updatedAt: number
    verificationTokenId: number
    userId: number
    _all: number
  }


  export type GuarantorVerificationMinAggregateInputType = {
    id?: true
    nominationId?: true
    name?: true
    email?: true
    contact?: true
    programme?: true
    subgroup?: true
    status?: true
    comments?: true
    verifiedAt?: true
    declinedAt?: true
    createdAt?: true
    updatedAt?: true
    verificationTokenId?: true
    userId?: true
  }

  export type GuarantorVerificationMaxAggregateInputType = {
    id?: true
    nominationId?: true
    name?: true
    email?: true
    contact?: true
    programme?: true
    subgroup?: true
    status?: true
    comments?: true
    verifiedAt?: true
    declinedAt?: true
    createdAt?: true
    updatedAt?: true
    verificationTokenId?: true
    userId?: true
  }

  export type GuarantorVerificationCountAggregateInputType = {
    id?: true
    nominationId?: true
    name?: true
    email?: true
    contact?: true
    programme?: true
    subgroup?: true
    status?: true
    comments?: true
    verifiedAt?: true
    declinedAt?: true
    createdAt?: true
    updatedAt?: true
    verificationTokenId?: true
    userId?: true
    _all?: true
  }

  export type GuarantorVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuarantorVerification to aggregate.
     */
    where?: GuarantorVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuarantorVerifications to fetch.
     */
    orderBy?: GuarantorVerificationOrderByWithRelationInput | GuarantorVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuarantorVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuarantorVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuarantorVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuarantorVerifications
    **/
    _count?: true | GuarantorVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuarantorVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuarantorVerificationMaxAggregateInputType
  }

  export type GetGuarantorVerificationAggregateType<T extends GuarantorVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateGuarantorVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuarantorVerification[P]>
      : GetScalarType<T[P], AggregateGuarantorVerification[P]>
  }




  export type GuarantorVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuarantorVerificationWhereInput
    orderBy?: GuarantorVerificationOrderByWithAggregationInput | GuarantorVerificationOrderByWithAggregationInput[]
    by: GuarantorVerificationScalarFieldEnum[] | GuarantorVerificationScalarFieldEnum
    having?: GuarantorVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuarantorVerificationCountAggregateInputType | true
    _min?: GuarantorVerificationMinAggregateInputType
    _max?: GuarantorVerificationMaxAggregateInputType
  }

  export type GuarantorVerificationGroupByOutputType = {
    id: string
    nominationId: string
    name: string
    email: string
    contact: string
    programme: string
    subgroup: string
    status: string
    comments: string | null
    verifiedAt: Date | null
    declinedAt: Date | null
    createdAt: Date
    updatedAt: Date
    verificationTokenId: string | null
    userId: string | null
    _count: GuarantorVerificationCountAggregateOutputType | null
    _min: GuarantorVerificationMinAggregateOutputType | null
    _max: GuarantorVerificationMaxAggregateOutputType | null
  }

  type GetGuarantorVerificationGroupByPayload<T extends GuarantorVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuarantorVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuarantorVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuarantorVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], GuarantorVerificationGroupByOutputType[P]>
        }
      >
    >


  export type GuarantorVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nominationId?: boolean
    name?: boolean
    email?: boolean
    contact?: boolean
    programme?: boolean
    subgroup?: boolean
    status?: boolean
    comments?: boolean
    verifiedAt?: boolean
    declinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verificationTokenId?: boolean
    userId?: boolean
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
    verificationToken?: boolean | GuarantorVerification$verificationTokenArgs<ExtArgs>
    User?: boolean | GuarantorVerification$UserArgs<ExtArgs>
  }, ExtArgs["result"]["guarantorVerification"]>

  export type GuarantorVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nominationId?: boolean
    name?: boolean
    email?: boolean
    contact?: boolean
    programme?: boolean
    subgroup?: boolean
    status?: boolean
    comments?: boolean
    verifiedAt?: boolean
    declinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verificationTokenId?: boolean
    userId?: boolean
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
    User?: boolean | GuarantorVerification$UserArgs<ExtArgs>
  }, ExtArgs["result"]["guarantorVerification"]>

  export type GuarantorVerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nominationId?: boolean
    name?: boolean
    email?: boolean
    contact?: boolean
    programme?: boolean
    subgroup?: boolean
    status?: boolean
    comments?: boolean
    verifiedAt?: boolean
    declinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verificationTokenId?: boolean
    userId?: boolean
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
    User?: boolean | GuarantorVerification$UserArgs<ExtArgs>
  }, ExtArgs["result"]["guarantorVerification"]>

  export type GuarantorVerificationSelectScalar = {
    id?: boolean
    nominationId?: boolean
    name?: boolean
    email?: boolean
    contact?: boolean
    programme?: boolean
    subgroup?: boolean
    status?: boolean
    comments?: boolean
    verifiedAt?: boolean
    declinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verificationTokenId?: boolean
    userId?: boolean
  }

  export type GuarantorVerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nominationId" | "name" | "email" | "contact" | "programme" | "subgroup" | "status" | "comments" | "verifiedAt" | "declinedAt" | "createdAt" | "updatedAt" | "verificationTokenId" | "userId", ExtArgs["result"]["guarantorVerification"]>
  export type GuarantorVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
    verificationToken?: boolean | GuarantorVerification$verificationTokenArgs<ExtArgs>
    User?: boolean | GuarantorVerification$UserArgs<ExtArgs>
  }
  export type GuarantorVerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
    User?: boolean | GuarantorVerification$UserArgs<ExtArgs>
  }
  export type GuarantorVerificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
    User?: boolean | GuarantorVerification$UserArgs<ExtArgs>
  }

  export type $GuarantorVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GuarantorVerification"
    objects: {
      nomination: Prisma.$NominationPayload<ExtArgs>
      verificationToken: Prisma.$VerificationTokenPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nominationId: string
      name: string
      email: string
      contact: string
      programme: string
      subgroup: string
      status: string
      comments: string | null
      verifiedAt: Date | null
      declinedAt: Date | null
      createdAt: Date
      updatedAt: Date
      verificationTokenId: string | null
      userId: string | null
    }, ExtArgs["result"]["guarantorVerification"]>
    composites: {}
  }

  type GuarantorVerificationGetPayload<S extends boolean | null | undefined | GuarantorVerificationDefaultArgs> = $Result.GetResult<Prisma.$GuarantorVerificationPayload, S>

  type GuarantorVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuarantorVerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuarantorVerificationCountAggregateInputType | true
    }

  export interface GuarantorVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuarantorVerification'], meta: { name: 'GuarantorVerification' } }
    /**
     * Find zero or one GuarantorVerification that matches the filter.
     * @param {GuarantorVerificationFindUniqueArgs} args - Arguments to find a GuarantorVerification
     * @example
     * // Get one GuarantorVerification
     * const guarantorVerification = await prisma.guarantorVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuarantorVerificationFindUniqueArgs>(args: SelectSubset<T, GuarantorVerificationFindUniqueArgs<ExtArgs>>): Prisma__GuarantorVerificationClient<$Result.GetResult<Prisma.$GuarantorVerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GuarantorVerification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuarantorVerificationFindUniqueOrThrowArgs} args - Arguments to find a GuarantorVerification
     * @example
     * // Get one GuarantorVerification
     * const guarantorVerification = await prisma.guarantorVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuarantorVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, GuarantorVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuarantorVerificationClient<$Result.GetResult<Prisma.$GuarantorVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuarantorVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuarantorVerificationFindFirstArgs} args - Arguments to find a GuarantorVerification
     * @example
     * // Get one GuarantorVerification
     * const guarantorVerification = await prisma.guarantorVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuarantorVerificationFindFirstArgs>(args?: SelectSubset<T, GuarantorVerificationFindFirstArgs<ExtArgs>>): Prisma__GuarantorVerificationClient<$Result.GetResult<Prisma.$GuarantorVerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuarantorVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuarantorVerificationFindFirstOrThrowArgs} args - Arguments to find a GuarantorVerification
     * @example
     * // Get one GuarantorVerification
     * const guarantorVerification = await prisma.guarantorVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuarantorVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, GuarantorVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuarantorVerificationClient<$Result.GetResult<Prisma.$GuarantorVerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuarantorVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuarantorVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuarantorVerifications
     * const guarantorVerifications = await prisma.guarantorVerification.findMany()
     * 
     * // Get first 10 GuarantorVerifications
     * const guarantorVerifications = await prisma.guarantorVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guarantorVerificationWithIdOnly = await prisma.guarantorVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuarantorVerificationFindManyArgs>(args?: SelectSubset<T, GuarantorVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuarantorVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GuarantorVerification.
     * @param {GuarantorVerificationCreateArgs} args - Arguments to create a GuarantorVerification.
     * @example
     * // Create one GuarantorVerification
     * const GuarantorVerification = await prisma.guarantorVerification.create({
     *   data: {
     *     // ... data to create a GuarantorVerification
     *   }
     * })
     * 
     */
    create<T extends GuarantorVerificationCreateArgs>(args: SelectSubset<T, GuarantorVerificationCreateArgs<ExtArgs>>): Prisma__GuarantorVerificationClient<$Result.GetResult<Prisma.$GuarantorVerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GuarantorVerifications.
     * @param {GuarantorVerificationCreateManyArgs} args - Arguments to create many GuarantorVerifications.
     * @example
     * // Create many GuarantorVerifications
     * const guarantorVerification = await prisma.guarantorVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuarantorVerificationCreateManyArgs>(args?: SelectSubset<T, GuarantorVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GuarantorVerifications and returns the data saved in the database.
     * @param {GuarantorVerificationCreateManyAndReturnArgs} args - Arguments to create many GuarantorVerifications.
     * @example
     * // Create many GuarantorVerifications
     * const guarantorVerification = await prisma.guarantorVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GuarantorVerifications and only return the `id`
     * const guarantorVerificationWithIdOnly = await prisma.guarantorVerification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GuarantorVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, GuarantorVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuarantorVerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GuarantorVerification.
     * @param {GuarantorVerificationDeleteArgs} args - Arguments to delete one GuarantorVerification.
     * @example
     * // Delete one GuarantorVerification
     * const GuarantorVerification = await prisma.guarantorVerification.delete({
     *   where: {
     *     // ... filter to delete one GuarantorVerification
     *   }
     * })
     * 
     */
    delete<T extends GuarantorVerificationDeleteArgs>(args: SelectSubset<T, GuarantorVerificationDeleteArgs<ExtArgs>>): Prisma__GuarantorVerificationClient<$Result.GetResult<Prisma.$GuarantorVerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GuarantorVerification.
     * @param {GuarantorVerificationUpdateArgs} args - Arguments to update one GuarantorVerification.
     * @example
     * // Update one GuarantorVerification
     * const guarantorVerification = await prisma.guarantorVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuarantorVerificationUpdateArgs>(args: SelectSubset<T, GuarantorVerificationUpdateArgs<ExtArgs>>): Prisma__GuarantorVerificationClient<$Result.GetResult<Prisma.$GuarantorVerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GuarantorVerifications.
     * @param {GuarantorVerificationDeleteManyArgs} args - Arguments to filter GuarantorVerifications to delete.
     * @example
     * // Delete a few GuarantorVerifications
     * const { count } = await prisma.guarantorVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuarantorVerificationDeleteManyArgs>(args?: SelectSubset<T, GuarantorVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuarantorVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuarantorVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuarantorVerifications
     * const guarantorVerification = await prisma.guarantorVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuarantorVerificationUpdateManyArgs>(args: SelectSubset<T, GuarantorVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuarantorVerifications and returns the data updated in the database.
     * @param {GuarantorVerificationUpdateManyAndReturnArgs} args - Arguments to update many GuarantorVerifications.
     * @example
     * // Update many GuarantorVerifications
     * const guarantorVerification = await prisma.guarantorVerification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GuarantorVerifications and only return the `id`
     * const guarantorVerificationWithIdOnly = await prisma.guarantorVerification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GuarantorVerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, GuarantorVerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuarantorVerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GuarantorVerification.
     * @param {GuarantorVerificationUpsertArgs} args - Arguments to update or create a GuarantorVerification.
     * @example
     * // Update or create a GuarantorVerification
     * const guarantorVerification = await prisma.guarantorVerification.upsert({
     *   create: {
     *     // ... data to create a GuarantorVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuarantorVerification we want to update
     *   }
     * })
     */
    upsert<T extends GuarantorVerificationUpsertArgs>(args: SelectSubset<T, GuarantorVerificationUpsertArgs<ExtArgs>>): Prisma__GuarantorVerificationClient<$Result.GetResult<Prisma.$GuarantorVerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GuarantorVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuarantorVerificationCountArgs} args - Arguments to filter GuarantorVerifications to count.
     * @example
     * // Count the number of GuarantorVerifications
     * const count = await prisma.guarantorVerification.count({
     *   where: {
     *     // ... the filter for the GuarantorVerifications we want to count
     *   }
     * })
    **/
    count<T extends GuarantorVerificationCountArgs>(
      args?: Subset<T, GuarantorVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuarantorVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuarantorVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuarantorVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuarantorVerificationAggregateArgs>(args: Subset<T, GuarantorVerificationAggregateArgs>): Prisma.PrismaPromise<GetGuarantorVerificationAggregateType<T>>

    /**
     * Group by GuarantorVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuarantorVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuarantorVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuarantorVerificationGroupByArgs['orderBy'] }
        : { orderBy?: GuarantorVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuarantorVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuarantorVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GuarantorVerification model
   */
  readonly fields: GuarantorVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuarantorVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuarantorVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nomination<T extends NominationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NominationDefaultArgs<ExtArgs>>): Prisma__NominationClient<$Result.GetResult<Prisma.$NominationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    verificationToken<T extends GuarantorVerification$verificationTokenArgs<ExtArgs> = {}>(args?: Subset<T, GuarantorVerification$verificationTokenArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User<T extends GuarantorVerification$UserArgs<ExtArgs> = {}>(args?: Subset<T, GuarantorVerification$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GuarantorVerification model
   */
  interface GuarantorVerificationFieldRefs {
    readonly id: FieldRef<"GuarantorVerification", 'String'>
    readonly nominationId: FieldRef<"GuarantorVerification", 'String'>
    readonly name: FieldRef<"GuarantorVerification", 'String'>
    readonly email: FieldRef<"GuarantorVerification", 'String'>
    readonly contact: FieldRef<"GuarantorVerification", 'String'>
    readonly programme: FieldRef<"GuarantorVerification", 'String'>
    readonly subgroup: FieldRef<"GuarantorVerification", 'String'>
    readonly status: FieldRef<"GuarantorVerification", 'String'>
    readonly comments: FieldRef<"GuarantorVerification", 'String'>
    readonly verifiedAt: FieldRef<"GuarantorVerification", 'DateTime'>
    readonly declinedAt: FieldRef<"GuarantorVerification", 'DateTime'>
    readonly createdAt: FieldRef<"GuarantorVerification", 'DateTime'>
    readonly updatedAt: FieldRef<"GuarantorVerification", 'DateTime'>
    readonly verificationTokenId: FieldRef<"GuarantorVerification", 'String'>
    readonly userId: FieldRef<"GuarantorVerification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GuarantorVerification findUnique
   */
  export type GuarantorVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuarantorVerification
     */
    select?: GuarantorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuarantorVerification
     */
    omit?: GuarantorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorVerificationInclude<ExtArgs> | null
    /**
     * Filter, which GuarantorVerification to fetch.
     */
    where: GuarantorVerificationWhereUniqueInput
  }

  /**
   * GuarantorVerification findUniqueOrThrow
   */
  export type GuarantorVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuarantorVerification
     */
    select?: GuarantorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuarantorVerification
     */
    omit?: GuarantorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorVerificationInclude<ExtArgs> | null
    /**
     * Filter, which GuarantorVerification to fetch.
     */
    where: GuarantorVerificationWhereUniqueInput
  }

  /**
   * GuarantorVerification findFirst
   */
  export type GuarantorVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuarantorVerification
     */
    select?: GuarantorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuarantorVerification
     */
    omit?: GuarantorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorVerificationInclude<ExtArgs> | null
    /**
     * Filter, which GuarantorVerification to fetch.
     */
    where?: GuarantorVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuarantorVerifications to fetch.
     */
    orderBy?: GuarantorVerificationOrderByWithRelationInput | GuarantorVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuarantorVerifications.
     */
    cursor?: GuarantorVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuarantorVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuarantorVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuarantorVerifications.
     */
    distinct?: GuarantorVerificationScalarFieldEnum | GuarantorVerificationScalarFieldEnum[]
  }

  /**
   * GuarantorVerification findFirstOrThrow
   */
  export type GuarantorVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuarantorVerification
     */
    select?: GuarantorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuarantorVerification
     */
    omit?: GuarantorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorVerificationInclude<ExtArgs> | null
    /**
     * Filter, which GuarantorVerification to fetch.
     */
    where?: GuarantorVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuarantorVerifications to fetch.
     */
    orderBy?: GuarantorVerificationOrderByWithRelationInput | GuarantorVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuarantorVerifications.
     */
    cursor?: GuarantorVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuarantorVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuarantorVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuarantorVerifications.
     */
    distinct?: GuarantorVerificationScalarFieldEnum | GuarantorVerificationScalarFieldEnum[]
  }

  /**
   * GuarantorVerification findMany
   */
  export type GuarantorVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuarantorVerification
     */
    select?: GuarantorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuarantorVerification
     */
    omit?: GuarantorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorVerificationInclude<ExtArgs> | null
    /**
     * Filter, which GuarantorVerifications to fetch.
     */
    where?: GuarantorVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuarantorVerifications to fetch.
     */
    orderBy?: GuarantorVerificationOrderByWithRelationInput | GuarantorVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuarantorVerifications.
     */
    cursor?: GuarantorVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuarantorVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuarantorVerifications.
     */
    skip?: number
    distinct?: GuarantorVerificationScalarFieldEnum | GuarantorVerificationScalarFieldEnum[]
  }

  /**
   * GuarantorVerification create
   */
  export type GuarantorVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuarantorVerification
     */
    select?: GuarantorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuarantorVerification
     */
    omit?: GuarantorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a GuarantorVerification.
     */
    data: XOR<GuarantorVerificationCreateInput, GuarantorVerificationUncheckedCreateInput>
  }

  /**
   * GuarantorVerification createMany
   */
  export type GuarantorVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GuarantorVerifications.
     */
    data: GuarantorVerificationCreateManyInput | GuarantorVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GuarantorVerification createManyAndReturn
   */
  export type GuarantorVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuarantorVerification
     */
    select?: GuarantorVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GuarantorVerification
     */
    omit?: GuarantorVerificationOmit<ExtArgs> | null
    /**
     * The data used to create many GuarantorVerifications.
     */
    data: GuarantorVerificationCreateManyInput | GuarantorVerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorVerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GuarantorVerification update
   */
  export type GuarantorVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuarantorVerification
     */
    select?: GuarantorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuarantorVerification
     */
    omit?: GuarantorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a GuarantorVerification.
     */
    data: XOR<GuarantorVerificationUpdateInput, GuarantorVerificationUncheckedUpdateInput>
    /**
     * Choose, which GuarantorVerification to update.
     */
    where: GuarantorVerificationWhereUniqueInput
  }

  /**
   * GuarantorVerification updateMany
   */
  export type GuarantorVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GuarantorVerifications.
     */
    data: XOR<GuarantorVerificationUpdateManyMutationInput, GuarantorVerificationUncheckedUpdateManyInput>
    /**
     * Filter which GuarantorVerifications to update
     */
    where?: GuarantorVerificationWhereInput
    /**
     * Limit how many GuarantorVerifications to update.
     */
    limit?: number
  }

  /**
   * GuarantorVerification updateManyAndReturn
   */
  export type GuarantorVerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuarantorVerification
     */
    select?: GuarantorVerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GuarantorVerification
     */
    omit?: GuarantorVerificationOmit<ExtArgs> | null
    /**
     * The data used to update GuarantorVerifications.
     */
    data: XOR<GuarantorVerificationUpdateManyMutationInput, GuarantorVerificationUncheckedUpdateManyInput>
    /**
     * Filter which GuarantorVerifications to update
     */
    where?: GuarantorVerificationWhereInput
    /**
     * Limit how many GuarantorVerifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorVerificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GuarantorVerification upsert
   */
  export type GuarantorVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuarantorVerification
     */
    select?: GuarantorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuarantorVerification
     */
    omit?: GuarantorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the GuarantorVerification to update in case it exists.
     */
    where: GuarantorVerificationWhereUniqueInput
    /**
     * In case the GuarantorVerification found by the `where` argument doesn't exist, create a new GuarantorVerification with this data.
     */
    create: XOR<GuarantorVerificationCreateInput, GuarantorVerificationUncheckedCreateInput>
    /**
     * In case the GuarantorVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuarantorVerificationUpdateInput, GuarantorVerificationUncheckedUpdateInput>
  }

  /**
   * GuarantorVerification delete
   */
  export type GuarantorVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuarantorVerification
     */
    select?: GuarantorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuarantorVerification
     */
    omit?: GuarantorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorVerificationInclude<ExtArgs> | null
    /**
     * Filter which GuarantorVerification to delete.
     */
    where: GuarantorVerificationWhereUniqueInput
  }

  /**
   * GuarantorVerification deleteMany
   */
  export type GuarantorVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuarantorVerifications to delete
     */
    where?: GuarantorVerificationWhereInput
    /**
     * Limit how many GuarantorVerifications to delete.
     */
    limit?: number
  }

  /**
   * GuarantorVerification.verificationToken
   */
  export type GuarantorVerification$verificationTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    where?: VerificationTokenWhereInput
  }

  /**
   * GuarantorVerification.User
   */
  export type GuarantorVerification$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * GuarantorVerification without action
   */
  export type GuarantorVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuarantorVerification
     */
    select?: GuarantorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuarantorVerification
     */
    omit?: GuarantorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorVerificationInclude<ExtArgs> | null
  }


  /**
   * Model EcReview
   */

  export type AggregateEcReview = {
    _count: EcReviewCountAggregateOutputType | null
    _min: EcReviewMinAggregateOutputType | null
    _max: EcReviewMaxAggregateOutputType | null
  }

  export type EcReviewMinAggregateOutputType = {
    id: string | null
    nominationId: string | null
    reviewerId: string | null
    approved: boolean | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type EcReviewMaxAggregateOutputType = {
    id: string | null
    nominationId: string | null
    reviewerId: string | null
    approved: boolean | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type EcReviewCountAggregateOutputType = {
    id: number
    nominationId: number
    reviewerId: number
    approved: number
    comments: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type EcReviewMinAggregateInputType = {
    id?: true
    nominationId?: true
    reviewerId?: true
    approved?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type EcReviewMaxAggregateInputType = {
    id?: true
    nominationId?: true
    reviewerId?: true
    approved?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type EcReviewCountAggregateInputType = {
    id?: true
    nominationId?: true
    reviewerId?: true
    approved?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type EcReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EcReview to aggregate.
     */
    where?: EcReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EcReviews to fetch.
     */
    orderBy?: EcReviewOrderByWithRelationInput | EcReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EcReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EcReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EcReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EcReviews
    **/
    _count?: true | EcReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EcReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EcReviewMaxAggregateInputType
  }

  export type GetEcReviewAggregateType<T extends EcReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateEcReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEcReview[P]>
      : GetScalarType<T[P], AggregateEcReview[P]>
  }




  export type EcReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EcReviewWhereInput
    orderBy?: EcReviewOrderByWithAggregationInput | EcReviewOrderByWithAggregationInput[]
    by: EcReviewScalarFieldEnum[] | EcReviewScalarFieldEnum
    having?: EcReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EcReviewCountAggregateInputType | true
    _min?: EcReviewMinAggregateInputType
    _max?: EcReviewMaxAggregateInputType
  }

  export type EcReviewGroupByOutputType = {
    id: string
    nominationId: string
    reviewerId: string
    approved: boolean
    comments: string | null
    createdAt: Date
    updatedAt: Date
    userId: string | null
    _count: EcReviewCountAggregateOutputType | null
    _min: EcReviewMinAggregateOutputType | null
    _max: EcReviewMaxAggregateOutputType | null
  }

  type GetEcReviewGroupByPayload<T extends EcReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EcReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EcReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EcReviewGroupByOutputType[P]>
            : GetScalarType<T[P], EcReviewGroupByOutputType[P]>
        }
      >
    >


  export type EcReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nominationId?: boolean
    reviewerId?: boolean
    approved?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    User?: boolean | EcReview$UserArgs<ExtArgs>
  }, ExtArgs["result"]["ecReview"]>

  export type EcReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nominationId?: boolean
    reviewerId?: boolean
    approved?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    User?: boolean | EcReview$UserArgs<ExtArgs>
  }, ExtArgs["result"]["ecReview"]>

  export type EcReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nominationId?: boolean
    reviewerId?: boolean
    approved?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    User?: boolean | EcReview$UserArgs<ExtArgs>
  }, ExtArgs["result"]["ecReview"]>

  export type EcReviewSelectScalar = {
    id?: boolean
    nominationId?: boolean
    reviewerId?: boolean
    approved?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type EcReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nominationId" | "reviewerId" | "approved" | "comments" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["ecReview"]>
  export type EcReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    User?: boolean | EcReview$UserArgs<ExtArgs>
  }
  export type EcReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    User?: boolean | EcReview$UserArgs<ExtArgs>
  }
  export type EcReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    User?: boolean | EcReview$UserArgs<ExtArgs>
  }

  export type $EcReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EcReview"
    objects: {
      nomination: Prisma.$NominationPayload<ExtArgs>
      reviewer: Prisma.$UserPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nominationId: string
      reviewerId: string
      approved: boolean
      comments: string | null
      createdAt: Date
      updatedAt: Date
      userId: string | null
    }, ExtArgs["result"]["ecReview"]>
    composites: {}
  }

  type EcReviewGetPayload<S extends boolean | null | undefined | EcReviewDefaultArgs> = $Result.GetResult<Prisma.$EcReviewPayload, S>

  type EcReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EcReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EcReviewCountAggregateInputType | true
    }

  export interface EcReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EcReview'], meta: { name: 'EcReview' } }
    /**
     * Find zero or one EcReview that matches the filter.
     * @param {EcReviewFindUniqueArgs} args - Arguments to find a EcReview
     * @example
     * // Get one EcReview
     * const ecReview = await prisma.ecReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EcReviewFindUniqueArgs>(args: SelectSubset<T, EcReviewFindUniqueArgs<ExtArgs>>): Prisma__EcReviewClient<$Result.GetResult<Prisma.$EcReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EcReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EcReviewFindUniqueOrThrowArgs} args - Arguments to find a EcReview
     * @example
     * // Get one EcReview
     * const ecReview = await prisma.ecReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EcReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, EcReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EcReviewClient<$Result.GetResult<Prisma.$EcReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EcReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcReviewFindFirstArgs} args - Arguments to find a EcReview
     * @example
     * // Get one EcReview
     * const ecReview = await prisma.ecReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EcReviewFindFirstArgs>(args?: SelectSubset<T, EcReviewFindFirstArgs<ExtArgs>>): Prisma__EcReviewClient<$Result.GetResult<Prisma.$EcReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EcReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcReviewFindFirstOrThrowArgs} args - Arguments to find a EcReview
     * @example
     * // Get one EcReview
     * const ecReview = await prisma.ecReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EcReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, EcReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__EcReviewClient<$Result.GetResult<Prisma.$EcReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EcReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EcReviews
     * const ecReviews = await prisma.ecReview.findMany()
     * 
     * // Get first 10 EcReviews
     * const ecReviews = await prisma.ecReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ecReviewWithIdOnly = await prisma.ecReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EcReviewFindManyArgs>(args?: SelectSubset<T, EcReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EcReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EcReview.
     * @param {EcReviewCreateArgs} args - Arguments to create a EcReview.
     * @example
     * // Create one EcReview
     * const EcReview = await prisma.ecReview.create({
     *   data: {
     *     // ... data to create a EcReview
     *   }
     * })
     * 
     */
    create<T extends EcReviewCreateArgs>(args: SelectSubset<T, EcReviewCreateArgs<ExtArgs>>): Prisma__EcReviewClient<$Result.GetResult<Prisma.$EcReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EcReviews.
     * @param {EcReviewCreateManyArgs} args - Arguments to create many EcReviews.
     * @example
     * // Create many EcReviews
     * const ecReview = await prisma.ecReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EcReviewCreateManyArgs>(args?: SelectSubset<T, EcReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EcReviews and returns the data saved in the database.
     * @param {EcReviewCreateManyAndReturnArgs} args - Arguments to create many EcReviews.
     * @example
     * // Create many EcReviews
     * const ecReview = await prisma.ecReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EcReviews and only return the `id`
     * const ecReviewWithIdOnly = await prisma.ecReview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EcReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, EcReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EcReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EcReview.
     * @param {EcReviewDeleteArgs} args - Arguments to delete one EcReview.
     * @example
     * // Delete one EcReview
     * const EcReview = await prisma.ecReview.delete({
     *   where: {
     *     // ... filter to delete one EcReview
     *   }
     * })
     * 
     */
    delete<T extends EcReviewDeleteArgs>(args: SelectSubset<T, EcReviewDeleteArgs<ExtArgs>>): Prisma__EcReviewClient<$Result.GetResult<Prisma.$EcReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EcReview.
     * @param {EcReviewUpdateArgs} args - Arguments to update one EcReview.
     * @example
     * // Update one EcReview
     * const ecReview = await prisma.ecReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EcReviewUpdateArgs>(args: SelectSubset<T, EcReviewUpdateArgs<ExtArgs>>): Prisma__EcReviewClient<$Result.GetResult<Prisma.$EcReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EcReviews.
     * @param {EcReviewDeleteManyArgs} args - Arguments to filter EcReviews to delete.
     * @example
     * // Delete a few EcReviews
     * const { count } = await prisma.ecReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EcReviewDeleteManyArgs>(args?: SelectSubset<T, EcReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EcReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EcReviews
     * const ecReview = await prisma.ecReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EcReviewUpdateManyArgs>(args: SelectSubset<T, EcReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EcReviews and returns the data updated in the database.
     * @param {EcReviewUpdateManyAndReturnArgs} args - Arguments to update many EcReviews.
     * @example
     * // Update many EcReviews
     * const ecReview = await prisma.ecReview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EcReviews and only return the `id`
     * const ecReviewWithIdOnly = await prisma.ecReview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EcReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, EcReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EcReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EcReview.
     * @param {EcReviewUpsertArgs} args - Arguments to update or create a EcReview.
     * @example
     * // Update or create a EcReview
     * const ecReview = await prisma.ecReview.upsert({
     *   create: {
     *     // ... data to create a EcReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EcReview we want to update
     *   }
     * })
     */
    upsert<T extends EcReviewUpsertArgs>(args: SelectSubset<T, EcReviewUpsertArgs<ExtArgs>>): Prisma__EcReviewClient<$Result.GetResult<Prisma.$EcReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EcReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcReviewCountArgs} args - Arguments to filter EcReviews to count.
     * @example
     * // Count the number of EcReviews
     * const count = await prisma.ecReview.count({
     *   where: {
     *     // ... the filter for the EcReviews we want to count
     *   }
     * })
    **/
    count<T extends EcReviewCountArgs>(
      args?: Subset<T, EcReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EcReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EcReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EcReviewAggregateArgs>(args: Subset<T, EcReviewAggregateArgs>): Prisma.PrismaPromise<GetEcReviewAggregateType<T>>

    /**
     * Group by EcReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EcReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EcReviewGroupByArgs['orderBy'] }
        : { orderBy?: EcReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EcReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEcReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EcReview model
   */
  readonly fields: EcReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EcReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EcReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nomination<T extends NominationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NominationDefaultArgs<ExtArgs>>): Prisma__NominationClient<$Result.GetResult<Prisma.$NominationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviewer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends EcReview$UserArgs<ExtArgs> = {}>(args?: Subset<T, EcReview$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EcReview model
   */
  interface EcReviewFieldRefs {
    readonly id: FieldRef<"EcReview", 'String'>
    readonly nominationId: FieldRef<"EcReview", 'String'>
    readonly reviewerId: FieldRef<"EcReview", 'String'>
    readonly approved: FieldRef<"EcReview", 'Boolean'>
    readonly comments: FieldRef<"EcReview", 'String'>
    readonly createdAt: FieldRef<"EcReview", 'DateTime'>
    readonly updatedAt: FieldRef<"EcReview", 'DateTime'>
    readonly userId: FieldRef<"EcReview", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EcReview findUnique
   */
  export type EcReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcReview
     */
    select?: EcReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcReview
     */
    omit?: EcReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcReviewInclude<ExtArgs> | null
    /**
     * Filter, which EcReview to fetch.
     */
    where: EcReviewWhereUniqueInput
  }

  /**
   * EcReview findUniqueOrThrow
   */
  export type EcReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcReview
     */
    select?: EcReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcReview
     */
    omit?: EcReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcReviewInclude<ExtArgs> | null
    /**
     * Filter, which EcReview to fetch.
     */
    where: EcReviewWhereUniqueInput
  }

  /**
   * EcReview findFirst
   */
  export type EcReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcReview
     */
    select?: EcReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcReview
     */
    omit?: EcReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcReviewInclude<ExtArgs> | null
    /**
     * Filter, which EcReview to fetch.
     */
    where?: EcReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EcReviews to fetch.
     */
    orderBy?: EcReviewOrderByWithRelationInput | EcReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EcReviews.
     */
    cursor?: EcReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EcReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EcReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EcReviews.
     */
    distinct?: EcReviewScalarFieldEnum | EcReviewScalarFieldEnum[]
  }

  /**
   * EcReview findFirstOrThrow
   */
  export type EcReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcReview
     */
    select?: EcReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcReview
     */
    omit?: EcReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcReviewInclude<ExtArgs> | null
    /**
     * Filter, which EcReview to fetch.
     */
    where?: EcReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EcReviews to fetch.
     */
    orderBy?: EcReviewOrderByWithRelationInput | EcReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EcReviews.
     */
    cursor?: EcReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EcReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EcReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EcReviews.
     */
    distinct?: EcReviewScalarFieldEnum | EcReviewScalarFieldEnum[]
  }

  /**
   * EcReview findMany
   */
  export type EcReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcReview
     */
    select?: EcReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcReview
     */
    omit?: EcReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcReviewInclude<ExtArgs> | null
    /**
     * Filter, which EcReviews to fetch.
     */
    where?: EcReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EcReviews to fetch.
     */
    orderBy?: EcReviewOrderByWithRelationInput | EcReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EcReviews.
     */
    cursor?: EcReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EcReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EcReviews.
     */
    skip?: number
    distinct?: EcReviewScalarFieldEnum | EcReviewScalarFieldEnum[]
  }

  /**
   * EcReview create
   */
  export type EcReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcReview
     */
    select?: EcReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcReview
     */
    omit?: EcReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a EcReview.
     */
    data: XOR<EcReviewCreateInput, EcReviewUncheckedCreateInput>
  }

  /**
   * EcReview createMany
   */
  export type EcReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EcReviews.
     */
    data: EcReviewCreateManyInput | EcReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EcReview createManyAndReturn
   */
  export type EcReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcReview
     */
    select?: EcReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EcReview
     */
    omit?: EcReviewOmit<ExtArgs> | null
    /**
     * The data used to create many EcReviews.
     */
    data: EcReviewCreateManyInput | EcReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EcReview update
   */
  export type EcReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcReview
     */
    select?: EcReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcReview
     */
    omit?: EcReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a EcReview.
     */
    data: XOR<EcReviewUpdateInput, EcReviewUncheckedUpdateInput>
    /**
     * Choose, which EcReview to update.
     */
    where: EcReviewWhereUniqueInput
  }

  /**
   * EcReview updateMany
   */
  export type EcReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EcReviews.
     */
    data: XOR<EcReviewUpdateManyMutationInput, EcReviewUncheckedUpdateManyInput>
    /**
     * Filter which EcReviews to update
     */
    where?: EcReviewWhereInput
    /**
     * Limit how many EcReviews to update.
     */
    limit?: number
  }

  /**
   * EcReview updateManyAndReturn
   */
  export type EcReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcReview
     */
    select?: EcReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EcReview
     */
    omit?: EcReviewOmit<ExtArgs> | null
    /**
     * The data used to update EcReviews.
     */
    data: XOR<EcReviewUpdateManyMutationInput, EcReviewUncheckedUpdateManyInput>
    /**
     * Filter which EcReviews to update
     */
    where?: EcReviewWhereInput
    /**
     * Limit how many EcReviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EcReview upsert
   */
  export type EcReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcReview
     */
    select?: EcReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcReview
     */
    omit?: EcReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the EcReview to update in case it exists.
     */
    where: EcReviewWhereUniqueInput
    /**
     * In case the EcReview found by the `where` argument doesn't exist, create a new EcReview with this data.
     */
    create: XOR<EcReviewCreateInput, EcReviewUncheckedCreateInput>
    /**
     * In case the EcReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EcReviewUpdateInput, EcReviewUncheckedUpdateInput>
  }

  /**
   * EcReview delete
   */
  export type EcReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcReview
     */
    select?: EcReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcReview
     */
    omit?: EcReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcReviewInclude<ExtArgs> | null
    /**
     * Filter which EcReview to delete.
     */
    where: EcReviewWhereUniqueInput
  }

  /**
   * EcReview deleteMany
   */
  export type EcReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EcReviews to delete
     */
    where?: EcReviewWhereInput
    /**
     * Limit how many EcReviews to delete.
     */
    limit?: number
  }

  /**
   * EcReview.User
   */
  export type EcReview$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * EcReview without action
   */
  export type EcReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcReview
     */
    select?: EcReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcReview
     */
    omit?: EcReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcReviewInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    type: $Enums.TokenType | null
    email: string | null
    phone: string | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
    nominatorVerificationId: string | null
    guarantorVerificationId: string | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    type: $Enums.TokenType | null
    email: string | null
    phone: string | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
    nominatorVerificationId: string | null
    guarantorVerificationId: string | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    id: number
    token: number
    type: number
    email: number
    phone: number
    expiresAt: number
    used: number
    createdAt: number
    nominatorVerificationId: number
    guarantorVerificationId: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    id?: true
    token?: true
    type?: true
    email?: true
    phone?: true
    expiresAt?: true
    used?: true
    createdAt?: true
    nominatorVerificationId?: true
    guarantorVerificationId?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    id?: true
    token?: true
    type?: true
    email?: true
    phone?: true
    expiresAt?: true
    used?: true
    createdAt?: true
    nominatorVerificationId?: true
    guarantorVerificationId?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    id?: true
    token?: true
    type?: true
    email?: true
    phone?: true
    expiresAt?: true
    used?: true
    createdAt?: true
    nominatorVerificationId?: true
    guarantorVerificationId?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    id: string
    token: string
    type: $Enums.TokenType
    email: string | null
    phone: string | null
    expiresAt: Date
    used: boolean
    createdAt: Date
    nominatorVerificationId: string | null
    guarantorVerificationId: string | null
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    type?: boolean
    email?: boolean
    phone?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    nominatorVerificationId?: boolean
    guarantorVerificationId?: boolean
    nominatorVerification?: boolean | VerificationToken$nominatorVerificationArgs<ExtArgs>
    guarantorVerification?: boolean | VerificationToken$guarantorVerificationArgs<ExtArgs>
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    type?: boolean
    email?: boolean
    phone?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    nominatorVerificationId?: boolean
    guarantorVerificationId?: boolean
    nominatorVerification?: boolean | VerificationToken$nominatorVerificationArgs<ExtArgs>
    guarantorVerification?: boolean | VerificationToken$guarantorVerificationArgs<ExtArgs>
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    type?: boolean
    email?: boolean
    phone?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    nominatorVerificationId?: boolean
    guarantorVerificationId?: boolean
    nominatorVerification?: boolean | VerificationToken$nominatorVerificationArgs<ExtArgs>
    guarantorVerification?: boolean | VerificationToken$guarantorVerificationArgs<ExtArgs>
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    id?: boolean
    token?: boolean
    type?: boolean
    email?: boolean
    phone?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    nominatorVerificationId?: boolean
    guarantorVerificationId?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "type" | "email" | "phone" | "expiresAt" | "used" | "createdAt" | "nominatorVerificationId" | "guarantorVerificationId", ExtArgs["result"]["verificationToken"]>
  export type VerificationTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nominatorVerification?: boolean | VerificationToken$nominatorVerificationArgs<ExtArgs>
    guarantorVerification?: boolean | VerificationToken$guarantorVerificationArgs<ExtArgs>
  }
  export type VerificationTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nominatorVerification?: boolean | VerificationToken$nominatorVerificationArgs<ExtArgs>
    guarantorVerification?: boolean | VerificationToken$guarantorVerificationArgs<ExtArgs>
  }
  export type VerificationTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nominatorVerification?: boolean | VerificationToken$nominatorVerificationArgs<ExtArgs>
    guarantorVerification?: boolean | VerificationToken$guarantorVerificationArgs<ExtArgs>
  }

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {
      nominatorVerification: Prisma.$NominatorVerificationPayload<ExtArgs> | null
      guarantorVerification: Prisma.$GuarantorVerificationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      type: $Enums.TokenType
      email: string | null
      phone: string | null
      expiresAt: Date
      used: boolean
      createdAt: Date
      nominatorVerificationId: string | null
      guarantorVerificationId: string | null
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nominatorVerification<T extends VerificationToken$nominatorVerificationArgs<ExtArgs> = {}>(args?: Subset<T, VerificationToken$nominatorVerificationArgs<ExtArgs>>): Prisma__NominatorVerificationClient<$Result.GetResult<Prisma.$NominatorVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    guarantorVerification<T extends VerificationToken$guarantorVerificationArgs<ExtArgs> = {}>(args?: Subset<T, VerificationToken$guarantorVerificationArgs<ExtArgs>>): Prisma__GuarantorVerificationClient<$Result.GetResult<Prisma.$GuarantorVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly id: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly type: FieldRef<"VerificationToken", 'TokenType'>
    readonly email: FieldRef<"VerificationToken", 'String'>
    readonly phone: FieldRef<"VerificationToken", 'String'>
    readonly expiresAt: FieldRef<"VerificationToken", 'DateTime'>
    readonly used: FieldRef<"VerificationToken", 'Boolean'>
    readonly createdAt: FieldRef<"VerificationToken", 'DateTime'>
    readonly nominatorVerificationId: FieldRef<"VerificationToken", 'String'>
    readonly guarantorVerificationId: FieldRef<"VerificationToken", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken.nominatorVerification
   */
  export type VerificationToken$nominatorVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NominatorVerification
     */
    select?: NominatorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NominatorVerification
     */
    omit?: NominatorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominatorVerificationInclude<ExtArgs> | null
    where?: NominatorVerificationWhereInput
  }

  /**
   * VerificationToken.guarantorVerification
   */
  export type VerificationToken$guarantorVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuarantorVerification
     */
    select?: GuarantorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuarantorVerification
     */
    omit?: GuarantorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorVerificationInclude<ExtArgs> | null
    where?: GuarantorVerificationWhereInput
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
  }


  /**
   * Model Candidate
   */

  export type AggregateCandidate = {
    _count: CandidateCountAggregateOutputType | null
    _avg: CandidateAvgAggregateOutputType | null
    _sum: CandidateSumAggregateOutputType | null
    _min: CandidateMinAggregateOutputType | null
    _max: CandidateMaxAggregateOutputType | null
  }

  export type CandidateAvgAggregateOutputType = {
    displayOrder: number | null
    candidateNumber: number | null
    voteCount: number | null
  }

  export type CandidateSumAggregateOutputType = {
    displayOrder: number | null
    candidateNumber: number | null
    voteCount: number | null
  }

  export type CandidateMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    position: $Enums.Candidate_Position | null
    photoUrl: string | null
    photoPublicId: string | null
    biography: string | null
    displayOrder: number | null
    isActive: boolean | null
    candidateNumber: number | null
    nominationId: string | null
    voteCount: number | null
  }

  export type CandidateMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    position: $Enums.Candidate_Position | null
    photoUrl: string | null
    photoPublicId: string | null
    biography: string | null
    displayOrder: number | null
    isActive: boolean | null
    candidateNumber: number | null
    nominationId: string | null
    voteCount: number | null
  }

  export type CandidateCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    position: number
    photoUrl: number
    photoPublicId: number
    biography: number
    displayOrder: number
    isActive: number
    candidateNumber: number
    nominationId: number
    voteCount: number
    _all: number
  }


  export type CandidateAvgAggregateInputType = {
    displayOrder?: true
    candidateNumber?: true
    voteCount?: true
  }

  export type CandidateSumAggregateInputType = {
    displayOrder?: true
    candidateNumber?: true
    voteCount?: true
  }

  export type CandidateMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    position?: true
    photoUrl?: true
    photoPublicId?: true
    biography?: true
    displayOrder?: true
    isActive?: true
    candidateNumber?: true
    nominationId?: true
    voteCount?: true
  }

  export type CandidateMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    position?: true
    photoUrl?: true
    photoPublicId?: true
    biography?: true
    displayOrder?: true
    isActive?: true
    candidateNumber?: true
    nominationId?: true
    voteCount?: true
  }

  export type CandidateCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    position?: true
    photoUrl?: true
    photoPublicId?: true
    biography?: true
    displayOrder?: true
    isActive?: true
    candidateNumber?: true
    nominationId?: true
    voteCount?: true
    _all?: true
  }

  export type CandidateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Candidate to aggregate.
     */
    where?: CandidateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candidates to fetch.
     */
    orderBy?: CandidateOrderByWithRelationInput | CandidateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CandidateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candidates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candidates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Candidates
    **/
    _count?: true | CandidateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CandidateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CandidateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CandidateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CandidateMaxAggregateInputType
  }

  export type GetCandidateAggregateType<T extends CandidateAggregateArgs> = {
        [P in keyof T & keyof AggregateCandidate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCandidate[P]>
      : GetScalarType<T[P], AggregateCandidate[P]>
  }




  export type CandidateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidateWhereInput
    orderBy?: CandidateOrderByWithAggregationInput | CandidateOrderByWithAggregationInput[]
    by: CandidateScalarFieldEnum[] | CandidateScalarFieldEnum
    having?: CandidateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CandidateCountAggregateInputType | true
    _avg?: CandidateAvgAggregateInputType
    _sum?: CandidateSumAggregateInputType
    _min?: CandidateMinAggregateInputType
    _max?: CandidateMaxAggregateInputType
  }

  export type CandidateGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    position: $Enums.Candidate_Position
    photoUrl: string | null
    photoPublicId: string | null
    biography: string | null
    displayOrder: number
    isActive: boolean
    candidateNumber: number
    nominationId: string
    voteCount: number
    _count: CandidateCountAggregateOutputType | null
    _avg: CandidateAvgAggregateOutputType | null
    _sum: CandidateSumAggregateOutputType | null
    _min: CandidateMinAggregateOutputType | null
    _max: CandidateMaxAggregateOutputType | null
  }

  type GetCandidateGroupByPayload<T extends CandidateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CandidateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CandidateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CandidateGroupByOutputType[P]>
            : GetScalarType<T[P], CandidateGroupByOutputType[P]>
        }
      >
    >


  export type CandidateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    position?: boolean
    photoUrl?: boolean
    photoPublicId?: boolean
    biography?: boolean
    displayOrder?: boolean
    isActive?: boolean
    candidateNumber?: boolean
    nominationId?: boolean
    voteCount?: boolean
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["candidate"]>

  export type CandidateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    position?: boolean
    photoUrl?: boolean
    photoPublicId?: boolean
    biography?: boolean
    displayOrder?: boolean
    isActive?: boolean
    candidateNumber?: boolean
    nominationId?: boolean
    voteCount?: boolean
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["candidate"]>

  export type CandidateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    position?: boolean
    photoUrl?: boolean
    photoPublicId?: boolean
    biography?: boolean
    displayOrder?: boolean
    isActive?: boolean
    candidateNumber?: boolean
    nominationId?: boolean
    voteCount?: boolean
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["candidate"]>

  export type CandidateSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    position?: boolean
    photoUrl?: boolean
    photoPublicId?: boolean
    biography?: boolean
    displayOrder?: boolean
    isActive?: boolean
    candidateNumber?: boolean
    nominationId?: boolean
    voteCount?: boolean
  }

  export type CandidateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "position" | "photoUrl" | "photoPublicId" | "biography" | "displayOrder" | "isActive" | "candidateNumber" | "nominationId" | "voteCount", ExtArgs["result"]["candidate"]>
  export type CandidateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
  }
  export type CandidateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
  }
  export type CandidateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nomination?: boolean | NominationDefaultArgs<ExtArgs>
  }

  export type $CandidatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Candidate"
    objects: {
      nomination: Prisma.$NominationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      position: $Enums.Candidate_Position
      photoUrl: string | null
      photoPublicId: string | null
      biography: string | null
      displayOrder: number
      isActive: boolean
      candidateNumber: number
      nominationId: string
      voteCount: number
    }, ExtArgs["result"]["candidate"]>
    composites: {}
  }

  type CandidateGetPayload<S extends boolean | null | undefined | CandidateDefaultArgs> = $Result.GetResult<Prisma.$CandidatePayload, S>

  type CandidateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CandidateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CandidateCountAggregateInputType | true
    }

  export interface CandidateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Candidate'], meta: { name: 'Candidate' } }
    /**
     * Find zero or one Candidate that matches the filter.
     * @param {CandidateFindUniqueArgs} args - Arguments to find a Candidate
     * @example
     * // Get one Candidate
     * const candidate = await prisma.candidate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CandidateFindUniqueArgs>(args: SelectSubset<T, CandidateFindUniqueArgs<ExtArgs>>): Prisma__CandidateClient<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Candidate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CandidateFindUniqueOrThrowArgs} args - Arguments to find a Candidate
     * @example
     * // Get one Candidate
     * const candidate = await prisma.candidate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CandidateFindUniqueOrThrowArgs>(args: SelectSubset<T, CandidateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CandidateClient<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Candidate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateFindFirstArgs} args - Arguments to find a Candidate
     * @example
     * // Get one Candidate
     * const candidate = await prisma.candidate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CandidateFindFirstArgs>(args?: SelectSubset<T, CandidateFindFirstArgs<ExtArgs>>): Prisma__CandidateClient<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Candidate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateFindFirstOrThrowArgs} args - Arguments to find a Candidate
     * @example
     * // Get one Candidate
     * const candidate = await prisma.candidate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CandidateFindFirstOrThrowArgs>(args?: SelectSubset<T, CandidateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CandidateClient<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Candidates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Candidates
     * const candidates = await prisma.candidate.findMany()
     * 
     * // Get first 10 Candidates
     * const candidates = await prisma.candidate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const candidateWithIdOnly = await prisma.candidate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CandidateFindManyArgs>(args?: SelectSubset<T, CandidateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Candidate.
     * @param {CandidateCreateArgs} args - Arguments to create a Candidate.
     * @example
     * // Create one Candidate
     * const Candidate = await prisma.candidate.create({
     *   data: {
     *     // ... data to create a Candidate
     *   }
     * })
     * 
     */
    create<T extends CandidateCreateArgs>(args: SelectSubset<T, CandidateCreateArgs<ExtArgs>>): Prisma__CandidateClient<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Candidates.
     * @param {CandidateCreateManyArgs} args - Arguments to create many Candidates.
     * @example
     * // Create many Candidates
     * const candidate = await prisma.candidate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CandidateCreateManyArgs>(args?: SelectSubset<T, CandidateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Candidates and returns the data saved in the database.
     * @param {CandidateCreateManyAndReturnArgs} args - Arguments to create many Candidates.
     * @example
     * // Create many Candidates
     * const candidate = await prisma.candidate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Candidates and only return the `id`
     * const candidateWithIdOnly = await prisma.candidate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CandidateCreateManyAndReturnArgs>(args?: SelectSubset<T, CandidateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Candidate.
     * @param {CandidateDeleteArgs} args - Arguments to delete one Candidate.
     * @example
     * // Delete one Candidate
     * const Candidate = await prisma.candidate.delete({
     *   where: {
     *     // ... filter to delete one Candidate
     *   }
     * })
     * 
     */
    delete<T extends CandidateDeleteArgs>(args: SelectSubset<T, CandidateDeleteArgs<ExtArgs>>): Prisma__CandidateClient<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Candidate.
     * @param {CandidateUpdateArgs} args - Arguments to update one Candidate.
     * @example
     * // Update one Candidate
     * const candidate = await prisma.candidate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CandidateUpdateArgs>(args: SelectSubset<T, CandidateUpdateArgs<ExtArgs>>): Prisma__CandidateClient<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Candidates.
     * @param {CandidateDeleteManyArgs} args - Arguments to filter Candidates to delete.
     * @example
     * // Delete a few Candidates
     * const { count } = await prisma.candidate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CandidateDeleteManyArgs>(args?: SelectSubset<T, CandidateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Candidates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Candidates
     * const candidate = await prisma.candidate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CandidateUpdateManyArgs>(args: SelectSubset<T, CandidateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Candidates and returns the data updated in the database.
     * @param {CandidateUpdateManyAndReturnArgs} args - Arguments to update many Candidates.
     * @example
     * // Update many Candidates
     * const candidate = await prisma.candidate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Candidates and only return the `id`
     * const candidateWithIdOnly = await prisma.candidate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CandidateUpdateManyAndReturnArgs>(args: SelectSubset<T, CandidateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Candidate.
     * @param {CandidateUpsertArgs} args - Arguments to update or create a Candidate.
     * @example
     * // Update or create a Candidate
     * const candidate = await prisma.candidate.upsert({
     *   create: {
     *     // ... data to create a Candidate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Candidate we want to update
     *   }
     * })
     */
    upsert<T extends CandidateUpsertArgs>(args: SelectSubset<T, CandidateUpsertArgs<ExtArgs>>): Prisma__CandidateClient<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Candidates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateCountArgs} args - Arguments to filter Candidates to count.
     * @example
     * // Count the number of Candidates
     * const count = await prisma.candidate.count({
     *   where: {
     *     // ... the filter for the Candidates we want to count
     *   }
     * })
    **/
    count<T extends CandidateCountArgs>(
      args?: Subset<T, CandidateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CandidateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Candidate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CandidateAggregateArgs>(args: Subset<T, CandidateAggregateArgs>): Prisma.PrismaPromise<GetCandidateAggregateType<T>>

    /**
     * Group by Candidate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CandidateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CandidateGroupByArgs['orderBy'] }
        : { orderBy?: CandidateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CandidateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCandidateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Candidate model
   */
  readonly fields: CandidateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Candidate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CandidateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nomination<T extends NominationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NominationDefaultArgs<ExtArgs>>): Prisma__NominationClient<$Result.GetResult<Prisma.$NominationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Candidate model
   */
  interface CandidateFieldRefs {
    readonly id: FieldRef<"Candidate", 'String'>
    readonly createdAt: FieldRef<"Candidate", 'DateTime'>
    readonly updatedAt: FieldRef<"Candidate", 'DateTime'>
    readonly name: FieldRef<"Candidate", 'String'>
    readonly position: FieldRef<"Candidate", 'Candidate_Position'>
    readonly photoUrl: FieldRef<"Candidate", 'String'>
    readonly photoPublicId: FieldRef<"Candidate", 'String'>
    readonly biography: FieldRef<"Candidate", 'String'>
    readonly displayOrder: FieldRef<"Candidate", 'Int'>
    readonly isActive: FieldRef<"Candidate", 'Boolean'>
    readonly candidateNumber: FieldRef<"Candidate", 'Int'>
    readonly nominationId: FieldRef<"Candidate", 'String'>
    readonly voteCount: FieldRef<"Candidate", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Candidate findUnique
   */
  export type CandidateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateInclude<ExtArgs> | null
    /**
     * Filter, which Candidate to fetch.
     */
    where: CandidateWhereUniqueInput
  }

  /**
   * Candidate findUniqueOrThrow
   */
  export type CandidateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateInclude<ExtArgs> | null
    /**
     * Filter, which Candidate to fetch.
     */
    where: CandidateWhereUniqueInput
  }

  /**
   * Candidate findFirst
   */
  export type CandidateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateInclude<ExtArgs> | null
    /**
     * Filter, which Candidate to fetch.
     */
    where?: CandidateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candidates to fetch.
     */
    orderBy?: CandidateOrderByWithRelationInput | CandidateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Candidates.
     */
    cursor?: CandidateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candidates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candidates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Candidates.
     */
    distinct?: CandidateScalarFieldEnum | CandidateScalarFieldEnum[]
  }

  /**
   * Candidate findFirstOrThrow
   */
  export type CandidateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateInclude<ExtArgs> | null
    /**
     * Filter, which Candidate to fetch.
     */
    where?: CandidateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candidates to fetch.
     */
    orderBy?: CandidateOrderByWithRelationInput | CandidateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Candidates.
     */
    cursor?: CandidateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candidates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candidates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Candidates.
     */
    distinct?: CandidateScalarFieldEnum | CandidateScalarFieldEnum[]
  }

  /**
   * Candidate findMany
   */
  export type CandidateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateInclude<ExtArgs> | null
    /**
     * Filter, which Candidates to fetch.
     */
    where?: CandidateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candidates to fetch.
     */
    orderBy?: CandidateOrderByWithRelationInput | CandidateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Candidates.
     */
    cursor?: CandidateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candidates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candidates.
     */
    skip?: number
    distinct?: CandidateScalarFieldEnum | CandidateScalarFieldEnum[]
  }

  /**
   * Candidate create
   */
  export type CandidateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateInclude<ExtArgs> | null
    /**
     * The data needed to create a Candidate.
     */
    data: XOR<CandidateCreateInput, CandidateUncheckedCreateInput>
  }

  /**
   * Candidate createMany
   */
  export type CandidateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Candidates.
     */
    data: CandidateCreateManyInput | CandidateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Candidate createManyAndReturn
   */
  export type CandidateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * The data used to create many Candidates.
     */
    data: CandidateCreateManyInput | CandidateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Candidate update
   */
  export type CandidateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateInclude<ExtArgs> | null
    /**
     * The data needed to update a Candidate.
     */
    data: XOR<CandidateUpdateInput, CandidateUncheckedUpdateInput>
    /**
     * Choose, which Candidate to update.
     */
    where: CandidateWhereUniqueInput
  }

  /**
   * Candidate updateMany
   */
  export type CandidateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Candidates.
     */
    data: XOR<CandidateUpdateManyMutationInput, CandidateUncheckedUpdateManyInput>
    /**
     * Filter which Candidates to update
     */
    where?: CandidateWhereInput
    /**
     * Limit how many Candidates to update.
     */
    limit?: number
  }

  /**
   * Candidate updateManyAndReturn
   */
  export type CandidateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * The data used to update Candidates.
     */
    data: XOR<CandidateUpdateManyMutationInput, CandidateUncheckedUpdateManyInput>
    /**
     * Filter which Candidates to update
     */
    where?: CandidateWhereInput
    /**
     * Limit how many Candidates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Candidate upsert
   */
  export type CandidateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateInclude<ExtArgs> | null
    /**
     * The filter to search for the Candidate to update in case it exists.
     */
    where: CandidateWhereUniqueInput
    /**
     * In case the Candidate found by the `where` argument doesn't exist, create a new Candidate with this data.
     */
    create: XOR<CandidateCreateInput, CandidateUncheckedCreateInput>
    /**
     * In case the Candidate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CandidateUpdateInput, CandidateUncheckedUpdateInput>
  }

  /**
   * Candidate delete
   */
  export type CandidateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateInclude<ExtArgs> | null
    /**
     * Filter which Candidate to delete.
     */
    where: CandidateWhereUniqueInput
  }

  /**
   * Candidate deleteMany
   */
  export type CandidateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Candidates to delete
     */
    where?: CandidateWhereInput
    /**
     * Limit how many Candidates to delete.
     */
    limit?: number
  }

  /**
   * Candidate without action
   */
  export type CandidateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateInclude<ExtArgs> | null
  }


  /**
   * Model VotingSession
   */

  export type AggregateVotingSession = {
    _count: VotingSessionCountAggregateOutputType | null
    _min: VotingSessionMinAggregateOutputType | null
    _max: VotingSessionMaxAggregateOutputType | null
  }

  export type VotingSessionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    sessionId: string | null
    voterHash: string | null
    deviceFingerprint: string | null
    ipAddress: string | null
    userAgent: string | null
    status: $Enums.VotingStatus | null
    startTime: Date | null
    endTime: Date | null
    expiresAt: Date | null
    isValid: boolean | null
    userId: string | null
  }

  export type VotingSessionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    sessionId: string | null
    voterHash: string | null
    deviceFingerprint: string | null
    ipAddress: string | null
    userAgent: string | null
    status: $Enums.VotingStatus | null
    startTime: Date | null
    endTime: Date | null
    expiresAt: Date | null
    isValid: boolean | null
    userId: string | null
  }

  export type VotingSessionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    sessionId: number
    voterHash: number
    deviceFingerprint: number
    ipAddress: number
    userAgent: number
    status: number
    startTime: number
    endTime: number
    expiresAt: number
    isValid: number
    userId: number
    _all: number
  }


  export type VotingSessionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    sessionId?: true
    voterHash?: true
    deviceFingerprint?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    startTime?: true
    endTime?: true
    expiresAt?: true
    isValid?: true
    userId?: true
  }

  export type VotingSessionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    sessionId?: true
    voterHash?: true
    deviceFingerprint?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    startTime?: true
    endTime?: true
    expiresAt?: true
    isValid?: true
    userId?: true
  }

  export type VotingSessionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    sessionId?: true
    voterHash?: true
    deviceFingerprint?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    startTime?: true
    endTime?: true
    expiresAt?: true
    isValid?: true
    userId?: true
    _all?: true
  }

  export type VotingSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VotingSession to aggregate.
     */
    where?: VotingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VotingSessions to fetch.
     */
    orderBy?: VotingSessionOrderByWithRelationInput | VotingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VotingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VotingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VotingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VotingSessions
    **/
    _count?: true | VotingSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VotingSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VotingSessionMaxAggregateInputType
  }

  export type GetVotingSessionAggregateType<T extends VotingSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateVotingSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVotingSession[P]>
      : GetScalarType<T[P], AggregateVotingSession[P]>
  }




  export type VotingSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VotingSessionWhereInput
    orderBy?: VotingSessionOrderByWithAggregationInput | VotingSessionOrderByWithAggregationInput[]
    by: VotingSessionScalarFieldEnum[] | VotingSessionScalarFieldEnum
    having?: VotingSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VotingSessionCountAggregateInputType | true
    _min?: VotingSessionMinAggregateInputType
    _max?: VotingSessionMaxAggregateInputType
  }

  export type VotingSessionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    sessionId: string
    voterHash: string
    deviceFingerprint: string | null
    ipAddress: string | null
    userAgent: string | null
    status: $Enums.VotingStatus
    startTime: Date
    endTime: Date | null
    expiresAt: Date
    isValid: boolean
    userId: string
    _count: VotingSessionCountAggregateOutputType | null
    _min: VotingSessionMinAggregateOutputType | null
    _max: VotingSessionMaxAggregateOutputType | null
  }

  type GetVotingSessionGroupByPayload<T extends VotingSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VotingSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VotingSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VotingSessionGroupByOutputType[P]>
            : GetScalarType<T[P], VotingSessionGroupByOutputType[P]>
        }
      >
    >


  export type VotingSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessionId?: boolean
    voterHash?: boolean
    deviceFingerprint?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    expiresAt?: boolean
    isValid?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    votes?: boolean | VotingSession$votesArgs<ExtArgs>
    _count?: boolean | VotingSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["votingSession"]>

  export type VotingSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessionId?: boolean
    voterHash?: boolean
    deviceFingerprint?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    expiresAt?: boolean
    isValid?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["votingSession"]>

  export type VotingSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessionId?: boolean
    voterHash?: boolean
    deviceFingerprint?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    expiresAt?: boolean
    isValid?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["votingSession"]>

  export type VotingSessionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessionId?: boolean
    voterHash?: boolean
    deviceFingerprint?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    expiresAt?: boolean
    isValid?: boolean
    userId?: boolean
  }

  export type VotingSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "sessionId" | "voterHash" | "deviceFingerprint" | "ipAddress" | "userAgent" | "status" | "startTime" | "endTime" | "expiresAt" | "isValid" | "userId", ExtArgs["result"]["votingSession"]>
  export type VotingSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    votes?: boolean | VotingSession$votesArgs<ExtArgs>
    _count?: boolean | VotingSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VotingSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VotingSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VotingSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VotingSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      votes: Prisma.$VotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      sessionId: string
      voterHash: string
      deviceFingerprint: string | null
      ipAddress: string | null
      userAgent: string | null
      status: $Enums.VotingStatus
      startTime: Date
      endTime: Date | null
      expiresAt: Date
      isValid: boolean
      userId: string
    }, ExtArgs["result"]["votingSession"]>
    composites: {}
  }

  type VotingSessionGetPayload<S extends boolean | null | undefined | VotingSessionDefaultArgs> = $Result.GetResult<Prisma.$VotingSessionPayload, S>

  type VotingSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VotingSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VotingSessionCountAggregateInputType | true
    }

  export interface VotingSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VotingSession'], meta: { name: 'VotingSession' } }
    /**
     * Find zero or one VotingSession that matches the filter.
     * @param {VotingSessionFindUniqueArgs} args - Arguments to find a VotingSession
     * @example
     * // Get one VotingSession
     * const votingSession = await prisma.votingSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VotingSessionFindUniqueArgs>(args: SelectSubset<T, VotingSessionFindUniqueArgs<ExtArgs>>): Prisma__VotingSessionClient<$Result.GetResult<Prisma.$VotingSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VotingSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VotingSessionFindUniqueOrThrowArgs} args - Arguments to find a VotingSession
     * @example
     * // Get one VotingSession
     * const votingSession = await prisma.votingSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VotingSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, VotingSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VotingSessionClient<$Result.GetResult<Prisma.$VotingSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VotingSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VotingSessionFindFirstArgs} args - Arguments to find a VotingSession
     * @example
     * // Get one VotingSession
     * const votingSession = await prisma.votingSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VotingSessionFindFirstArgs>(args?: SelectSubset<T, VotingSessionFindFirstArgs<ExtArgs>>): Prisma__VotingSessionClient<$Result.GetResult<Prisma.$VotingSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VotingSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VotingSessionFindFirstOrThrowArgs} args - Arguments to find a VotingSession
     * @example
     * // Get one VotingSession
     * const votingSession = await prisma.votingSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VotingSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, VotingSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__VotingSessionClient<$Result.GetResult<Prisma.$VotingSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VotingSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VotingSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VotingSessions
     * const votingSessions = await prisma.votingSession.findMany()
     * 
     * // Get first 10 VotingSessions
     * const votingSessions = await prisma.votingSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const votingSessionWithIdOnly = await prisma.votingSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VotingSessionFindManyArgs>(args?: SelectSubset<T, VotingSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotingSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VotingSession.
     * @param {VotingSessionCreateArgs} args - Arguments to create a VotingSession.
     * @example
     * // Create one VotingSession
     * const VotingSession = await prisma.votingSession.create({
     *   data: {
     *     // ... data to create a VotingSession
     *   }
     * })
     * 
     */
    create<T extends VotingSessionCreateArgs>(args: SelectSubset<T, VotingSessionCreateArgs<ExtArgs>>): Prisma__VotingSessionClient<$Result.GetResult<Prisma.$VotingSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VotingSessions.
     * @param {VotingSessionCreateManyArgs} args - Arguments to create many VotingSessions.
     * @example
     * // Create many VotingSessions
     * const votingSession = await prisma.votingSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VotingSessionCreateManyArgs>(args?: SelectSubset<T, VotingSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VotingSessions and returns the data saved in the database.
     * @param {VotingSessionCreateManyAndReturnArgs} args - Arguments to create many VotingSessions.
     * @example
     * // Create many VotingSessions
     * const votingSession = await prisma.votingSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VotingSessions and only return the `id`
     * const votingSessionWithIdOnly = await prisma.votingSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VotingSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, VotingSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotingSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VotingSession.
     * @param {VotingSessionDeleteArgs} args - Arguments to delete one VotingSession.
     * @example
     * // Delete one VotingSession
     * const VotingSession = await prisma.votingSession.delete({
     *   where: {
     *     // ... filter to delete one VotingSession
     *   }
     * })
     * 
     */
    delete<T extends VotingSessionDeleteArgs>(args: SelectSubset<T, VotingSessionDeleteArgs<ExtArgs>>): Prisma__VotingSessionClient<$Result.GetResult<Prisma.$VotingSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VotingSession.
     * @param {VotingSessionUpdateArgs} args - Arguments to update one VotingSession.
     * @example
     * // Update one VotingSession
     * const votingSession = await prisma.votingSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VotingSessionUpdateArgs>(args: SelectSubset<T, VotingSessionUpdateArgs<ExtArgs>>): Prisma__VotingSessionClient<$Result.GetResult<Prisma.$VotingSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VotingSessions.
     * @param {VotingSessionDeleteManyArgs} args - Arguments to filter VotingSessions to delete.
     * @example
     * // Delete a few VotingSessions
     * const { count } = await prisma.votingSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VotingSessionDeleteManyArgs>(args?: SelectSubset<T, VotingSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VotingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VotingSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VotingSessions
     * const votingSession = await prisma.votingSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VotingSessionUpdateManyArgs>(args: SelectSubset<T, VotingSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VotingSessions and returns the data updated in the database.
     * @param {VotingSessionUpdateManyAndReturnArgs} args - Arguments to update many VotingSessions.
     * @example
     * // Update many VotingSessions
     * const votingSession = await prisma.votingSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VotingSessions and only return the `id`
     * const votingSessionWithIdOnly = await prisma.votingSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VotingSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, VotingSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotingSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VotingSession.
     * @param {VotingSessionUpsertArgs} args - Arguments to update or create a VotingSession.
     * @example
     * // Update or create a VotingSession
     * const votingSession = await prisma.votingSession.upsert({
     *   create: {
     *     // ... data to create a VotingSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VotingSession we want to update
     *   }
     * })
     */
    upsert<T extends VotingSessionUpsertArgs>(args: SelectSubset<T, VotingSessionUpsertArgs<ExtArgs>>): Prisma__VotingSessionClient<$Result.GetResult<Prisma.$VotingSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VotingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VotingSessionCountArgs} args - Arguments to filter VotingSessions to count.
     * @example
     * // Count the number of VotingSessions
     * const count = await prisma.votingSession.count({
     *   where: {
     *     // ... the filter for the VotingSessions we want to count
     *   }
     * })
    **/
    count<T extends VotingSessionCountArgs>(
      args?: Subset<T, VotingSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VotingSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VotingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VotingSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VotingSessionAggregateArgs>(args: Subset<T, VotingSessionAggregateArgs>): Prisma.PrismaPromise<GetVotingSessionAggregateType<T>>

    /**
     * Group by VotingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VotingSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VotingSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VotingSessionGroupByArgs['orderBy'] }
        : { orderBy?: VotingSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VotingSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVotingSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VotingSession model
   */
  readonly fields: VotingSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VotingSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VotingSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    votes<T extends VotingSession$votesArgs<ExtArgs> = {}>(args?: Subset<T, VotingSession$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VotingSession model
   */
  interface VotingSessionFieldRefs {
    readonly id: FieldRef<"VotingSession", 'String'>
    readonly createdAt: FieldRef<"VotingSession", 'DateTime'>
    readonly updatedAt: FieldRef<"VotingSession", 'DateTime'>
    readonly sessionId: FieldRef<"VotingSession", 'String'>
    readonly voterHash: FieldRef<"VotingSession", 'String'>
    readonly deviceFingerprint: FieldRef<"VotingSession", 'String'>
    readonly ipAddress: FieldRef<"VotingSession", 'String'>
    readonly userAgent: FieldRef<"VotingSession", 'String'>
    readonly status: FieldRef<"VotingSession", 'VotingStatus'>
    readonly startTime: FieldRef<"VotingSession", 'DateTime'>
    readonly endTime: FieldRef<"VotingSession", 'DateTime'>
    readonly expiresAt: FieldRef<"VotingSession", 'DateTime'>
    readonly isValid: FieldRef<"VotingSession", 'Boolean'>
    readonly userId: FieldRef<"VotingSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VotingSession findUnique
   */
  export type VotingSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VotingSession
     */
    select?: VotingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VotingSession
     */
    omit?: VotingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VotingSessionInclude<ExtArgs> | null
    /**
     * Filter, which VotingSession to fetch.
     */
    where: VotingSessionWhereUniqueInput
  }

  /**
   * VotingSession findUniqueOrThrow
   */
  export type VotingSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VotingSession
     */
    select?: VotingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VotingSession
     */
    omit?: VotingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VotingSessionInclude<ExtArgs> | null
    /**
     * Filter, which VotingSession to fetch.
     */
    where: VotingSessionWhereUniqueInput
  }

  /**
   * VotingSession findFirst
   */
  export type VotingSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VotingSession
     */
    select?: VotingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VotingSession
     */
    omit?: VotingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VotingSessionInclude<ExtArgs> | null
    /**
     * Filter, which VotingSession to fetch.
     */
    where?: VotingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VotingSessions to fetch.
     */
    orderBy?: VotingSessionOrderByWithRelationInput | VotingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VotingSessions.
     */
    cursor?: VotingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VotingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VotingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VotingSessions.
     */
    distinct?: VotingSessionScalarFieldEnum | VotingSessionScalarFieldEnum[]
  }

  /**
   * VotingSession findFirstOrThrow
   */
  export type VotingSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VotingSession
     */
    select?: VotingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VotingSession
     */
    omit?: VotingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VotingSessionInclude<ExtArgs> | null
    /**
     * Filter, which VotingSession to fetch.
     */
    where?: VotingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VotingSessions to fetch.
     */
    orderBy?: VotingSessionOrderByWithRelationInput | VotingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VotingSessions.
     */
    cursor?: VotingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VotingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VotingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VotingSessions.
     */
    distinct?: VotingSessionScalarFieldEnum | VotingSessionScalarFieldEnum[]
  }

  /**
   * VotingSession findMany
   */
  export type VotingSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VotingSession
     */
    select?: VotingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VotingSession
     */
    omit?: VotingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VotingSessionInclude<ExtArgs> | null
    /**
     * Filter, which VotingSessions to fetch.
     */
    where?: VotingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VotingSessions to fetch.
     */
    orderBy?: VotingSessionOrderByWithRelationInput | VotingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VotingSessions.
     */
    cursor?: VotingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VotingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VotingSessions.
     */
    skip?: number
    distinct?: VotingSessionScalarFieldEnum | VotingSessionScalarFieldEnum[]
  }

  /**
   * VotingSession create
   */
  export type VotingSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VotingSession
     */
    select?: VotingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VotingSession
     */
    omit?: VotingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VotingSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a VotingSession.
     */
    data: XOR<VotingSessionCreateInput, VotingSessionUncheckedCreateInput>
  }

  /**
   * VotingSession createMany
   */
  export type VotingSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VotingSessions.
     */
    data: VotingSessionCreateManyInput | VotingSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VotingSession createManyAndReturn
   */
  export type VotingSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VotingSession
     */
    select?: VotingSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VotingSession
     */
    omit?: VotingSessionOmit<ExtArgs> | null
    /**
     * The data used to create many VotingSessions.
     */
    data: VotingSessionCreateManyInput | VotingSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VotingSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VotingSession update
   */
  export type VotingSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VotingSession
     */
    select?: VotingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VotingSession
     */
    omit?: VotingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VotingSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a VotingSession.
     */
    data: XOR<VotingSessionUpdateInput, VotingSessionUncheckedUpdateInput>
    /**
     * Choose, which VotingSession to update.
     */
    where: VotingSessionWhereUniqueInput
  }

  /**
   * VotingSession updateMany
   */
  export type VotingSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VotingSessions.
     */
    data: XOR<VotingSessionUpdateManyMutationInput, VotingSessionUncheckedUpdateManyInput>
    /**
     * Filter which VotingSessions to update
     */
    where?: VotingSessionWhereInput
    /**
     * Limit how many VotingSessions to update.
     */
    limit?: number
  }

  /**
   * VotingSession updateManyAndReturn
   */
  export type VotingSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VotingSession
     */
    select?: VotingSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VotingSession
     */
    omit?: VotingSessionOmit<ExtArgs> | null
    /**
     * The data used to update VotingSessions.
     */
    data: XOR<VotingSessionUpdateManyMutationInput, VotingSessionUncheckedUpdateManyInput>
    /**
     * Filter which VotingSessions to update
     */
    where?: VotingSessionWhereInput
    /**
     * Limit how many VotingSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VotingSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VotingSession upsert
   */
  export type VotingSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VotingSession
     */
    select?: VotingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VotingSession
     */
    omit?: VotingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VotingSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the VotingSession to update in case it exists.
     */
    where: VotingSessionWhereUniqueInput
    /**
     * In case the VotingSession found by the `where` argument doesn't exist, create a new VotingSession with this data.
     */
    create: XOR<VotingSessionCreateInput, VotingSessionUncheckedCreateInput>
    /**
     * In case the VotingSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VotingSessionUpdateInput, VotingSessionUncheckedUpdateInput>
  }

  /**
   * VotingSession delete
   */
  export type VotingSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VotingSession
     */
    select?: VotingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VotingSession
     */
    omit?: VotingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VotingSessionInclude<ExtArgs> | null
    /**
     * Filter which VotingSession to delete.
     */
    where: VotingSessionWhereUniqueInput
  }

  /**
   * VotingSession deleteMany
   */
  export type VotingSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VotingSessions to delete
     */
    where?: VotingSessionWhereInput
    /**
     * Limit how many VotingSessions to delete.
     */
    limit?: number
  }

  /**
   * VotingSession.votes
   */
  export type VotingSession$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    cursor?: VoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * VotingSession without action
   */
  export type VotingSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VotingSession
     */
    select?: VotingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VotingSession
     */
    omit?: VotingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VotingSessionInclude<ExtArgs> | null
  }


  /**
   * Model Vote
   */

  export type AggregateVote = {
    _count: VoteCountAggregateOutputType | null
    _min: VoteMinAggregateOutputType | null
    _max: VoteMaxAggregateOutputType | null
  }

  export type VoteMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    encryptedVote: string | null
    voterHash: string | null
    submissionTime: Date | null
    deviceFingerprint: string | null
    ipAddress: string | null
    isValid: boolean | null
    sessionId: string | null
  }

  export type VoteMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    encryptedVote: string | null
    voterHash: string | null
    submissionTime: Date | null
    deviceFingerprint: string | null
    ipAddress: string | null
    isValid: boolean | null
    sessionId: string | null
  }

  export type VoteCountAggregateOutputType = {
    id: number
    createdAt: number
    encryptedVote: number
    voterHash: number
    submissionTime: number
    deviceFingerprint: number
    ipAddress: number
    isValid: number
    sessionId: number
    _all: number
  }


  export type VoteMinAggregateInputType = {
    id?: true
    createdAt?: true
    encryptedVote?: true
    voterHash?: true
    submissionTime?: true
    deviceFingerprint?: true
    ipAddress?: true
    isValid?: true
    sessionId?: true
  }

  export type VoteMaxAggregateInputType = {
    id?: true
    createdAt?: true
    encryptedVote?: true
    voterHash?: true
    submissionTime?: true
    deviceFingerprint?: true
    ipAddress?: true
    isValid?: true
    sessionId?: true
  }

  export type VoteCountAggregateInputType = {
    id?: true
    createdAt?: true
    encryptedVote?: true
    voterHash?: true
    submissionTime?: true
    deviceFingerprint?: true
    ipAddress?: true
    isValid?: true
    sessionId?: true
    _all?: true
  }

  export type VoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vote to aggregate.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Votes
    **/
    _count?: true | VoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoteMaxAggregateInputType
  }

  export type GetVoteAggregateType<T extends VoteAggregateArgs> = {
        [P in keyof T & keyof AggregateVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVote[P]>
      : GetScalarType<T[P], AggregateVote[P]>
  }




  export type VoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithAggregationInput | VoteOrderByWithAggregationInput[]
    by: VoteScalarFieldEnum[] | VoteScalarFieldEnum
    having?: VoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoteCountAggregateInputType | true
    _min?: VoteMinAggregateInputType
    _max?: VoteMaxAggregateInputType
  }

  export type VoteGroupByOutputType = {
    id: string
    createdAt: Date
    encryptedVote: string
    voterHash: string
    submissionTime: Date
    deviceFingerprint: string | null
    ipAddress: string | null
    isValid: boolean
    sessionId: string
    _count: VoteCountAggregateOutputType | null
    _min: VoteMinAggregateOutputType | null
    _max: VoteMaxAggregateOutputType | null
  }

  type GetVoteGroupByPayload<T extends VoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoteGroupByOutputType[P]>
            : GetScalarType<T[P], VoteGroupByOutputType[P]>
        }
      >
    >


  export type VoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    encryptedVote?: boolean
    voterHash?: boolean
    submissionTime?: boolean
    deviceFingerprint?: boolean
    ipAddress?: boolean
    isValid?: boolean
    sessionId?: boolean
    session?: boolean | VotingSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vote"]>

  export type VoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    encryptedVote?: boolean
    voterHash?: boolean
    submissionTime?: boolean
    deviceFingerprint?: boolean
    ipAddress?: boolean
    isValid?: boolean
    sessionId?: boolean
    session?: boolean | VotingSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vote"]>

  export type VoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    encryptedVote?: boolean
    voterHash?: boolean
    submissionTime?: boolean
    deviceFingerprint?: boolean
    ipAddress?: boolean
    isValid?: boolean
    sessionId?: boolean
    session?: boolean | VotingSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vote"]>

  export type VoteSelectScalar = {
    id?: boolean
    createdAt?: boolean
    encryptedVote?: boolean
    voterHash?: boolean
    submissionTime?: boolean
    deviceFingerprint?: boolean
    ipAddress?: boolean
    isValid?: boolean
    sessionId?: boolean
  }

  export type VoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "encryptedVote" | "voterHash" | "submissionTime" | "deviceFingerprint" | "ipAddress" | "isValid" | "sessionId", ExtArgs["result"]["vote"]>
  export type VoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | VotingSessionDefaultArgs<ExtArgs>
  }
  export type VoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | VotingSessionDefaultArgs<ExtArgs>
  }
  export type VoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | VotingSessionDefaultArgs<ExtArgs>
  }

  export type $VotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vote"
    objects: {
      session: Prisma.$VotingSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      encryptedVote: string
      voterHash: string
      submissionTime: Date
      deviceFingerprint: string | null
      ipAddress: string | null
      isValid: boolean
      sessionId: string
    }, ExtArgs["result"]["vote"]>
    composites: {}
  }

  type VoteGetPayload<S extends boolean | null | undefined | VoteDefaultArgs> = $Result.GetResult<Prisma.$VotePayload, S>

  type VoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoteCountAggregateInputType | true
    }

  export interface VoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vote'], meta: { name: 'Vote' } }
    /**
     * Find zero or one Vote that matches the filter.
     * @param {VoteFindUniqueArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoteFindUniqueArgs>(args: SelectSubset<T, VoteFindUniqueArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoteFindUniqueOrThrowArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoteFindUniqueOrThrowArgs>(args: SelectSubset<T, VoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindFirstArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoteFindFirstArgs>(args?: SelectSubset<T, VoteFindFirstArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindFirstOrThrowArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoteFindFirstOrThrowArgs>(args?: SelectSubset<T, VoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Votes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Votes
     * const votes = await prisma.vote.findMany()
     * 
     * // Get first 10 Votes
     * const votes = await prisma.vote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voteWithIdOnly = await prisma.vote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoteFindManyArgs>(args?: SelectSubset<T, VoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vote.
     * @param {VoteCreateArgs} args - Arguments to create a Vote.
     * @example
     * // Create one Vote
     * const Vote = await prisma.vote.create({
     *   data: {
     *     // ... data to create a Vote
     *   }
     * })
     * 
     */
    create<T extends VoteCreateArgs>(args: SelectSubset<T, VoteCreateArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Votes.
     * @param {VoteCreateManyArgs} args - Arguments to create many Votes.
     * @example
     * // Create many Votes
     * const vote = await prisma.vote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoteCreateManyArgs>(args?: SelectSubset<T, VoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Votes and returns the data saved in the database.
     * @param {VoteCreateManyAndReturnArgs} args - Arguments to create many Votes.
     * @example
     * // Create many Votes
     * const vote = await prisma.vote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Votes and only return the `id`
     * const voteWithIdOnly = await prisma.vote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoteCreateManyAndReturnArgs>(args?: SelectSubset<T, VoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vote.
     * @param {VoteDeleteArgs} args - Arguments to delete one Vote.
     * @example
     * // Delete one Vote
     * const Vote = await prisma.vote.delete({
     *   where: {
     *     // ... filter to delete one Vote
     *   }
     * })
     * 
     */
    delete<T extends VoteDeleteArgs>(args: SelectSubset<T, VoteDeleteArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vote.
     * @param {VoteUpdateArgs} args - Arguments to update one Vote.
     * @example
     * // Update one Vote
     * const vote = await prisma.vote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoteUpdateArgs>(args: SelectSubset<T, VoteUpdateArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Votes.
     * @param {VoteDeleteManyArgs} args - Arguments to filter Votes to delete.
     * @example
     * // Delete a few Votes
     * const { count } = await prisma.vote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoteDeleteManyArgs>(args?: SelectSubset<T, VoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Votes
     * const vote = await prisma.vote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoteUpdateManyArgs>(args: SelectSubset<T, VoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Votes and returns the data updated in the database.
     * @param {VoteUpdateManyAndReturnArgs} args - Arguments to update many Votes.
     * @example
     * // Update many Votes
     * const vote = await prisma.vote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Votes and only return the `id`
     * const voteWithIdOnly = await prisma.vote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoteUpdateManyAndReturnArgs>(args: SelectSubset<T, VoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vote.
     * @param {VoteUpsertArgs} args - Arguments to update or create a Vote.
     * @example
     * // Update or create a Vote
     * const vote = await prisma.vote.upsert({
     *   create: {
     *     // ... data to create a Vote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vote we want to update
     *   }
     * })
     */
    upsert<T extends VoteUpsertArgs>(args: SelectSubset<T, VoteUpsertArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteCountArgs} args - Arguments to filter Votes to count.
     * @example
     * // Count the number of Votes
     * const count = await prisma.vote.count({
     *   where: {
     *     // ... the filter for the Votes we want to count
     *   }
     * })
    **/
    count<T extends VoteCountArgs>(
      args?: Subset<T, VoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoteAggregateArgs>(args: Subset<T, VoteAggregateArgs>): Prisma.PrismaPromise<GetVoteAggregateType<T>>

    /**
     * Group by Vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoteGroupByArgs['orderBy'] }
        : { orderBy?: VoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vote model
   */
  readonly fields: VoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends VotingSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VotingSessionDefaultArgs<ExtArgs>>): Prisma__VotingSessionClient<$Result.GetResult<Prisma.$VotingSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vote model
   */
  interface VoteFieldRefs {
    readonly id: FieldRef<"Vote", 'String'>
    readonly createdAt: FieldRef<"Vote", 'DateTime'>
    readonly encryptedVote: FieldRef<"Vote", 'String'>
    readonly voterHash: FieldRef<"Vote", 'String'>
    readonly submissionTime: FieldRef<"Vote", 'DateTime'>
    readonly deviceFingerprint: FieldRef<"Vote", 'String'>
    readonly ipAddress: FieldRef<"Vote", 'String'>
    readonly isValid: FieldRef<"Vote", 'Boolean'>
    readonly sessionId: FieldRef<"Vote", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Vote findUnique
   */
  export type VoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote findUniqueOrThrow
   */
  export type VoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote findFirst
   */
  export type VoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Votes.
     */
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote findFirstOrThrow
   */
  export type VoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Votes.
     */
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote findMany
   */
  export type VoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Votes to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote create
   */
  export type VoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Vote.
     */
    data: XOR<VoteCreateInput, VoteUncheckedCreateInput>
  }

  /**
   * Vote createMany
   */
  export type VoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Votes.
     */
    data: VoteCreateManyInput | VoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vote createManyAndReturn
   */
  export type VoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * The data used to create many Votes.
     */
    data: VoteCreateManyInput | VoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vote update
   */
  export type VoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Vote.
     */
    data: XOR<VoteUpdateInput, VoteUncheckedUpdateInput>
    /**
     * Choose, which Vote to update.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote updateMany
   */
  export type VoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Votes.
     */
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyInput>
    /**
     * Filter which Votes to update
     */
    where?: VoteWhereInput
    /**
     * Limit how many Votes to update.
     */
    limit?: number
  }

  /**
   * Vote updateManyAndReturn
   */
  export type VoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * The data used to update Votes.
     */
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyInput>
    /**
     * Filter which Votes to update
     */
    where?: VoteWhereInput
    /**
     * Limit how many Votes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vote upsert
   */
  export type VoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Vote to update in case it exists.
     */
    where: VoteWhereUniqueInput
    /**
     * In case the Vote found by the `where` argument doesn't exist, create a new Vote with this data.
     */
    create: XOR<VoteCreateInput, VoteUncheckedCreateInput>
    /**
     * In case the Vote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoteUpdateInput, VoteUncheckedUpdateInput>
  }

  /**
   * Vote delete
   */
  export type VoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter which Vote to delete.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote deleteMany
   */
  export type VoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Votes to delete
     */
    where?: VoteWhereInput
    /**
     * Limit how many Votes to delete.
     */
    limit?: number
  }

  /**
   * Vote without action
   */
  export type VoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    action: string | null
    entity: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    action: string | null
    entity: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    createdAt: number
    action: number
    entity: number
    entityId: number
    oldValues: number
    newValues: number
    ipAddress: number
    userAgent: number
    userId: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    createdAt?: true
    action?: true
    entity?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    createdAt?: true
    action?: true
    entity?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    createdAt?: true
    action?: true
    entity?: true
    entityId?: true
    oldValues?: true
    newValues?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    createdAt: Date
    action: string
    entity: string
    entityId: string | null
    oldValues: JsonValue | null
    newValues: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    createdAt?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "action" | "entity" | "entityId" | "oldValues" | "newValues" | "ipAddress" | "userAgent" | "userId", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      action: string
      entity: string
      entityId: string | null
      oldValues: Prisma.JsonValue | null
      newValues: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      userId: string | null
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly oldValues: FieldRef<"AuditLog", 'Json'>
    readonly newValues: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Subgroup
   */

  export type AggregateSubgroup = {
    _count: SubgroupCountAggregateOutputType | null
    _min: SubgroupMinAggregateOutputType | null
    _max: SubgroupMaxAggregateOutputType | null
  }

  export type SubgroupMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
    isActive: boolean | null
  }

  export type SubgroupMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
    isActive: boolean | null
  }

  export type SubgroupCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    description: number
    isActive: number
    _all: number
  }


  export type SubgroupMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    isActive?: true
  }

  export type SubgroupMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    isActive?: true
  }

  export type SubgroupCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    isActive?: true
    _all?: true
  }

  export type SubgroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subgroup to aggregate.
     */
    where?: SubgroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subgroups to fetch.
     */
    orderBy?: SubgroupOrderByWithRelationInput | SubgroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubgroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subgroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subgroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subgroups
    **/
    _count?: true | SubgroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubgroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubgroupMaxAggregateInputType
  }

  export type GetSubgroupAggregateType<T extends SubgroupAggregateArgs> = {
        [P in keyof T & keyof AggregateSubgroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubgroup[P]>
      : GetScalarType<T[P], AggregateSubgroup[P]>
  }




  export type SubgroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubgroupWhereInput
    orderBy?: SubgroupOrderByWithAggregationInput | SubgroupOrderByWithAggregationInput[]
    by: SubgroupScalarFieldEnum[] | SubgroupScalarFieldEnum
    having?: SubgroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubgroupCountAggregateInputType | true
    _min?: SubgroupMinAggregateInputType
    _max?: SubgroupMaxAggregateInputType
  }

  export type SubgroupGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    description: string | null
    isActive: boolean
    _count: SubgroupCountAggregateOutputType | null
    _min: SubgroupMinAggregateOutputType | null
    _max: SubgroupMaxAggregateOutputType | null
  }

  type GetSubgroupGroupByPayload<T extends SubgroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubgroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubgroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubgroupGroupByOutputType[P]>
            : GetScalarType<T[P], SubgroupGroupByOutputType[P]>
        }
      >
    >


  export type SubgroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    users?: boolean | Subgroup$usersArgs<ExtArgs>
    nominations?: boolean | Subgroup$nominationsArgs<ExtArgs>
    _count?: boolean | SubgroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subgroup"]>

  export type SubgroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["subgroup"]>

  export type SubgroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["subgroup"]>

  export type SubgroupSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
  }

  export type SubgroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "description" | "isActive", ExtArgs["result"]["subgroup"]>
  export type SubgroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Subgroup$usersArgs<ExtArgs>
    nominations?: boolean | Subgroup$nominationsArgs<ExtArgs>
    _count?: boolean | SubgroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubgroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SubgroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SubgroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subgroup"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      nominations: Prisma.$NominationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      description: string | null
      isActive: boolean
    }, ExtArgs["result"]["subgroup"]>
    composites: {}
  }

  type SubgroupGetPayload<S extends boolean | null | undefined | SubgroupDefaultArgs> = $Result.GetResult<Prisma.$SubgroupPayload, S>

  type SubgroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubgroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubgroupCountAggregateInputType | true
    }

  export interface SubgroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subgroup'], meta: { name: 'Subgroup' } }
    /**
     * Find zero or one Subgroup that matches the filter.
     * @param {SubgroupFindUniqueArgs} args - Arguments to find a Subgroup
     * @example
     * // Get one Subgroup
     * const subgroup = await prisma.subgroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubgroupFindUniqueArgs>(args: SelectSubset<T, SubgroupFindUniqueArgs<ExtArgs>>): Prisma__SubgroupClient<$Result.GetResult<Prisma.$SubgroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subgroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubgroupFindUniqueOrThrowArgs} args - Arguments to find a Subgroup
     * @example
     * // Get one Subgroup
     * const subgroup = await prisma.subgroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubgroupFindUniqueOrThrowArgs>(args: SelectSubset<T, SubgroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubgroupClient<$Result.GetResult<Prisma.$SubgroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subgroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubgroupFindFirstArgs} args - Arguments to find a Subgroup
     * @example
     * // Get one Subgroup
     * const subgroup = await prisma.subgroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubgroupFindFirstArgs>(args?: SelectSubset<T, SubgroupFindFirstArgs<ExtArgs>>): Prisma__SubgroupClient<$Result.GetResult<Prisma.$SubgroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subgroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubgroupFindFirstOrThrowArgs} args - Arguments to find a Subgroup
     * @example
     * // Get one Subgroup
     * const subgroup = await prisma.subgroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubgroupFindFirstOrThrowArgs>(args?: SelectSubset<T, SubgroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubgroupClient<$Result.GetResult<Prisma.$SubgroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subgroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubgroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subgroups
     * const subgroups = await prisma.subgroup.findMany()
     * 
     * // Get first 10 Subgroups
     * const subgroups = await prisma.subgroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subgroupWithIdOnly = await prisma.subgroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubgroupFindManyArgs>(args?: SelectSubset<T, SubgroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubgroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subgroup.
     * @param {SubgroupCreateArgs} args - Arguments to create a Subgroup.
     * @example
     * // Create one Subgroup
     * const Subgroup = await prisma.subgroup.create({
     *   data: {
     *     // ... data to create a Subgroup
     *   }
     * })
     * 
     */
    create<T extends SubgroupCreateArgs>(args: SelectSubset<T, SubgroupCreateArgs<ExtArgs>>): Prisma__SubgroupClient<$Result.GetResult<Prisma.$SubgroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subgroups.
     * @param {SubgroupCreateManyArgs} args - Arguments to create many Subgroups.
     * @example
     * // Create many Subgroups
     * const subgroup = await prisma.subgroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubgroupCreateManyArgs>(args?: SelectSubset<T, SubgroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subgroups and returns the data saved in the database.
     * @param {SubgroupCreateManyAndReturnArgs} args - Arguments to create many Subgroups.
     * @example
     * // Create many Subgroups
     * const subgroup = await prisma.subgroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subgroups and only return the `id`
     * const subgroupWithIdOnly = await prisma.subgroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubgroupCreateManyAndReturnArgs>(args?: SelectSubset<T, SubgroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubgroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subgroup.
     * @param {SubgroupDeleteArgs} args - Arguments to delete one Subgroup.
     * @example
     * // Delete one Subgroup
     * const Subgroup = await prisma.subgroup.delete({
     *   where: {
     *     // ... filter to delete one Subgroup
     *   }
     * })
     * 
     */
    delete<T extends SubgroupDeleteArgs>(args: SelectSubset<T, SubgroupDeleteArgs<ExtArgs>>): Prisma__SubgroupClient<$Result.GetResult<Prisma.$SubgroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subgroup.
     * @param {SubgroupUpdateArgs} args - Arguments to update one Subgroup.
     * @example
     * // Update one Subgroup
     * const subgroup = await prisma.subgroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubgroupUpdateArgs>(args: SelectSubset<T, SubgroupUpdateArgs<ExtArgs>>): Prisma__SubgroupClient<$Result.GetResult<Prisma.$SubgroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subgroups.
     * @param {SubgroupDeleteManyArgs} args - Arguments to filter Subgroups to delete.
     * @example
     * // Delete a few Subgroups
     * const { count } = await prisma.subgroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubgroupDeleteManyArgs>(args?: SelectSubset<T, SubgroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subgroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubgroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subgroups
     * const subgroup = await prisma.subgroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubgroupUpdateManyArgs>(args: SelectSubset<T, SubgroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subgroups and returns the data updated in the database.
     * @param {SubgroupUpdateManyAndReturnArgs} args - Arguments to update many Subgroups.
     * @example
     * // Update many Subgroups
     * const subgroup = await prisma.subgroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subgroups and only return the `id`
     * const subgroupWithIdOnly = await prisma.subgroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubgroupUpdateManyAndReturnArgs>(args: SelectSubset<T, SubgroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubgroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subgroup.
     * @param {SubgroupUpsertArgs} args - Arguments to update or create a Subgroup.
     * @example
     * // Update or create a Subgroup
     * const subgroup = await prisma.subgroup.upsert({
     *   create: {
     *     // ... data to create a Subgroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subgroup we want to update
     *   }
     * })
     */
    upsert<T extends SubgroupUpsertArgs>(args: SelectSubset<T, SubgroupUpsertArgs<ExtArgs>>): Prisma__SubgroupClient<$Result.GetResult<Prisma.$SubgroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subgroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubgroupCountArgs} args - Arguments to filter Subgroups to count.
     * @example
     * // Count the number of Subgroups
     * const count = await prisma.subgroup.count({
     *   where: {
     *     // ... the filter for the Subgroups we want to count
     *   }
     * })
    **/
    count<T extends SubgroupCountArgs>(
      args?: Subset<T, SubgroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubgroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subgroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubgroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubgroupAggregateArgs>(args: Subset<T, SubgroupAggregateArgs>): Prisma.PrismaPromise<GetSubgroupAggregateType<T>>

    /**
     * Group by Subgroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubgroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubgroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubgroupGroupByArgs['orderBy'] }
        : { orderBy?: SubgroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubgroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubgroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subgroup model
   */
  readonly fields: SubgroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subgroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubgroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Subgroup$usersArgs<ExtArgs> = {}>(args?: Subset<T, Subgroup$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    nominations<T extends Subgroup$nominationsArgs<ExtArgs> = {}>(args?: Subset<T, Subgroup$nominationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NominationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subgroup model
   */
  interface SubgroupFieldRefs {
    readonly id: FieldRef<"Subgroup", 'String'>
    readonly createdAt: FieldRef<"Subgroup", 'DateTime'>
    readonly updatedAt: FieldRef<"Subgroup", 'DateTime'>
    readonly name: FieldRef<"Subgroup", 'String'>
    readonly description: FieldRef<"Subgroup", 'String'>
    readonly isActive: FieldRef<"Subgroup", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Subgroup findUnique
   */
  export type SubgroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null
    /**
     * Filter, which Subgroup to fetch.
     */
    where: SubgroupWhereUniqueInput
  }

  /**
   * Subgroup findUniqueOrThrow
   */
  export type SubgroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null
    /**
     * Filter, which Subgroup to fetch.
     */
    where: SubgroupWhereUniqueInput
  }

  /**
   * Subgroup findFirst
   */
  export type SubgroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null
    /**
     * Filter, which Subgroup to fetch.
     */
    where?: SubgroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subgroups to fetch.
     */
    orderBy?: SubgroupOrderByWithRelationInput | SubgroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subgroups.
     */
    cursor?: SubgroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subgroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subgroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subgroups.
     */
    distinct?: SubgroupScalarFieldEnum | SubgroupScalarFieldEnum[]
  }

  /**
   * Subgroup findFirstOrThrow
   */
  export type SubgroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null
    /**
     * Filter, which Subgroup to fetch.
     */
    where?: SubgroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subgroups to fetch.
     */
    orderBy?: SubgroupOrderByWithRelationInput | SubgroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subgroups.
     */
    cursor?: SubgroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subgroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subgroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subgroups.
     */
    distinct?: SubgroupScalarFieldEnum | SubgroupScalarFieldEnum[]
  }

  /**
   * Subgroup findMany
   */
  export type SubgroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null
    /**
     * Filter, which Subgroups to fetch.
     */
    where?: SubgroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subgroups to fetch.
     */
    orderBy?: SubgroupOrderByWithRelationInput | SubgroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subgroups.
     */
    cursor?: SubgroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subgroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subgroups.
     */
    skip?: number
    distinct?: SubgroupScalarFieldEnum | SubgroupScalarFieldEnum[]
  }

  /**
   * Subgroup create
   */
  export type SubgroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null
    /**
     * The data needed to create a Subgroup.
     */
    data: XOR<SubgroupCreateInput, SubgroupUncheckedCreateInput>
  }

  /**
   * Subgroup createMany
   */
  export type SubgroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subgroups.
     */
    data: SubgroupCreateManyInput | SubgroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subgroup createManyAndReturn
   */
  export type SubgroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null
    /**
     * The data used to create many Subgroups.
     */
    data: SubgroupCreateManyInput | SubgroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subgroup update
   */
  export type SubgroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null
    /**
     * The data needed to update a Subgroup.
     */
    data: XOR<SubgroupUpdateInput, SubgroupUncheckedUpdateInput>
    /**
     * Choose, which Subgroup to update.
     */
    where: SubgroupWhereUniqueInput
  }

  /**
   * Subgroup updateMany
   */
  export type SubgroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subgroups.
     */
    data: XOR<SubgroupUpdateManyMutationInput, SubgroupUncheckedUpdateManyInput>
    /**
     * Filter which Subgroups to update
     */
    where?: SubgroupWhereInput
    /**
     * Limit how many Subgroups to update.
     */
    limit?: number
  }

  /**
   * Subgroup updateManyAndReturn
   */
  export type SubgroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null
    /**
     * The data used to update Subgroups.
     */
    data: XOR<SubgroupUpdateManyMutationInput, SubgroupUncheckedUpdateManyInput>
    /**
     * Filter which Subgroups to update
     */
    where?: SubgroupWhereInput
    /**
     * Limit how many Subgroups to update.
     */
    limit?: number
  }

  /**
   * Subgroup upsert
   */
  export type SubgroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null
    /**
     * The filter to search for the Subgroup to update in case it exists.
     */
    where: SubgroupWhereUniqueInput
    /**
     * In case the Subgroup found by the `where` argument doesn't exist, create a new Subgroup with this data.
     */
    create: XOR<SubgroupCreateInput, SubgroupUncheckedCreateInput>
    /**
     * In case the Subgroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubgroupUpdateInput, SubgroupUncheckedUpdateInput>
  }

  /**
   * Subgroup delete
   */
  export type SubgroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null
    /**
     * Filter which Subgroup to delete.
     */
    where: SubgroupWhereUniqueInput
  }

  /**
   * Subgroup deleteMany
   */
  export type SubgroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subgroups to delete
     */
    where?: SubgroupWhereInput
    /**
     * Limit how many Subgroups to delete.
     */
    limit?: number
  }

  /**
   * Subgroup.users
   */
  export type Subgroup$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Subgroup.nominations
   */
  export type Subgroup$nominationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nomination
     */
    select?: NominationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nomination
     */
    omit?: NominationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NominationInclude<ExtArgs> | null
    where?: NominationWhereInput
    orderBy?: NominationOrderByWithRelationInput | NominationOrderByWithRelationInput[]
    cursor?: NominationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NominationScalarFieldEnum | NominationScalarFieldEnum[]
  }

  /**
   * Subgroup without action
   */
  export type SubgroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null
  }


  /**
   * Model Programme
   */

  export type AggregateProgramme = {
    _count: ProgrammeCountAggregateOutputType | null
    _avg: ProgrammeAvgAggregateOutputType | null
    _sum: ProgrammeSumAggregateOutputType | null
    _min: ProgrammeMinAggregateOutputType | null
    _max: ProgrammeMaxAggregateOutputType | null
  }

  export type ProgrammeAvgAggregateOutputType = {
    duration: number | null
  }

  export type ProgrammeSumAggregateOutputType = {
    duration: number | null
  }

  export type ProgrammeMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    college: string | null
    duration: number | null
    isActive: boolean | null
  }

  export type ProgrammeMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    college: string | null
    duration: number | null
    isActive: boolean | null
  }

  export type ProgrammeCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    college: number
    duration: number
    isActive: number
    _all: number
  }


  export type ProgrammeAvgAggregateInputType = {
    duration?: true
  }

  export type ProgrammeSumAggregateInputType = {
    duration?: true
  }

  export type ProgrammeMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    college?: true
    duration?: true
    isActive?: true
  }

  export type ProgrammeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    college?: true
    duration?: true
    isActive?: true
  }

  export type ProgrammeCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    college?: true
    duration?: true
    isActive?: true
    _all?: true
  }

  export type ProgrammeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programme to aggregate.
     */
    where?: ProgrammeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programmes to fetch.
     */
    orderBy?: ProgrammeOrderByWithRelationInput | ProgrammeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgrammeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programmes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programmes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Programmes
    **/
    _count?: true | ProgrammeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgrammeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgrammeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgrammeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgrammeMaxAggregateInputType
  }

  export type GetProgrammeAggregateType<T extends ProgrammeAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramme]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramme[P]>
      : GetScalarType<T[P], AggregateProgramme[P]>
  }




  export type ProgrammeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgrammeWhereInput
    orderBy?: ProgrammeOrderByWithAggregationInput | ProgrammeOrderByWithAggregationInput[]
    by: ProgrammeScalarFieldEnum[] | ProgrammeScalarFieldEnum
    having?: ProgrammeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgrammeCountAggregateInputType | true
    _avg?: ProgrammeAvgAggregateInputType
    _sum?: ProgrammeSumAggregateInputType
    _min?: ProgrammeMinAggregateInputType
    _max?: ProgrammeMaxAggregateInputType
  }

  export type ProgrammeGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    college: string | null
    duration: number | null
    isActive: boolean
    _count: ProgrammeCountAggregateOutputType | null
    _avg: ProgrammeAvgAggregateOutputType | null
    _sum: ProgrammeSumAggregateOutputType | null
    _min: ProgrammeMinAggregateOutputType | null
    _max: ProgrammeMaxAggregateOutputType | null
  }

  type GetProgrammeGroupByPayload<T extends ProgrammeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgrammeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgrammeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgrammeGroupByOutputType[P]>
            : GetScalarType<T[P], ProgrammeGroupByOutputType[P]>
        }
      >
    >


  export type ProgrammeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    college?: boolean
    duration?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["programme"]>

  export type ProgrammeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    college?: boolean
    duration?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["programme"]>

  export type ProgrammeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    college?: boolean
    duration?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["programme"]>

  export type ProgrammeSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    college?: boolean
    duration?: boolean
    isActive?: boolean
  }

  export type ProgrammeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "college" | "duration" | "isActive", ExtArgs["result"]["programme"]>

  export type $ProgrammePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Programme"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      college: string | null
      duration: number | null
      isActive: boolean
    }, ExtArgs["result"]["programme"]>
    composites: {}
  }

  type ProgrammeGetPayload<S extends boolean | null | undefined | ProgrammeDefaultArgs> = $Result.GetResult<Prisma.$ProgrammePayload, S>

  type ProgrammeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgrammeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgrammeCountAggregateInputType | true
    }

  export interface ProgrammeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Programme'], meta: { name: 'Programme' } }
    /**
     * Find zero or one Programme that matches the filter.
     * @param {ProgrammeFindUniqueArgs} args - Arguments to find a Programme
     * @example
     * // Get one Programme
     * const programme = await prisma.programme.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgrammeFindUniqueArgs>(args: SelectSubset<T, ProgrammeFindUniqueArgs<ExtArgs>>): Prisma__ProgrammeClient<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Programme that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgrammeFindUniqueOrThrowArgs} args - Arguments to find a Programme
     * @example
     * // Get one Programme
     * const programme = await prisma.programme.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgrammeFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgrammeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgrammeClient<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Programme that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgrammeFindFirstArgs} args - Arguments to find a Programme
     * @example
     * // Get one Programme
     * const programme = await prisma.programme.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgrammeFindFirstArgs>(args?: SelectSubset<T, ProgrammeFindFirstArgs<ExtArgs>>): Prisma__ProgrammeClient<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Programme that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgrammeFindFirstOrThrowArgs} args - Arguments to find a Programme
     * @example
     * // Get one Programme
     * const programme = await prisma.programme.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgrammeFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgrammeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgrammeClient<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Programmes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgrammeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Programmes
     * const programmes = await prisma.programme.findMany()
     * 
     * // Get first 10 Programmes
     * const programmes = await prisma.programme.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programmeWithIdOnly = await prisma.programme.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgrammeFindManyArgs>(args?: SelectSubset<T, ProgrammeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Programme.
     * @param {ProgrammeCreateArgs} args - Arguments to create a Programme.
     * @example
     * // Create one Programme
     * const Programme = await prisma.programme.create({
     *   data: {
     *     // ... data to create a Programme
     *   }
     * })
     * 
     */
    create<T extends ProgrammeCreateArgs>(args: SelectSubset<T, ProgrammeCreateArgs<ExtArgs>>): Prisma__ProgrammeClient<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Programmes.
     * @param {ProgrammeCreateManyArgs} args - Arguments to create many Programmes.
     * @example
     * // Create many Programmes
     * const programme = await prisma.programme.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgrammeCreateManyArgs>(args?: SelectSubset<T, ProgrammeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Programmes and returns the data saved in the database.
     * @param {ProgrammeCreateManyAndReturnArgs} args - Arguments to create many Programmes.
     * @example
     * // Create many Programmes
     * const programme = await prisma.programme.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Programmes and only return the `id`
     * const programmeWithIdOnly = await prisma.programme.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgrammeCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgrammeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Programme.
     * @param {ProgrammeDeleteArgs} args - Arguments to delete one Programme.
     * @example
     * // Delete one Programme
     * const Programme = await prisma.programme.delete({
     *   where: {
     *     // ... filter to delete one Programme
     *   }
     * })
     * 
     */
    delete<T extends ProgrammeDeleteArgs>(args: SelectSubset<T, ProgrammeDeleteArgs<ExtArgs>>): Prisma__ProgrammeClient<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Programme.
     * @param {ProgrammeUpdateArgs} args - Arguments to update one Programme.
     * @example
     * // Update one Programme
     * const programme = await prisma.programme.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgrammeUpdateArgs>(args: SelectSubset<T, ProgrammeUpdateArgs<ExtArgs>>): Prisma__ProgrammeClient<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Programmes.
     * @param {ProgrammeDeleteManyArgs} args - Arguments to filter Programmes to delete.
     * @example
     * // Delete a few Programmes
     * const { count } = await prisma.programme.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgrammeDeleteManyArgs>(args?: SelectSubset<T, ProgrammeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programmes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgrammeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Programmes
     * const programme = await prisma.programme.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgrammeUpdateManyArgs>(args: SelectSubset<T, ProgrammeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programmes and returns the data updated in the database.
     * @param {ProgrammeUpdateManyAndReturnArgs} args - Arguments to update many Programmes.
     * @example
     * // Update many Programmes
     * const programme = await prisma.programme.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Programmes and only return the `id`
     * const programmeWithIdOnly = await prisma.programme.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProgrammeUpdateManyAndReturnArgs>(args: SelectSubset<T, ProgrammeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Programme.
     * @param {ProgrammeUpsertArgs} args - Arguments to update or create a Programme.
     * @example
     * // Update or create a Programme
     * const programme = await prisma.programme.upsert({
     *   create: {
     *     // ... data to create a Programme
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Programme we want to update
     *   }
     * })
     */
    upsert<T extends ProgrammeUpsertArgs>(args: SelectSubset<T, ProgrammeUpsertArgs<ExtArgs>>): Prisma__ProgrammeClient<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Programmes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgrammeCountArgs} args - Arguments to filter Programmes to count.
     * @example
     * // Count the number of Programmes
     * const count = await prisma.programme.count({
     *   where: {
     *     // ... the filter for the Programmes we want to count
     *   }
     * })
    **/
    count<T extends ProgrammeCountArgs>(
      args?: Subset<T, ProgrammeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgrammeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Programme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgrammeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgrammeAggregateArgs>(args: Subset<T, ProgrammeAggregateArgs>): Prisma.PrismaPromise<GetProgrammeAggregateType<T>>

    /**
     * Group by Programme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgrammeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgrammeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgrammeGroupByArgs['orderBy'] }
        : { orderBy?: ProgrammeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgrammeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgrammeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Programme model
   */
  readonly fields: ProgrammeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Programme.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgrammeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Programme model
   */
  interface ProgrammeFieldRefs {
    readonly id: FieldRef<"Programme", 'String'>
    readonly createdAt: FieldRef<"Programme", 'DateTime'>
    readonly updatedAt: FieldRef<"Programme", 'DateTime'>
    readonly name: FieldRef<"Programme", 'String'>
    readonly college: FieldRef<"Programme", 'String'>
    readonly duration: FieldRef<"Programme", 'Int'>
    readonly isActive: FieldRef<"Programme", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Programme findUnique
   */
  export type ProgrammeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Programme
     */
    omit?: ProgrammeOmit<ExtArgs> | null
    /**
     * Filter, which Programme to fetch.
     */
    where: ProgrammeWhereUniqueInput
  }

  /**
   * Programme findUniqueOrThrow
   */
  export type ProgrammeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Programme
     */
    omit?: ProgrammeOmit<ExtArgs> | null
    /**
     * Filter, which Programme to fetch.
     */
    where: ProgrammeWhereUniqueInput
  }

  /**
   * Programme findFirst
   */
  export type ProgrammeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Programme
     */
    omit?: ProgrammeOmit<ExtArgs> | null
    /**
     * Filter, which Programme to fetch.
     */
    where?: ProgrammeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programmes to fetch.
     */
    orderBy?: ProgrammeOrderByWithRelationInput | ProgrammeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programmes.
     */
    cursor?: ProgrammeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programmes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programmes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programmes.
     */
    distinct?: ProgrammeScalarFieldEnum | ProgrammeScalarFieldEnum[]
  }

  /**
   * Programme findFirstOrThrow
   */
  export type ProgrammeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Programme
     */
    omit?: ProgrammeOmit<ExtArgs> | null
    /**
     * Filter, which Programme to fetch.
     */
    where?: ProgrammeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programmes to fetch.
     */
    orderBy?: ProgrammeOrderByWithRelationInput | ProgrammeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programmes.
     */
    cursor?: ProgrammeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programmes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programmes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programmes.
     */
    distinct?: ProgrammeScalarFieldEnum | ProgrammeScalarFieldEnum[]
  }

  /**
   * Programme findMany
   */
  export type ProgrammeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Programme
     */
    omit?: ProgrammeOmit<ExtArgs> | null
    /**
     * Filter, which Programmes to fetch.
     */
    where?: ProgrammeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programmes to fetch.
     */
    orderBy?: ProgrammeOrderByWithRelationInput | ProgrammeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Programmes.
     */
    cursor?: ProgrammeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programmes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programmes.
     */
    skip?: number
    distinct?: ProgrammeScalarFieldEnum | ProgrammeScalarFieldEnum[]
  }

  /**
   * Programme create
   */
  export type ProgrammeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Programme
     */
    omit?: ProgrammeOmit<ExtArgs> | null
    /**
     * The data needed to create a Programme.
     */
    data: XOR<ProgrammeCreateInput, ProgrammeUncheckedCreateInput>
  }

  /**
   * Programme createMany
   */
  export type ProgrammeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Programmes.
     */
    data: ProgrammeCreateManyInput | ProgrammeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Programme createManyAndReturn
   */
  export type ProgrammeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Programme
     */
    omit?: ProgrammeOmit<ExtArgs> | null
    /**
     * The data used to create many Programmes.
     */
    data: ProgrammeCreateManyInput | ProgrammeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Programme update
   */
  export type ProgrammeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Programme
     */
    omit?: ProgrammeOmit<ExtArgs> | null
    /**
     * The data needed to update a Programme.
     */
    data: XOR<ProgrammeUpdateInput, ProgrammeUncheckedUpdateInput>
    /**
     * Choose, which Programme to update.
     */
    where: ProgrammeWhereUniqueInput
  }

  /**
   * Programme updateMany
   */
  export type ProgrammeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Programmes.
     */
    data: XOR<ProgrammeUpdateManyMutationInput, ProgrammeUncheckedUpdateManyInput>
    /**
     * Filter which Programmes to update
     */
    where?: ProgrammeWhereInput
    /**
     * Limit how many Programmes to update.
     */
    limit?: number
  }

  /**
   * Programme updateManyAndReturn
   */
  export type ProgrammeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Programme
     */
    omit?: ProgrammeOmit<ExtArgs> | null
    /**
     * The data used to update Programmes.
     */
    data: XOR<ProgrammeUpdateManyMutationInput, ProgrammeUncheckedUpdateManyInput>
    /**
     * Filter which Programmes to update
     */
    where?: ProgrammeWhereInput
    /**
     * Limit how many Programmes to update.
     */
    limit?: number
  }

  /**
   * Programme upsert
   */
  export type ProgrammeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Programme
     */
    omit?: ProgrammeOmit<ExtArgs> | null
    /**
     * The filter to search for the Programme to update in case it exists.
     */
    where: ProgrammeWhereUniqueInput
    /**
     * In case the Programme found by the `where` argument doesn't exist, create a new Programme with this data.
     */
    create: XOR<ProgrammeCreateInput, ProgrammeUncheckedCreateInput>
    /**
     * In case the Programme was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgrammeUpdateInput, ProgrammeUncheckedUpdateInput>
  }

  /**
   * Programme delete
   */
  export type ProgrammeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Programme
     */
    omit?: ProgrammeOmit<ExtArgs> | null
    /**
     * Filter which Programme to delete.
     */
    where: ProgrammeWhereUniqueInput
  }

  /**
   * Programme deleteMany
   */
  export type ProgrammeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programmes to delete
     */
    where?: ProgrammeWhereInput
    /**
     * Limit how many Programmes to delete.
     */
    limit?: number
  }

  /**
   * Programme without action
   */
  export type ProgrammeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Programme
     */
    omit?: ProgrammeOmit<ExtArgs> | null
  }


  /**
   * Model SystemConfig
   */

  export type AggregateSystemConfig = {
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  export type SystemConfigMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    key: string | null
    value: string | null
    type: string | null
  }

  export type SystemConfigMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    key: string | null
    value: string | null
    type: string | null
  }

  export type SystemConfigCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    key: number
    value: number
    type: number
    _all: number
  }


  export type SystemConfigMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    key?: true
    value?: true
    type?: true
  }

  export type SystemConfigMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    key?: true
    value?: true
    type?: true
  }

  export type SystemConfigCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    key?: true
    value?: true
    type?: true
    _all?: true
  }

  export type SystemConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfig to aggregate.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemConfigs
    **/
    _count?: true | SystemConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemConfigMaxAggregateInputType
  }

  export type GetSystemConfigAggregateType<T extends SystemConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemConfig[P]>
      : GetScalarType<T[P], AggregateSystemConfig[P]>
  }




  export type SystemConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemConfigWhereInput
    orderBy?: SystemConfigOrderByWithAggregationInput | SystemConfigOrderByWithAggregationInput[]
    by: SystemConfigScalarFieldEnum[] | SystemConfigScalarFieldEnum
    having?: SystemConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemConfigCountAggregateInputType | true
    _min?: SystemConfigMinAggregateInputType
    _max?: SystemConfigMaxAggregateInputType
  }

  export type SystemConfigGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    key: string
    value: string
    type: string
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  type GetSystemConfigGroupByPayload<T extends SystemConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
        }
      >
    >


  export type SystemConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
  }

  export type SystemConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "key" | "value" | "type", ExtArgs["result"]["systemConfig"]>

  export type $SystemConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      key: string
      value: string
      type: string
    }, ExtArgs["result"]["systemConfig"]>
    composites: {}
  }

  type SystemConfigGetPayload<S extends boolean | null | undefined | SystemConfigDefaultArgs> = $Result.GetResult<Prisma.$SystemConfigPayload, S>

  type SystemConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemConfigCountAggregateInputType | true
    }

  export interface SystemConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemConfig'], meta: { name: 'SystemConfig' } }
    /**
     * Find zero or one SystemConfig that matches the filter.
     * @param {SystemConfigFindUniqueArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemConfigFindUniqueArgs>(args: SelectSubset<T, SystemConfigFindUniqueArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemConfigFindUniqueOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemConfigFindFirstArgs>(args?: SelectSubset<T, SystemConfigFindFirstArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany()
     * 
     * // Get first 10 SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemConfigFindManyArgs>(args?: SelectSubset<T, SystemConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemConfig.
     * @param {SystemConfigCreateArgs} args - Arguments to create a SystemConfig.
     * @example
     * // Create one SystemConfig
     * const SystemConfig = await prisma.systemConfig.create({
     *   data: {
     *     // ... data to create a SystemConfig
     *   }
     * })
     * 
     */
    create<T extends SystemConfigCreateArgs>(args: SelectSubset<T, SystemConfigCreateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemConfigs.
     * @param {SystemConfigCreateManyArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemConfigCreateManyArgs>(args?: SelectSubset<T, SystemConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemConfigs and returns the data saved in the database.
     * @param {SystemConfigCreateManyAndReturnArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemConfig.
     * @param {SystemConfigDeleteArgs} args - Arguments to delete one SystemConfig.
     * @example
     * // Delete one SystemConfig
     * const SystemConfig = await prisma.systemConfig.delete({
     *   where: {
     *     // ... filter to delete one SystemConfig
     *   }
     * })
     * 
     */
    delete<T extends SystemConfigDeleteArgs>(args: SelectSubset<T, SystemConfigDeleteArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemConfig.
     * @param {SystemConfigUpdateArgs} args - Arguments to update one SystemConfig.
     * @example
     * // Update one SystemConfig
     * const systemConfig = await prisma.systemConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemConfigUpdateArgs>(args: SelectSubset<T, SystemConfigUpdateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemConfigs.
     * @param {SystemConfigDeleteManyArgs} args - Arguments to filter SystemConfigs to delete.
     * @example
     * // Delete a few SystemConfigs
     * const { count } = await prisma.systemConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemConfigDeleteManyArgs>(args?: SelectSubset<T, SystemConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemConfigUpdateManyArgs>(args: SelectSubset<T, SystemConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs and returns the data updated in the database.
     * @param {SystemConfigUpdateManyAndReturnArgs} args - Arguments to update many SystemConfigs.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemConfig.
     * @param {SystemConfigUpsertArgs} args - Arguments to update or create a SystemConfig.
     * @example
     * // Update or create a SystemConfig
     * const systemConfig = await prisma.systemConfig.upsert({
     *   create: {
     *     // ... data to create a SystemConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemConfig we want to update
     *   }
     * })
     */
    upsert<T extends SystemConfigUpsertArgs>(args: SelectSubset<T, SystemConfigUpsertArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigCountArgs} args - Arguments to filter SystemConfigs to count.
     * @example
     * // Count the number of SystemConfigs
     * const count = await prisma.systemConfig.count({
     *   where: {
     *     // ... the filter for the SystemConfigs we want to count
     *   }
     * })
    **/
    count<T extends SystemConfigCountArgs>(
      args?: Subset<T, SystemConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemConfigAggregateArgs>(args: Subset<T, SystemConfigAggregateArgs>): Prisma.PrismaPromise<GetSystemConfigAggregateType<T>>

    /**
     * Group by SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemConfigGroupByArgs['orderBy'] }
        : { orderBy?: SystemConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemConfig model
   */
  readonly fields: SystemConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemConfig model
   */
  interface SystemConfigFieldRefs {
    readonly id: FieldRef<"SystemConfig", 'String'>
    readonly createdAt: FieldRef<"SystemConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemConfig", 'DateTime'>
    readonly key: FieldRef<"SystemConfig", 'String'>
    readonly value: FieldRef<"SystemConfig", 'String'>
    readonly type: FieldRef<"SystemConfig", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SystemConfig findUnique
   */
  export type SystemConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findUniqueOrThrow
   */
  export type SystemConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findFirst
   */
  export type SystemConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findFirstOrThrow
   */
  export type SystemConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findMany
   */
  export type SystemConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfigs to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig create
   */
  export type SystemConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemConfig.
     */
    data: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
  }

  /**
   * SystemConfig createMany
   */
  export type SystemConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig createManyAndReturn
   */
  export type SystemConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig update
   */
  export type SystemConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemConfig.
     */
    data: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
    /**
     * Choose, which SystemConfig to update.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig updateMany
   */
  export type SystemConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to update.
     */
    limit?: number
  }

  /**
   * SystemConfig updateManyAndReturn
   */
  export type SystemConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to update.
     */
    limit?: number
  }

  /**
   * SystemConfig upsert
   */
  export type SystemConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemConfig to update in case it exists.
     */
    where: SystemConfigWhereUniqueInput
    /**
     * In case the SystemConfig found by the `where` argument doesn't exist, create a new SystemConfig with this data.
     */
    create: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
    /**
     * In case the SystemConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
  }

  /**
   * SystemConfig delete
   */
  export type SystemConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter which SystemConfig to delete.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig deleteMany
   */
  export type SystemConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfigs to delete
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to delete.
     */
    limit?: number
  }

  /**
   * SystemConfig without action
   */
  export type SystemConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
  }


  /**
   * Model ElectionTimeline
   */

  export type AggregateElectionTimeline = {
    _count: ElectionTimelineCountAggregateOutputType | null
    _avg: ElectionTimelineAvgAggregateOutputType | null
    _sum: ElectionTimelineSumAggregateOutputType | null
    _min: ElectionTimelineMinAggregateOutputType | null
    _max: ElectionTimelineMaxAggregateOutputType | null
  }

  export type ElectionTimelineAvgAggregateOutputType = {
    gracePeriodHours: number | null
  }

  export type ElectionTimelineSumAggregateOutputType = {
    gracePeriodHours: number | null
  }

  export type ElectionTimelineMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    phase: string | null
    startDate: Date | null
    endDate: Date | null
    gracePeriodHours: number | null
    isActive: boolean | null
    automaticTransition: boolean | null
  }

  export type ElectionTimelineMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    phase: string | null
    startDate: Date | null
    endDate: Date | null
    gracePeriodHours: number | null
    isActive: boolean | null
    automaticTransition: boolean | null
  }

  export type ElectionTimelineCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    phase: number
    startDate: number
    endDate: number
    gracePeriodHours: number
    isActive: number
    automaticTransition: number
    _all: number
  }


  export type ElectionTimelineAvgAggregateInputType = {
    gracePeriodHours?: true
  }

  export type ElectionTimelineSumAggregateInputType = {
    gracePeriodHours?: true
  }

  export type ElectionTimelineMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    phase?: true
    startDate?: true
    endDate?: true
    gracePeriodHours?: true
    isActive?: true
    automaticTransition?: true
  }

  export type ElectionTimelineMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    phase?: true
    startDate?: true
    endDate?: true
    gracePeriodHours?: true
    isActive?: true
    automaticTransition?: true
  }

  export type ElectionTimelineCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    phase?: true
    startDate?: true
    endDate?: true
    gracePeriodHours?: true
    isActive?: true
    automaticTransition?: true
    _all?: true
  }

  export type ElectionTimelineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ElectionTimeline to aggregate.
     */
    where?: ElectionTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElectionTimelines to fetch.
     */
    orderBy?: ElectionTimelineOrderByWithRelationInput | ElectionTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ElectionTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElectionTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElectionTimelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ElectionTimelines
    **/
    _count?: true | ElectionTimelineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ElectionTimelineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ElectionTimelineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ElectionTimelineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ElectionTimelineMaxAggregateInputType
  }

  export type GetElectionTimelineAggregateType<T extends ElectionTimelineAggregateArgs> = {
        [P in keyof T & keyof AggregateElectionTimeline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateElectionTimeline[P]>
      : GetScalarType<T[P], AggregateElectionTimeline[P]>
  }




  export type ElectionTimelineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ElectionTimelineWhereInput
    orderBy?: ElectionTimelineOrderByWithAggregationInput | ElectionTimelineOrderByWithAggregationInput[]
    by: ElectionTimelineScalarFieldEnum[] | ElectionTimelineScalarFieldEnum
    having?: ElectionTimelineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ElectionTimelineCountAggregateInputType | true
    _avg?: ElectionTimelineAvgAggregateInputType
    _sum?: ElectionTimelineSumAggregateInputType
    _min?: ElectionTimelineMinAggregateInputType
    _max?: ElectionTimelineMaxAggregateInputType
  }

  export type ElectionTimelineGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    phase: string
    startDate: Date
    endDate: Date
    gracePeriodHours: number
    isActive: boolean
    automaticTransition: boolean
    _count: ElectionTimelineCountAggregateOutputType | null
    _avg: ElectionTimelineAvgAggregateOutputType | null
    _sum: ElectionTimelineSumAggregateOutputType | null
    _min: ElectionTimelineMinAggregateOutputType | null
    _max: ElectionTimelineMaxAggregateOutputType | null
  }

  type GetElectionTimelineGroupByPayload<T extends ElectionTimelineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ElectionTimelineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ElectionTimelineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ElectionTimelineGroupByOutputType[P]>
            : GetScalarType<T[P], ElectionTimelineGroupByOutputType[P]>
        }
      >
    >


  export type ElectionTimelineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phase?: boolean
    startDate?: boolean
    endDate?: boolean
    gracePeriodHours?: boolean
    isActive?: boolean
    automaticTransition?: boolean
  }, ExtArgs["result"]["electionTimeline"]>

  export type ElectionTimelineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phase?: boolean
    startDate?: boolean
    endDate?: boolean
    gracePeriodHours?: boolean
    isActive?: boolean
    automaticTransition?: boolean
  }, ExtArgs["result"]["electionTimeline"]>

  export type ElectionTimelineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phase?: boolean
    startDate?: boolean
    endDate?: boolean
    gracePeriodHours?: boolean
    isActive?: boolean
    automaticTransition?: boolean
  }, ExtArgs["result"]["electionTimeline"]>

  export type ElectionTimelineSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phase?: boolean
    startDate?: boolean
    endDate?: boolean
    gracePeriodHours?: boolean
    isActive?: boolean
    automaticTransition?: boolean
  }

  export type ElectionTimelineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "phase" | "startDate" | "endDate" | "gracePeriodHours" | "isActive" | "automaticTransition", ExtArgs["result"]["electionTimeline"]>

  export type $ElectionTimelinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ElectionTimeline"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      phase: string
      startDate: Date
      endDate: Date
      gracePeriodHours: number
      isActive: boolean
      automaticTransition: boolean
    }, ExtArgs["result"]["electionTimeline"]>
    composites: {}
  }

  type ElectionTimelineGetPayload<S extends boolean | null | undefined | ElectionTimelineDefaultArgs> = $Result.GetResult<Prisma.$ElectionTimelinePayload, S>

  type ElectionTimelineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ElectionTimelineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ElectionTimelineCountAggregateInputType | true
    }

  export interface ElectionTimelineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ElectionTimeline'], meta: { name: 'ElectionTimeline' } }
    /**
     * Find zero or one ElectionTimeline that matches the filter.
     * @param {ElectionTimelineFindUniqueArgs} args - Arguments to find a ElectionTimeline
     * @example
     * // Get one ElectionTimeline
     * const electionTimeline = await prisma.electionTimeline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ElectionTimelineFindUniqueArgs>(args: SelectSubset<T, ElectionTimelineFindUniqueArgs<ExtArgs>>): Prisma__ElectionTimelineClient<$Result.GetResult<Prisma.$ElectionTimelinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ElectionTimeline that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ElectionTimelineFindUniqueOrThrowArgs} args - Arguments to find a ElectionTimeline
     * @example
     * // Get one ElectionTimeline
     * const electionTimeline = await prisma.electionTimeline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ElectionTimelineFindUniqueOrThrowArgs>(args: SelectSubset<T, ElectionTimelineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ElectionTimelineClient<$Result.GetResult<Prisma.$ElectionTimelinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ElectionTimeline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectionTimelineFindFirstArgs} args - Arguments to find a ElectionTimeline
     * @example
     * // Get one ElectionTimeline
     * const electionTimeline = await prisma.electionTimeline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ElectionTimelineFindFirstArgs>(args?: SelectSubset<T, ElectionTimelineFindFirstArgs<ExtArgs>>): Prisma__ElectionTimelineClient<$Result.GetResult<Prisma.$ElectionTimelinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ElectionTimeline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectionTimelineFindFirstOrThrowArgs} args - Arguments to find a ElectionTimeline
     * @example
     * // Get one ElectionTimeline
     * const electionTimeline = await prisma.electionTimeline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ElectionTimelineFindFirstOrThrowArgs>(args?: SelectSubset<T, ElectionTimelineFindFirstOrThrowArgs<ExtArgs>>): Prisma__ElectionTimelineClient<$Result.GetResult<Prisma.$ElectionTimelinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ElectionTimelines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectionTimelineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ElectionTimelines
     * const electionTimelines = await prisma.electionTimeline.findMany()
     * 
     * // Get first 10 ElectionTimelines
     * const electionTimelines = await prisma.electionTimeline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const electionTimelineWithIdOnly = await prisma.electionTimeline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ElectionTimelineFindManyArgs>(args?: SelectSubset<T, ElectionTimelineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElectionTimelinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ElectionTimeline.
     * @param {ElectionTimelineCreateArgs} args - Arguments to create a ElectionTimeline.
     * @example
     * // Create one ElectionTimeline
     * const ElectionTimeline = await prisma.electionTimeline.create({
     *   data: {
     *     // ... data to create a ElectionTimeline
     *   }
     * })
     * 
     */
    create<T extends ElectionTimelineCreateArgs>(args: SelectSubset<T, ElectionTimelineCreateArgs<ExtArgs>>): Prisma__ElectionTimelineClient<$Result.GetResult<Prisma.$ElectionTimelinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ElectionTimelines.
     * @param {ElectionTimelineCreateManyArgs} args - Arguments to create many ElectionTimelines.
     * @example
     * // Create many ElectionTimelines
     * const electionTimeline = await prisma.electionTimeline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ElectionTimelineCreateManyArgs>(args?: SelectSubset<T, ElectionTimelineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ElectionTimelines and returns the data saved in the database.
     * @param {ElectionTimelineCreateManyAndReturnArgs} args - Arguments to create many ElectionTimelines.
     * @example
     * // Create many ElectionTimelines
     * const electionTimeline = await prisma.electionTimeline.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ElectionTimelines and only return the `id`
     * const electionTimelineWithIdOnly = await prisma.electionTimeline.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ElectionTimelineCreateManyAndReturnArgs>(args?: SelectSubset<T, ElectionTimelineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElectionTimelinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ElectionTimeline.
     * @param {ElectionTimelineDeleteArgs} args - Arguments to delete one ElectionTimeline.
     * @example
     * // Delete one ElectionTimeline
     * const ElectionTimeline = await prisma.electionTimeline.delete({
     *   where: {
     *     // ... filter to delete one ElectionTimeline
     *   }
     * })
     * 
     */
    delete<T extends ElectionTimelineDeleteArgs>(args: SelectSubset<T, ElectionTimelineDeleteArgs<ExtArgs>>): Prisma__ElectionTimelineClient<$Result.GetResult<Prisma.$ElectionTimelinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ElectionTimeline.
     * @param {ElectionTimelineUpdateArgs} args - Arguments to update one ElectionTimeline.
     * @example
     * // Update one ElectionTimeline
     * const electionTimeline = await prisma.electionTimeline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ElectionTimelineUpdateArgs>(args: SelectSubset<T, ElectionTimelineUpdateArgs<ExtArgs>>): Prisma__ElectionTimelineClient<$Result.GetResult<Prisma.$ElectionTimelinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ElectionTimelines.
     * @param {ElectionTimelineDeleteManyArgs} args - Arguments to filter ElectionTimelines to delete.
     * @example
     * // Delete a few ElectionTimelines
     * const { count } = await prisma.electionTimeline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ElectionTimelineDeleteManyArgs>(args?: SelectSubset<T, ElectionTimelineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ElectionTimelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectionTimelineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ElectionTimelines
     * const electionTimeline = await prisma.electionTimeline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ElectionTimelineUpdateManyArgs>(args: SelectSubset<T, ElectionTimelineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ElectionTimelines and returns the data updated in the database.
     * @param {ElectionTimelineUpdateManyAndReturnArgs} args - Arguments to update many ElectionTimelines.
     * @example
     * // Update many ElectionTimelines
     * const electionTimeline = await prisma.electionTimeline.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ElectionTimelines and only return the `id`
     * const electionTimelineWithIdOnly = await prisma.electionTimeline.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ElectionTimelineUpdateManyAndReturnArgs>(args: SelectSubset<T, ElectionTimelineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElectionTimelinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ElectionTimeline.
     * @param {ElectionTimelineUpsertArgs} args - Arguments to update or create a ElectionTimeline.
     * @example
     * // Update or create a ElectionTimeline
     * const electionTimeline = await prisma.electionTimeline.upsert({
     *   create: {
     *     // ... data to create a ElectionTimeline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ElectionTimeline we want to update
     *   }
     * })
     */
    upsert<T extends ElectionTimelineUpsertArgs>(args: SelectSubset<T, ElectionTimelineUpsertArgs<ExtArgs>>): Prisma__ElectionTimelineClient<$Result.GetResult<Prisma.$ElectionTimelinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ElectionTimelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectionTimelineCountArgs} args - Arguments to filter ElectionTimelines to count.
     * @example
     * // Count the number of ElectionTimelines
     * const count = await prisma.electionTimeline.count({
     *   where: {
     *     // ... the filter for the ElectionTimelines we want to count
     *   }
     * })
    **/
    count<T extends ElectionTimelineCountArgs>(
      args?: Subset<T, ElectionTimelineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ElectionTimelineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ElectionTimeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectionTimelineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ElectionTimelineAggregateArgs>(args: Subset<T, ElectionTimelineAggregateArgs>): Prisma.PrismaPromise<GetElectionTimelineAggregateType<T>>

    /**
     * Group by ElectionTimeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectionTimelineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ElectionTimelineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ElectionTimelineGroupByArgs['orderBy'] }
        : { orderBy?: ElectionTimelineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ElectionTimelineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetElectionTimelineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ElectionTimeline model
   */
  readonly fields: ElectionTimelineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ElectionTimeline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ElectionTimelineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ElectionTimeline model
   */
  interface ElectionTimelineFieldRefs {
    readonly id: FieldRef<"ElectionTimeline", 'String'>
    readonly createdAt: FieldRef<"ElectionTimeline", 'DateTime'>
    readonly updatedAt: FieldRef<"ElectionTimeline", 'DateTime'>
    readonly phase: FieldRef<"ElectionTimeline", 'String'>
    readonly startDate: FieldRef<"ElectionTimeline", 'DateTime'>
    readonly endDate: FieldRef<"ElectionTimeline", 'DateTime'>
    readonly gracePeriodHours: FieldRef<"ElectionTimeline", 'Int'>
    readonly isActive: FieldRef<"ElectionTimeline", 'Boolean'>
    readonly automaticTransition: FieldRef<"ElectionTimeline", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ElectionTimeline findUnique
   */
  export type ElectionTimelineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionTimeline
     */
    select?: ElectionTimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionTimeline
     */
    omit?: ElectionTimelineOmit<ExtArgs> | null
    /**
     * Filter, which ElectionTimeline to fetch.
     */
    where: ElectionTimelineWhereUniqueInput
  }

  /**
   * ElectionTimeline findUniqueOrThrow
   */
  export type ElectionTimelineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionTimeline
     */
    select?: ElectionTimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionTimeline
     */
    omit?: ElectionTimelineOmit<ExtArgs> | null
    /**
     * Filter, which ElectionTimeline to fetch.
     */
    where: ElectionTimelineWhereUniqueInput
  }

  /**
   * ElectionTimeline findFirst
   */
  export type ElectionTimelineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionTimeline
     */
    select?: ElectionTimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionTimeline
     */
    omit?: ElectionTimelineOmit<ExtArgs> | null
    /**
     * Filter, which ElectionTimeline to fetch.
     */
    where?: ElectionTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElectionTimelines to fetch.
     */
    orderBy?: ElectionTimelineOrderByWithRelationInput | ElectionTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ElectionTimelines.
     */
    cursor?: ElectionTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElectionTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElectionTimelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ElectionTimelines.
     */
    distinct?: ElectionTimelineScalarFieldEnum | ElectionTimelineScalarFieldEnum[]
  }

  /**
   * ElectionTimeline findFirstOrThrow
   */
  export type ElectionTimelineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionTimeline
     */
    select?: ElectionTimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionTimeline
     */
    omit?: ElectionTimelineOmit<ExtArgs> | null
    /**
     * Filter, which ElectionTimeline to fetch.
     */
    where?: ElectionTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElectionTimelines to fetch.
     */
    orderBy?: ElectionTimelineOrderByWithRelationInput | ElectionTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ElectionTimelines.
     */
    cursor?: ElectionTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElectionTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElectionTimelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ElectionTimelines.
     */
    distinct?: ElectionTimelineScalarFieldEnum | ElectionTimelineScalarFieldEnum[]
  }

  /**
   * ElectionTimeline findMany
   */
  export type ElectionTimelineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionTimeline
     */
    select?: ElectionTimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionTimeline
     */
    omit?: ElectionTimelineOmit<ExtArgs> | null
    /**
     * Filter, which ElectionTimelines to fetch.
     */
    where?: ElectionTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElectionTimelines to fetch.
     */
    orderBy?: ElectionTimelineOrderByWithRelationInput | ElectionTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ElectionTimelines.
     */
    cursor?: ElectionTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElectionTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElectionTimelines.
     */
    skip?: number
    distinct?: ElectionTimelineScalarFieldEnum | ElectionTimelineScalarFieldEnum[]
  }

  /**
   * ElectionTimeline create
   */
  export type ElectionTimelineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionTimeline
     */
    select?: ElectionTimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionTimeline
     */
    omit?: ElectionTimelineOmit<ExtArgs> | null
    /**
     * The data needed to create a ElectionTimeline.
     */
    data: XOR<ElectionTimelineCreateInput, ElectionTimelineUncheckedCreateInput>
  }

  /**
   * ElectionTimeline createMany
   */
  export type ElectionTimelineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ElectionTimelines.
     */
    data: ElectionTimelineCreateManyInput | ElectionTimelineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ElectionTimeline createManyAndReturn
   */
  export type ElectionTimelineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionTimeline
     */
    select?: ElectionTimelineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionTimeline
     */
    omit?: ElectionTimelineOmit<ExtArgs> | null
    /**
     * The data used to create many ElectionTimelines.
     */
    data: ElectionTimelineCreateManyInput | ElectionTimelineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ElectionTimeline update
   */
  export type ElectionTimelineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionTimeline
     */
    select?: ElectionTimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionTimeline
     */
    omit?: ElectionTimelineOmit<ExtArgs> | null
    /**
     * The data needed to update a ElectionTimeline.
     */
    data: XOR<ElectionTimelineUpdateInput, ElectionTimelineUncheckedUpdateInput>
    /**
     * Choose, which ElectionTimeline to update.
     */
    where: ElectionTimelineWhereUniqueInput
  }

  /**
   * ElectionTimeline updateMany
   */
  export type ElectionTimelineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ElectionTimelines.
     */
    data: XOR<ElectionTimelineUpdateManyMutationInput, ElectionTimelineUncheckedUpdateManyInput>
    /**
     * Filter which ElectionTimelines to update
     */
    where?: ElectionTimelineWhereInput
    /**
     * Limit how many ElectionTimelines to update.
     */
    limit?: number
  }

  /**
   * ElectionTimeline updateManyAndReturn
   */
  export type ElectionTimelineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionTimeline
     */
    select?: ElectionTimelineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionTimeline
     */
    omit?: ElectionTimelineOmit<ExtArgs> | null
    /**
     * The data used to update ElectionTimelines.
     */
    data: XOR<ElectionTimelineUpdateManyMutationInput, ElectionTimelineUncheckedUpdateManyInput>
    /**
     * Filter which ElectionTimelines to update
     */
    where?: ElectionTimelineWhereInput
    /**
     * Limit how many ElectionTimelines to update.
     */
    limit?: number
  }

  /**
   * ElectionTimeline upsert
   */
  export type ElectionTimelineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionTimeline
     */
    select?: ElectionTimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionTimeline
     */
    omit?: ElectionTimelineOmit<ExtArgs> | null
    /**
     * The filter to search for the ElectionTimeline to update in case it exists.
     */
    where: ElectionTimelineWhereUniqueInput
    /**
     * In case the ElectionTimeline found by the `where` argument doesn't exist, create a new ElectionTimeline with this data.
     */
    create: XOR<ElectionTimelineCreateInput, ElectionTimelineUncheckedCreateInput>
    /**
     * In case the ElectionTimeline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ElectionTimelineUpdateInput, ElectionTimelineUncheckedUpdateInput>
  }

  /**
   * ElectionTimeline delete
   */
  export type ElectionTimelineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionTimeline
     */
    select?: ElectionTimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionTimeline
     */
    omit?: ElectionTimelineOmit<ExtArgs> | null
    /**
     * Filter which ElectionTimeline to delete.
     */
    where: ElectionTimelineWhereUniqueInput
  }

  /**
   * ElectionTimeline deleteMany
   */
  export type ElectionTimelineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ElectionTimelines to delete
     */
    where?: ElectionTimelineWhereInput
    /**
     * Limit how many ElectionTimelines to delete.
     */
    limit?: number
  }

  /**
   * ElectionTimeline without action
   */
  export type ElectionTimelineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionTimeline
     */
    select?: ElectionTimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionTimeline
     */
    omit?: ElectionTimelineOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    password: 'password',
    role: 'role',
    programme: 'programme',
    level: 'level',
    subgroup: 'subgroup',
    college: 'college',
    phoneVerified: 'phoneVerified',
    emailVerified: 'emailVerified',
    isActive: 'isActive',
    hasVoted: 'hasVoted',
    inkVerified: 'inkVerified',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    subgroupId: 'subgroupId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const NominationScalarFieldEnum: {
    id: 'id',
    aspirantId: 'aspirantId',
    nomineeName: 'nomineeName',
    nomineeEmail: 'nomineeEmail',
    nomineeContact: 'nomineeContact',
    nomineePosition: 'nomineePosition',
    photoUrl: 'photoUrl',
    photoPublicId: 'photoPublicId',
    status: 'status',
    nomineeCollege: 'nomineeCollege',
    nomineeDepartment: 'nomineeDepartment',
    nomineeDateOfBirth: 'nomineeDateOfBirth',
    nomineeHostel: 'nomineeHostel',
    nomineeRoom: 'nomineeRoom',
    nomineeSex: 'nomineeSex',
    nomineeCwa: 'nomineeCwa',
    nomineeProgramme: 'nomineeProgramme',
    nomineeLevel: 'nomineeLevel',
    nomineeParish: 'nomineeParish',
    nomineeNationality: 'nomineeNationality',
    nomineeRegion: 'nomineeRegion',
    nomineeSubgroups: 'nomineeSubgroups',
    nomineeEducation: 'nomineeEducation',
    hasLeadershipPosition: 'hasLeadershipPosition',
    leadershipPositions: 'leadershipPositions',
    hasServedCommittee: 'hasServedCommittee',
    committees: 'committees',
    skills: 'skills',
    visionForOffice: 'visionForOffice',
    knowledgeAboutOffice: 'knowledgeAboutOffice',
    approvalCount: 'approvalCount',
    rejectionCount: 'rejectionCount',
    reviewedAt: 'reviewedAt',
    rejectionReason: 'rejectionReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    subgroupId: 'subgroupId'
  };

  export type NominationScalarFieldEnum = (typeof NominationScalarFieldEnum)[keyof typeof NominationScalarFieldEnum]


  export const NominatorVerificationScalarFieldEnum: {
    id: 'id',
    nominationId: 'nominationId',
    name: 'name',
    email: 'email',
    contact: 'contact',
    programme: 'programme',
    level: 'level',
    subgroup: 'subgroup',
    status: 'status',
    comments: 'comments',
    verifiedAt: 'verifiedAt',
    declinedAt: 'declinedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type NominatorVerificationScalarFieldEnum = (typeof NominatorVerificationScalarFieldEnum)[keyof typeof NominatorVerificationScalarFieldEnum]


  export const GuarantorVerificationScalarFieldEnum: {
    id: 'id',
    nominationId: 'nominationId',
    name: 'name',
    email: 'email',
    contact: 'contact',
    programme: 'programme',
    subgroup: 'subgroup',
    status: 'status',
    comments: 'comments',
    verifiedAt: 'verifiedAt',
    declinedAt: 'declinedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    verificationTokenId: 'verificationTokenId',
    userId: 'userId'
  };

  export type GuarantorVerificationScalarFieldEnum = (typeof GuarantorVerificationScalarFieldEnum)[keyof typeof GuarantorVerificationScalarFieldEnum]


  export const EcReviewScalarFieldEnum: {
    id: 'id',
    nominationId: 'nominationId',
    reviewerId: 'reviewerId',
    approved: 'approved',
    comments: 'comments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type EcReviewScalarFieldEnum = (typeof EcReviewScalarFieldEnum)[keyof typeof EcReviewScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    type: 'type',
    email: 'email',
    phone: 'phone',
    expiresAt: 'expiresAt',
    used: 'used',
    createdAt: 'createdAt',
    nominatorVerificationId: 'nominatorVerificationId',
    guarantorVerificationId: 'guarantorVerificationId'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const CandidateScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    position: 'position',
    photoUrl: 'photoUrl',
    photoPublicId: 'photoPublicId',
    biography: 'biography',
    displayOrder: 'displayOrder',
    isActive: 'isActive',
    candidateNumber: 'candidateNumber',
    nominationId: 'nominationId',
    voteCount: 'voteCount'
  };

  export type CandidateScalarFieldEnum = (typeof CandidateScalarFieldEnum)[keyof typeof CandidateScalarFieldEnum]


  export const VotingSessionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sessionId: 'sessionId',
    voterHash: 'voterHash',
    deviceFingerprint: 'deviceFingerprint',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    status: 'status',
    startTime: 'startTime',
    endTime: 'endTime',
    expiresAt: 'expiresAt',
    isValid: 'isValid',
    userId: 'userId'
  };

  export type VotingSessionScalarFieldEnum = (typeof VotingSessionScalarFieldEnum)[keyof typeof VotingSessionScalarFieldEnum]


  export const VoteScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    encryptedVote: 'encryptedVote',
    voterHash: 'voterHash',
    submissionTime: 'submissionTime',
    deviceFingerprint: 'deviceFingerprint',
    ipAddress: 'ipAddress',
    isValid: 'isValid',
    sessionId: 'sessionId'
  };

  export type VoteScalarFieldEnum = (typeof VoteScalarFieldEnum)[keyof typeof VoteScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    oldValues: 'oldValues',
    newValues: 'newValues',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SubgroupScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    description: 'description',
    isActive: 'isActive'
  };

  export type SubgroupScalarFieldEnum = (typeof SubgroupScalarFieldEnum)[keyof typeof SubgroupScalarFieldEnum]


  export const ProgrammeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    college: 'college',
    duration: 'duration',
    isActive: 'isActive'
  };

  export type ProgrammeScalarFieldEnum = (typeof ProgrammeScalarFieldEnum)[keyof typeof ProgrammeScalarFieldEnum]


  export const SystemConfigScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    key: 'key',
    value: 'value',
    type: 'type'
  };

  export type SystemConfigScalarFieldEnum = (typeof SystemConfigScalarFieldEnum)[keyof typeof SystemConfigScalarFieldEnum]


  export const ElectionTimelineScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    phase: 'phase',
    startDate: 'startDate',
    endDate: 'endDate',
    gracePeriodHours: 'gracePeriodHours',
    isActive: 'isActive',
    automaticTransition: 'automaticTransition'
  };

  export type ElectionTimelineScalarFieldEnum = (typeof ElectionTimelineScalarFieldEnum)[keyof typeof ElectionTimelineScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Candidate_Position'
   */
  export type EnumCandidate_PositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Candidate_Position'>
    


  /**
   * Reference to a field of type 'Candidate_Position[]'
   */
  export type ListEnumCandidate_PositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Candidate_Position[]'>
    


  /**
   * Reference to a field of type 'NominationStatus'
   */
  export type EnumNominationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NominationStatus'>
    


  /**
   * Reference to a field of type 'NominationStatus[]'
   */
  export type ListEnumNominationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NominationStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'TokenType'
   */
  export type EnumTokenTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TokenType'>
    


  /**
   * Reference to a field of type 'TokenType[]'
   */
  export type ListEnumTokenTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TokenType[]'>
    


  /**
   * Reference to a field of type 'VotingStatus'
   */
  export type EnumVotingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VotingStatus'>
    


  /**
   * Reference to a field of type 'VotingStatus[]'
   */
  export type ListEnumVotingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VotingStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    programme?: StringNullableFilter<"User"> | string | null
    level?: StringNullableFilter<"User"> | string | null
    subgroup?: StringNullableFilter<"User"> | string | null
    college?: StringNullableFilter<"User"> | string | null
    phoneVerified?: BoolFilter<"User"> | boolean
    emailVerified?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    hasVoted?: BoolFilter<"User"> | boolean
    inkVerified?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    subgroupId?: StringNullableFilter<"User"> | string | null
    nominations?: NominationListRelationFilter
    ecReviews?: EcReviewListRelationFilter
    Nomination?: NominationListRelationFilter
    NominatorVerification?: NominatorVerificationListRelationFilter
    GuarantorVerification?: GuarantorVerificationListRelationFilter
    EcReview?: EcReviewListRelationFilter
    VotingSession?: VotingSessionListRelationFilter
    AuditLog?: AuditLogListRelationFilter
    Subgroup?: XOR<SubgroupNullableScalarRelationFilter, SubgroupWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    programme?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    subgroup?: SortOrderInput | SortOrder
    college?: SortOrderInput | SortOrder
    phoneVerified?: SortOrder
    emailVerified?: SortOrder
    isActive?: SortOrder
    hasVoted?: SortOrder
    inkVerified?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subgroupId?: SortOrderInput | SortOrder
    nominations?: NominationOrderByRelationAggregateInput
    ecReviews?: EcReviewOrderByRelationAggregateInput
    Nomination?: NominationOrderByRelationAggregateInput
    NominatorVerification?: NominatorVerificationOrderByRelationAggregateInput
    GuarantorVerification?: GuarantorVerificationOrderByRelationAggregateInput
    EcReview?: EcReviewOrderByRelationAggregateInput
    VotingSession?: VotingSessionOrderByRelationAggregateInput
    AuditLog?: AuditLogOrderByRelationAggregateInput
    Subgroup?: SubgroupOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    programme?: StringNullableFilter<"User"> | string | null
    level?: StringNullableFilter<"User"> | string | null
    subgroup?: StringNullableFilter<"User"> | string | null
    college?: StringNullableFilter<"User"> | string | null
    phoneVerified?: BoolFilter<"User"> | boolean
    emailVerified?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    hasVoted?: BoolFilter<"User"> | boolean
    inkVerified?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    subgroupId?: StringNullableFilter<"User"> | string | null
    nominations?: NominationListRelationFilter
    ecReviews?: EcReviewListRelationFilter
    Nomination?: NominationListRelationFilter
    NominatorVerification?: NominatorVerificationListRelationFilter
    GuarantorVerification?: GuarantorVerificationListRelationFilter
    EcReview?: EcReviewListRelationFilter
    VotingSession?: VotingSessionListRelationFilter
    AuditLog?: AuditLogListRelationFilter
    Subgroup?: XOR<SubgroupNullableScalarRelationFilter, SubgroupWhereInput> | null
  }, "id" | "email" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    programme?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    subgroup?: SortOrderInput | SortOrder
    college?: SortOrderInput | SortOrder
    phoneVerified?: SortOrder
    emailVerified?: SortOrder
    isActive?: SortOrder
    hasVoted?: SortOrder
    inkVerified?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subgroupId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    programme?: StringNullableWithAggregatesFilter<"User"> | string | null
    level?: StringNullableWithAggregatesFilter<"User"> | string | null
    subgroup?: StringNullableWithAggregatesFilter<"User"> | string | null
    college?: StringNullableWithAggregatesFilter<"User"> | string | null
    phoneVerified?: BoolWithAggregatesFilter<"User"> | boolean
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    hasVoted?: BoolWithAggregatesFilter<"User"> | boolean
    inkVerified?: BoolWithAggregatesFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    subgroupId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type NominationWhereInput = {
    AND?: NominationWhereInput | NominationWhereInput[]
    OR?: NominationWhereInput[]
    NOT?: NominationWhereInput | NominationWhereInput[]
    id?: StringFilter<"Nomination"> | string
    aspirantId?: StringFilter<"Nomination"> | string
    nomineeName?: StringFilter<"Nomination"> | string
    nomineeEmail?: StringFilter<"Nomination"> | string
    nomineeContact?: StringFilter<"Nomination"> | string
    nomineePosition?: EnumCandidate_PositionFilter<"Nomination"> | $Enums.Candidate_Position
    photoUrl?: StringNullableFilter<"Nomination"> | string | null
    photoPublicId?: StringNullableFilter<"Nomination"> | string | null
    status?: EnumNominationStatusFilter<"Nomination"> | $Enums.NominationStatus
    nomineeCollege?: StringFilter<"Nomination"> | string
    nomineeDepartment?: StringFilter<"Nomination"> | string
    nomineeDateOfBirth?: DateTimeFilter<"Nomination"> | Date | string
    nomineeHostel?: StringFilter<"Nomination"> | string
    nomineeRoom?: StringFilter<"Nomination"> | string
    nomineeSex?: StringFilter<"Nomination"> | string
    nomineeCwa?: StringFilter<"Nomination"> | string
    nomineeProgramme?: StringFilter<"Nomination"> | string
    nomineeLevel?: StringFilter<"Nomination"> | string
    nomineeParish?: StringFilter<"Nomination"> | string
    nomineeNationality?: StringFilter<"Nomination"> | string
    nomineeRegion?: StringFilter<"Nomination"> | string
    nomineeSubgroups?: StringNullableListFilter<"Nomination">
    nomineeEducation?: StringNullableListFilter<"Nomination">
    hasLeadershipPosition?: BoolFilter<"Nomination"> | boolean
    leadershipPositions?: StringNullableListFilter<"Nomination">
    hasServedCommittee?: BoolFilter<"Nomination"> | boolean
    committees?: StringNullableListFilter<"Nomination">
    skills?: StringNullableListFilter<"Nomination">
    visionForOffice?: StringNullableListFilter<"Nomination">
    knowledgeAboutOffice?: StringNullableListFilter<"Nomination">
    approvalCount?: IntFilter<"Nomination"> | number
    rejectionCount?: IntFilter<"Nomination"> | number
    reviewedAt?: DateTimeNullableFilter<"Nomination"> | Date | string | null
    rejectionReason?: StringNullableFilter<"Nomination"> | string | null
    createdAt?: DateTimeFilter<"Nomination"> | Date | string
    updatedAt?: DateTimeFilter<"Nomination"> | Date | string
    userId?: StringNullableFilter<"Nomination"> | string | null
    subgroupId?: StringNullableFilter<"Nomination"> | string | null
    aspirant?: XOR<UserScalarRelationFilter, UserWhereInput>
    nominatorVerification?: XOR<NominatorVerificationNullableScalarRelationFilter, NominatorVerificationWhereInput> | null
    guarantorVerifications?: GuarantorVerificationListRelationFilter
    EcReview?: EcReviewListRelationFilter
    candidate?: XOR<CandidateNullableScalarRelationFilter, CandidateWhereInput> | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Subgroup?: XOR<SubgroupNullableScalarRelationFilter, SubgroupWhereInput> | null
  }

  export type NominationOrderByWithRelationInput = {
    id?: SortOrder
    aspirantId?: SortOrder
    nomineeName?: SortOrder
    nomineeEmail?: SortOrder
    nomineeContact?: SortOrder
    nomineePosition?: SortOrder
    photoUrl?: SortOrderInput | SortOrder
    photoPublicId?: SortOrderInput | SortOrder
    status?: SortOrder
    nomineeCollege?: SortOrder
    nomineeDepartment?: SortOrder
    nomineeDateOfBirth?: SortOrder
    nomineeHostel?: SortOrder
    nomineeRoom?: SortOrder
    nomineeSex?: SortOrder
    nomineeCwa?: SortOrder
    nomineeProgramme?: SortOrder
    nomineeLevel?: SortOrder
    nomineeParish?: SortOrder
    nomineeNationality?: SortOrder
    nomineeRegion?: SortOrder
    nomineeSubgroups?: SortOrder
    nomineeEducation?: SortOrder
    hasLeadershipPosition?: SortOrder
    leadershipPositions?: SortOrder
    hasServedCommittee?: SortOrder
    committees?: SortOrder
    skills?: SortOrder
    visionForOffice?: SortOrder
    knowledgeAboutOffice?: SortOrder
    approvalCount?: SortOrder
    rejectionCount?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    subgroupId?: SortOrderInput | SortOrder
    aspirant?: UserOrderByWithRelationInput
    nominatorVerification?: NominatorVerificationOrderByWithRelationInput
    guarantorVerifications?: GuarantorVerificationOrderByRelationAggregateInput
    EcReview?: EcReviewOrderByRelationAggregateInput
    candidate?: CandidateOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    Subgroup?: SubgroupOrderByWithRelationInput
  }

  export type NominationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NominationWhereInput | NominationWhereInput[]
    OR?: NominationWhereInput[]
    NOT?: NominationWhereInput | NominationWhereInput[]
    aspirantId?: StringFilter<"Nomination"> | string
    nomineeName?: StringFilter<"Nomination"> | string
    nomineeEmail?: StringFilter<"Nomination"> | string
    nomineeContact?: StringFilter<"Nomination"> | string
    nomineePosition?: EnumCandidate_PositionFilter<"Nomination"> | $Enums.Candidate_Position
    photoUrl?: StringNullableFilter<"Nomination"> | string | null
    photoPublicId?: StringNullableFilter<"Nomination"> | string | null
    status?: EnumNominationStatusFilter<"Nomination"> | $Enums.NominationStatus
    nomineeCollege?: StringFilter<"Nomination"> | string
    nomineeDepartment?: StringFilter<"Nomination"> | string
    nomineeDateOfBirth?: DateTimeFilter<"Nomination"> | Date | string
    nomineeHostel?: StringFilter<"Nomination"> | string
    nomineeRoom?: StringFilter<"Nomination"> | string
    nomineeSex?: StringFilter<"Nomination"> | string
    nomineeCwa?: StringFilter<"Nomination"> | string
    nomineeProgramme?: StringFilter<"Nomination"> | string
    nomineeLevel?: StringFilter<"Nomination"> | string
    nomineeParish?: StringFilter<"Nomination"> | string
    nomineeNationality?: StringFilter<"Nomination"> | string
    nomineeRegion?: StringFilter<"Nomination"> | string
    nomineeSubgroups?: StringNullableListFilter<"Nomination">
    nomineeEducation?: StringNullableListFilter<"Nomination">
    hasLeadershipPosition?: BoolFilter<"Nomination"> | boolean
    leadershipPositions?: StringNullableListFilter<"Nomination">
    hasServedCommittee?: BoolFilter<"Nomination"> | boolean
    committees?: StringNullableListFilter<"Nomination">
    skills?: StringNullableListFilter<"Nomination">
    visionForOffice?: StringNullableListFilter<"Nomination">
    knowledgeAboutOffice?: StringNullableListFilter<"Nomination">
    approvalCount?: IntFilter<"Nomination"> | number
    rejectionCount?: IntFilter<"Nomination"> | number
    reviewedAt?: DateTimeNullableFilter<"Nomination"> | Date | string | null
    rejectionReason?: StringNullableFilter<"Nomination"> | string | null
    createdAt?: DateTimeFilter<"Nomination"> | Date | string
    updatedAt?: DateTimeFilter<"Nomination"> | Date | string
    userId?: StringNullableFilter<"Nomination"> | string | null
    subgroupId?: StringNullableFilter<"Nomination"> | string | null
    aspirant?: XOR<UserScalarRelationFilter, UserWhereInput>
    nominatorVerification?: XOR<NominatorVerificationNullableScalarRelationFilter, NominatorVerificationWhereInput> | null
    guarantorVerifications?: GuarantorVerificationListRelationFilter
    EcReview?: EcReviewListRelationFilter
    candidate?: XOR<CandidateNullableScalarRelationFilter, CandidateWhereInput> | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Subgroup?: XOR<SubgroupNullableScalarRelationFilter, SubgroupWhereInput> | null
  }, "id">

  export type NominationOrderByWithAggregationInput = {
    id?: SortOrder
    aspirantId?: SortOrder
    nomineeName?: SortOrder
    nomineeEmail?: SortOrder
    nomineeContact?: SortOrder
    nomineePosition?: SortOrder
    photoUrl?: SortOrderInput | SortOrder
    photoPublicId?: SortOrderInput | SortOrder
    status?: SortOrder
    nomineeCollege?: SortOrder
    nomineeDepartment?: SortOrder
    nomineeDateOfBirth?: SortOrder
    nomineeHostel?: SortOrder
    nomineeRoom?: SortOrder
    nomineeSex?: SortOrder
    nomineeCwa?: SortOrder
    nomineeProgramme?: SortOrder
    nomineeLevel?: SortOrder
    nomineeParish?: SortOrder
    nomineeNationality?: SortOrder
    nomineeRegion?: SortOrder
    nomineeSubgroups?: SortOrder
    nomineeEducation?: SortOrder
    hasLeadershipPosition?: SortOrder
    leadershipPositions?: SortOrder
    hasServedCommittee?: SortOrder
    committees?: SortOrder
    skills?: SortOrder
    visionForOffice?: SortOrder
    knowledgeAboutOffice?: SortOrder
    approvalCount?: SortOrder
    rejectionCount?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    subgroupId?: SortOrderInput | SortOrder
    _count?: NominationCountOrderByAggregateInput
    _avg?: NominationAvgOrderByAggregateInput
    _max?: NominationMaxOrderByAggregateInput
    _min?: NominationMinOrderByAggregateInput
    _sum?: NominationSumOrderByAggregateInput
  }

  export type NominationScalarWhereWithAggregatesInput = {
    AND?: NominationScalarWhereWithAggregatesInput | NominationScalarWhereWithAggregatesInput[]
    OR?: NominationScalarWhereWithAggregatesInput[]
    NOT?: NominationScalarWhereWithAggregatesInput | NominationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Nomination"> | string
    aspirantId?: StringWithAggregatesFilter<"Nomination"> | string
    nomineeName?: StringWithAggregatesFilter<"Nomination"> | string
    nomineeEmail?: StringWithAggregatesFilter<"Nomination"> | string
    nomineeContact?: StringWithAggregatesFilter<"Nomination"> | string
    nomineePosition?: EnumCandidate_PositionWithAggregatesFilter<"Nomination"> | $Enums.Candidate_Position
    photoUrl?: StringNullableWithAggregatesFilter<"Nomination"> | string | null
    photoPublicId?: StringNullableWithAggregatesFilter<"Nomination"> | string | null
    status?: EnumNominationStatusWithAggregatesFilter<"Nomination"> | $Enums.NominationStatus
    nomineeCollege?: StringWithAggregatesFilter<"Nomination"> | string
    nomineeDepartment?: StringWithAggregatesFilter<"Nomination"> | string
    nomineeDateOfBirth?: DateTimeWithAggregatesFilter<"Nomination"> | Date | string
    nomineeHostel?: StringWithAggregatesFilter<"Nomination"> | string
    nomineeRoom?: StringWithAggregatesFilter<"Nomination"> | string
    nomineeSex?: StringWithAggregatesFilter<"Nomination"> | string
    nomineeCwa?: StringWithAggregatesFilter<"Nomination"> | string
    nomineeProgramme?: StringWithAggregatesFilter<"Nomination"> | string
    nomineeLevel?: StringWithAggregatesFilter<"Nomination"> | string
    nomineeParish?: StringWithAggregatesFilter<"Nomination"> | string
    nomineeNationality?: StringWithAggregatesFilter<"Nomination"> | string
    nomineeRegion?: StringWithAggregatesFilter<"Nomination"> | string
    nomineeSubgroups?: StringNullableListFilter<"Nomination">
    nomineeEducation?: StringNullableListFilter<"Nomination">
    hasLeadershipPosition?: BoolWithAggregatesFilter<"Nomination"> | boolean
    leadershipPositions?: StringNullableListFilter<"Nomination">
    hasServedCommittee?: BoolWithAggregatesFilter<"Nomination"> | boolean
    committees?: StringNullableListFilter<"Nomination">
    skills?: StringNullableListFilter<"Nomination">
    visionForOffice?: StringNullableListFilter<"Nomination">
    knowledgeAboutOffice?: StringNullableListFilter<"Nomination">
    approvalCount?: IntWithAggregatesFilter<"Nomination"> | number
    rejectionCount?: IntWithAggregatesFilter<"Nomination"> | number
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"Nomination"> | Date | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"Nomination"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Nomination"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Nomination"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"Nomination"> | string | null
    subgroupId?: StringNullableWithAggregatesFilter<"Nomination"> | string | null
  }

  export type NominatorVerificationWhereInput = {
    AND?: NominatorVerificationWhereInput | NominatorVerificationWhereInput[]
    OR?: NominatorVerificationWhereInput[]
    NOT?: NominatorVerificationWhereInput | NominatorVerificationWhereInput[]
    id?: StringFilter<"NominatorVerification"> | string
    nominationId?: StringFilter<"NominatorVerification"> | string
    name?: StringFilter<"NominatorVerification"> | string
    email?: StringFilter<"NominatorVerification"> | string
    contact?: StringFilter<"NominatorVerification"> | string
    programme?: StringFilter<"NominatorVerification"> | string
    level?: StringFilter<"NominatorVerification"> | string
    subgroup?: StringFilter<"NominatorVerification"> | string
    status?: StringFilter<"NominatorVerification"> | string
    comments?: StringNullableFilter<"NominatorVerification"> | string | null
    verifiedAt?: DateTimeNullableFilter<"NominatorVerification"> | Date | string | null
    declinedAt?: DateTimeNullableFilter<"NominatorVerification"> | Date | string | null
    createdAt?: DateTimeFilter<"NominatorVerification"> | Date | string
    updatedAt?: DateTimeFilter<"NominatorVerification"> | Date | string
    userId?: StringNullableFilter<"NominatorVerification"> | string | null
    nomination?: XOR<NominationScalarRelationFilter, NominationWhereInput>
    verificationToken?: XOR<VerificationTokenNullableScalarRelationFilter, VerificationTokenWhereInput> | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type NominatorVerificationOrderByWithRelationInput = {
    id?: SortOrder
    nominationId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    contact?: SortOrder
    programme?: SortOrder
    level?: SortOrder
    subgroup?: SortOrder
    status?: SortOrder
    comments?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    declinedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    nomination?: NominationOrderByWithRelationInput
    verificationToken?: VerificationTokenOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type NominatorVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nominationId?: string
    AND?: NominatorVerificationWhereInput | NominatorVerificationWhereInput[]
    OR?: NominatorVerificationWhereInput[]
    NOT?: NominatorVerificationWhereInput | NominatorVerificationWhereInput[]
    name?: StringFilter<"NominatorVerification"> | string
    email?: StringFilter<"NominatorVerification"> | string
    contact?: StringFilter<"NominatorVerification"> | string
    programme?: StringFilter<"NominatorVerification"> | string
    level?: StringFilter<"NominatorVerification"> | string
    subgroup?: StringFilter<"NominatorVerification"> | string
    status?: StringFilter<"NominatorVerification"> | string
    comments?: StringNullableFilter<"NominatorVerification"> | string | null
    verifiedAt?: DateTimeNullableFilter<"NominatorVerification"> | Date | string | null
    declinedAt?: DateTimeNullableFilter<"NominatorVerification"> | Date | string | null
    createdAt?: DateTimeFilter<"NominatorVerification"> | Date | string
    updatedAt?: DateTimeFilter<"NominatorVerification"> | Date | string
    userId?: StringNullableFilter<"NominatorVerification"> | string | null
    nomination?: XOR<NominationScalarRelationFilter, NominationWhereInput>
    verificationToken?: XOR<VerificationTokenNullableScalarRelationFilter, VerificationTokenWhereInput> | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "nominationId">

  export type NominatorVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    nominationId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    contact?: SortOrder
    programme?: SortOrder
    level?: SortOrder
    subgroup?: SortOrder
    status?: SortOrder
    comments?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    declinedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: NominatorVerificationCountOrderByAggregateInput
    _max?: NominatorVerificationMaxOrderByAggregateInput
    _min?: NominatorVerificationMinOrderByAggregateInput
  }

  export type NominatorVerificationScalarWhereWithAggregatesInput = {
    AND?: NominatorVerificationScalarWhereWithAggregatesInput | NominatorVerificationScalarWhereWithAggregatesInput[]
    OR?: NominatorVerificationScalarWhereWithAggregatesInput[]
    NOT?: NominatorVerificationScalarWhereWithAggregatesInput | NominatorVerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NominatorVerification"> | string
    nominationId?: StringWithAggregatesFilter<"NominatorVerification"> | string
    name?: StringWithAggregatesFilter<"NominatorVerification"> | string
    email?: StringWithAggregatesFilter<"NominatorVerification"> | string
    contact?: StringWithAggregatesFilter<"NominatorVerification"> | string
    programme?: StringWithAggregatesFilter<"NominatorVerification"> | string
    level?: StringWithAggregatesFilter<"NominatorVerification"> | string
    subgroup?: StringWithAggregatesFilter<"NominatorVerification"> | string
    status?: StringWithAggregatesFilter<"NominatorVerification"> | string
    comments?: StringNullableWithAggregatesFilter<"NominatorVerification"> | string | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"NominatorVerification"> | Date | string | null
    declinedAt?: DateTimeNullableWithAggregatesFilter<"NominatorVerification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NominatorVerification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NominatorVerification"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"NominatorVerification"> | string | null
  }

  export type GuarantorVerificationWhereInput = {
    AND?: GuarantorVerificationWhereInput | GuarantorVerificationWhereInput[]
    OR?: GuarantorVerificationWhereInput[]
    NOT?: GuarantorVerificationWhereInput | GuarantorVerificationWhereInput[]
    id?: StringFilter<"GuarantorVerification"> | string
    nominationId?: StringFilter<"GuarantorVerification"> | string
    name?: StringFilter<"GuarantorVerification"> | string
    email?: StringFilter<"GuarantorVerification"> | string
    contact?: StringFilter<"GuarantorVerification"> | string
    programme?: StringFilter<"GuarantorVerification"> | string
    subgroup?: StringFilter<"GuarantorVerification"> | string
    status?: StringFilter<"GuarantorVerification"> | string
    comments?: StringNullableFilter<"GuarantorVerification"> | string | null
    verifiedAt?: DateTimeNullableFilter<"GuarantorVerification"> | Date | string | null
    declinedAt?: DateTimeNullableFilter<"GuarantorVerification"> | Date | string | null
    createdAt?: DateTimeFilter<"GuarantorVerification"> | Date | string
    updatedAt?: DateTimeFilter<"GuarantorVerification"> | Date | string
    verificationTokenId?: StringNullableFilter<"GuarantorVerification"> | string | null
    userId?: StringNullableFilter<"GuarantorVerification"> | string | null
    nomination?: XOR<NominationScalarRelationFilter, NominationWhereInput>
    verificationToken?: XOR<VerificationTokenNullableScalarRelationFilter, VerificationTokenWhereInput> | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type GuarantorVerificationOrderByWithRelationInput = {
    id?: SortOrder
    nominationId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    contact?: SortOrder
    programme?: SortOrder
    subgroup?: SortOrder
    status?: SortOrder
    comments?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    declinedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verificationTokenId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    nomination?: NominationOrderByWithRelationInput
    verificationToken?: VerificationTokenOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type GuarantorVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    verificationTokenId?: string
    AND?: GuarantorVerificationWhereInput | GuarantorVerificationWhereInput[]
    OR?: GuarantorVerificationWhereInput[]
    NOT?: GuarantorVerificationWhereInput | GuarantorVerificationWhereInput[]
    nominationId?: StringFilter<"GuarantorVerification"> | string
    name?: StringFilter<"GuarantorVerification"> | string
    email?: StringFilter<"GuarantorVerification"> | string
    contact?: StringFilter<"GuarantorVerification"> | string
    programme?: StringFilter<"GuarantorVerification"> | string
    subgroup?: StringFilter<"GuarantorVerification"> | string
    status?: StringFilter<"GuarantorVerification"> | string
    comments?: StringNullableFilter<"GuarantorVerification"> | string | null
    verifiedAt?: DateTimeNullableFilter<"GuarantorVerification"> | Date | string | null
    declinedAt?: DateTimeNullableFilter<"GuarantorVerification"> | Date | string | null
    createdAt?: DateTimeFilter<"GuarantorVerification"> | Date | string
    updatedAt?: DateTimeFilter<"GuarantorVerification"> | Date | string
    userId?: StringNullableFilter<"GuarantorVerification"> | string | null
    nomination?: XOR<NominationScalarRelationFilter, NominationWhereInput>
    verificationToken?: XOR<VerificationTokenNullableScalarRelationFilter, VerificationTokenWhereInput> | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "verificationTokenId">

  export type GuarantorVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    nominationId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    contact?: SortOrder
    programme?: SortOrder
    subgroup?: SortOrder
    status?: SortOrder
    comments?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    declinedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verificationTokenId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: GuarantorVerificationCountOrderByAggregateInput
    _max?: GuarantorVerificationMaxOrderByAggregateInput
    _min?: GuarantorVerificationMinOrderByAggregateInput
  }

  export type GuarantorVerificationScalarWhereWithAggregatesInput = {
    AND?: GuarantorVerificationScalarWhereWithAggregatesInput | GuarantorVerificationScalarWhereWithAggregatesInput[]
    OR?: GuarantorVerificationScalarWhereWithAggregatesInput[]
    NOT?: GuarantorVerificationScalarWhereWithAggregatesInput | GuarantorVerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GuarantorVerification"> | string
    nominationId?: StringWithAggregatesFilter<"GuarantorVerification"> | string
    name?: StringWithAggregatesFilter<"GuarantorVerification"> | string
    email?: StringWithAggregatesFilter<"GuarantorVerification"> | string
    contact?: StringWithAggregatesFilter<"GuarantorVerification"> | string
    programme?: StringWithAggregatesFilter<"GuarantorVerification"> | string
    subgroup?: StringWithAggregatesFilter<"GuarantorVerification"> | string
    status?: StringWithAggregatesFilter<"GuarantorVerification"> | string
    comments?: StringNullableWithAggregatesFilter<"GuarantorVerification"> | string | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"GuarantorVerification"> | Date | string | null
    declinedAt?: DateTimeNullableWithAggregatesFilter<"GuarantorVerification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GuarantorVerification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GuarantorVerification"> | Date | string
    verificationTokenId?: StringNullableWithAggregatesFilter<"GuarantorVerification"> | string | null
    userId?: StringNullableWithAggregatesFilter<"GuarantorVerification"> | string | null
  }

  export type EcReviewWhereInput = {
    AND?: EcReviewWhereInput | EcReviewWhereInput[]
    OR?: EcReviewWhereInput[]
    NOT?: EcReviewWhereInput | EcReviewWhereInput[]
    id?: StringFilter<"EcReview"> | string
    nominationId?: StringFilter<"EcReview"> | string
    reviewerId?: StringFilter<"EcReview"> | string
    approved?: BoolFilter<"EcReview"> | boolean
    comments?: StringNullableFilter<"EcReview"> | string | null
    createdAt?: DateTimeFilter<"EcReview"> | Date | string
    updatedAt?: DateTimeFilter<"EcReview"> | Date | string
    userId?: StringNullableFilter<"EcReview"> | string | null
    nomination?: XOR<NominationScalarRelationFilter, NominationWhereInput>
    reviewer?: XOR<UserScalarRelationFilter, UserWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type EcReviewOrderByWithRelationInput = {
    id?: SortOrder
    nominationId?: SortOrder
    reviewerId?: SortOrder
    approved?: SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    nomination?: NominationOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type EcReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nominationId_reviewerId?: EcReviewNominationIdReviewerIdCompoundUniqueInput
    AND?: EcReviewWhereInput | EcReviewWhereInput[]
    OR?: EcReviewWhereInput[]
    NOT?: EcReviewWhereInput | EcReviewWhereInput[]
    nominationId?: StringFilter<"EcReview"> | string
    reviewerId?: StringFilter<"EcReview"> | string
    approved?: BoolFilter<"EcReview"> | boolean
    comments?: StringNullableFilter<"EcReview"> | string | null
    createdAt?: DateTimeFilter<"EcReview"> | Date | string
    updatedAt?: DateTimeFilter<"EcReview"> | Date | string
    userId?: StringNullableFilter<"EcReview"> | string | null
    nomination?: XOR<NominationScalarRelationFilter, NominationWhereInput>
    reviewer?: XOR<UserScalarRelationFilter, UserWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "nominationId_reviewerId">

  export type EcReviewOrderByWithAggregationInput = {
    id?: SortOrder
    nominationId?: SortOrder
    reviewerId?: SortOrder
    approved?: SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: EcReviewCountOrderByAggregateInput
    _max?: EcReviewMaxOrderByAggregateInput
    _min?: EcReviewMinOrderByAggregateInput
  }

  export type EcReviewScalarWhereWithAggregatesInput = {
    AND?: EcReviewScalarWhereWithAggregatesInput | EcReviewScalarWhereWithAggregatesInput[]
    OR?: EcReviewScalarWhereWithAggregatesInput[]
    NOT?: EcReviewScalarWhereWithAggregatesInput | EcReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EcReview"> | string
    nominationId?: StringWithAggregatesFilter<"EcReview"> | string
    reviewerId?: StringWithAggregatesFilter<"EcReview"> | string
    approved?: BoolWithAggregatesFilter<"EcReview"> | boolean
    comments?: StringNullableWithAggregatesFilter<"EcReview"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EcReview"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EcReview"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"EcReview"> | string | null
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    id?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    type?: EnumTokenTypeFilter<"VerificationToken"> | $Enums.TokenType
    email?: StringNullableFilter<"VerificationToken"> | string | null
    phone?: StringNullableFilter<"VerificationToken"> | string | null
    expiresAt?: DateTimeFilter<"VerificationToken"> | Date | string
    used?: BoolFilter<"VerificationToken"> | boolean
    createdAt?: DateTimeFilter<"VerificationToken"> | Date | string
    nominatorVerificationId?: StringNullableFilter<"VerificationToken"> | string | null
    guarantorVerificationId?: StringNullableFilter<"VerificationToken"> | string | null
    nominatorVerification?: XOR<NominatorVerificationNullableScalarRelationFilter, NominatorVerificationWhereInput> | null
    guarantorVerification?: XOR<GuarantorVerificationNullableScalarRelationFilter, GuarantorVerificationWhereInput> | null
  }

  export type VerificationTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    nominatorVerificationId?: SortOrderInput | SortOrder
    guarantorVerificationId?: SortOrderInput | SortOrder
    nominatorVerification?: NominatorVerificationOrderByWithRelationInput
    guarantorVerification?: GuarantorVerificationOrderByWithRelationInput
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    nominatorVerificationId?: string
    guarantorVerificationId?: string
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    type?: EnumTokenTypeFilter<"VerificationToken"> | $Enums.TokenType
    email?: StringNullableFilter<"VerificationToken"> | string | null
    phone?: StringNullableFilter<"VerificationToken"> | string | null
    expiresAt?: DateTimeFilter<"VerificationToken"> | Date | string
    used?: BoolFilter<"VerificationToken"> | boolean
    createdAt?: DateTimeFilter<"VerificationToken"> | Date | string
    nominatorVerification?: XOR<NominatorVerificationNullableScalarRelationFilter, NominatorVerificationWhereInput> | null
    guarantorVerification?: XOR<GuarantorVerificationNullableScalarRelationFilter, GuarantorVerificationWhereInput> | null
  }, "id" | "token" | "nominatorVerificationId" | "guarantorVerificationId">

  export type VerificationTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    nominatorVerificationId?: SortOrderInput | SortOrder
    guarantorVerificationId?: SortOrderInput | SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    type?: EnumTokenTypeWithAggregatesFilter<"VerificationToken"> | $Enums.TokenType
    email?: StringNullableWithAggregatesFilter<"VerificationToken"> | string | null
    phone?: StringNullableWithAggregatesFilter<"VerificationToken"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
    used?: BoolWithAggregatesFilter<"VerificationToken"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
    nominatorVerificationId?: StringNullableWithAggregatesFilter<"VerificationToken"> | string | null
    guarantorVerificationId?: StringNullableWithAggregatesFilter<"VerificationToken"> | string | null
  }

  export type CandidateWhereInput = {
    AND?: CandidateWhereInput | CandidateWhereInput[]
    OR?: CandidateWhereInput[]
    NOT?: CandidateWhereInput | CandidateWhereInput[]
    id?: StringFilter<"Candidate"> | string
    createdAt?: DateTimeFilter<"Candidate"> | Date | string
    updatedAt?: DateTimeFilter<"Candidate"> | Date | string
    name?: StringFilter<"Candidate"> | string
    position?: EnumCandidate_PositionFilter<"Candidate"> | $Enums.Candidate_Position
    photoUrl?: StringNullableFilter<"Candidate"> | string | null
    photoPublicId?: StringNullableFilter<"Candidate"> | string | null
    biography?: StringNullableFilter<"Candidate"> | string | null
    displayOrder?: IntFilter<"Candidate"> | number
    isActive?: BoolFilter<"Candidate"> | boolean
    candidateNumber?: IntFilter<"Candidate"> | number
    nominationId?: StringFilter<"Candidate"> | string
    voteCount?: IntFilter<"Candidate"> | number
    nomination?: XOR<NominationScalarRelationFilter, NominationWhereInput>
  }

  export type CandidateOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    position?: SortOrder
    photoUrl?: SortOrderInput | SortOrder
    photoPublicId?: SortOrderInput | SortOrder
    biography?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    candidateNumber?: SortOrder
    nominationId?: SortOrder
    voteCount?: SortOrder
    nomination?: NominationOrderByWithRelationInput
  }

  export type CandidateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    candidateNumber?: number
    nominationId?: string
    AND?: CandidateWhereInput | CandidateWhereInput[]
    OR?: CandidateWhereInput[]
    NOT?: CandidateWhereInput | CandidateWhereInput[]
    createdAt?: DateTimeFilter<"Candidate"> | Date | string
    updatedAt?: DateTimeFilter<"Candidate"> | Date | string
    name?: StringFilter<"Candidate"> | string
    position?: EnumCandidate_PositionFilter<"Candidate"> | $Enums.Candidate_Position
    photoUrl?: StringNullableFilter<"Candidate"> | string | null
    photoPublicId?: StringNullableFilter<"Candidate"> | string | null
    biography?: StringNullableFilter<"Candidate"> | string | null
    displayOrder?: IntFilter<"Candidate"> | number
    isActive?: BoolFilter<"Candidate"> | boolean
    voteCount?: IntFilter<"Candidate"> | number
    nomination?: XOR<NominationScalarRelationFilter, NominationWhereInput>
  }, "id" | "candidateNumber" | "nominationId">

  export type CandidateOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    position?: SortOrder
    photoUrl?: SortOrderInput | SortOrder
    photoPublicId?: SortOrderInput | SortOrder
    biography?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    candidateNumber?: SortOrder
    nominationId?: SortOrder
    voteCount?: SortOrder
    _count?: CandidateCountOrderByAggregateInput
    _avg?: CandidateAvgOrderByAggregateInput
    _max?: CandidateMaxOrderByAggregateInput
    _min?: CandidateMinOrderByAggregateInput
    _sum?: CandidateSumOrderByAggregateInput
  }

  export type CandidateScalarWhereWithAggregatesInput = {
    AND?: CandidateScalarWhereWithAggregatesInput | CandidateScalarWhereWithAggregatesInput[]
    OR?: CandidateScalarWhereWithAggregatesInput[]
    NOT?: CandidateScalarWhereWithAggregatesInput | CandidateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Candidate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Candidate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Candidate"> | Date | string
    name?: StringWithAggregatesFilter<"Candidate"> | string
    position?: EnumCandidate_PositionWithAggregatesFilter<"Candidate"> | $Enums.Candidate_Position
    photoUrl?: StringNullableWithAggregatesFilter<"Candidate"> | string | null
    photoPublicId?: StringNullableWithAggregatesFilter<"Candidate"> | string | null
    biography?: StringNullableWithAggregatesFilter<"Candidate"> | string | null
    displayOrder?: IntWithAggregatesFilter<"Candidate"> | number
    isActive?: BoolWithAggregatesFilter<"Candidate"> | boolean
    candidateNumber?: IntWithAggregatesFilter<"Candidate"> | number
    nominationId?: StringWithAggregatesFilter<"Candidate"> | string
    voteCount?: IntWithAggregatesFilter<"Candidate"> | number
  }

  export type VotingSessionWhereInput = {
    AND?: VotingSessionWhereInput | VotingSessionWhereInput[]
    OR?: VotingSessionWhereInput[]
    NOT?: VotingSessionWhereInput | VotingSessionWhereInput[]
    id?: StringFilter<"VotingSession"> | string
    createdAt?: DateTimeFilter<"VotingSession"> | Date | string
    updatedAt?: DateTimeFilter<"VotingSession"> | Date | string
    sessionId?: StringFilter<"VotingSession"> | string
    voterHash?: StringFilter<"VotingSession"> | string
    deviceFingerprint?: StringNullableFilter<"VotingSession"> | string | null
    ipAddress?: StringNullableFilter<"VotingSession"> | string | null
    userAgent?: StringNullableFilter<"VotingSession"> | string | null
    status?: EnumVotingStatusFilter<"VotingSession"> | $Enums.VotingStatus
    startTime?: DateTimeFilter<"VotingSession"> | Date | string
    endTime?: DateTimeNullableFilter<"VotingSession"> | Date | string | null
    expiresAt?: DateTimeFilter<"VotingSession"> | Date | string
    isValid?: BoolFilter<"VotingSession"> | boolean
    userId?: StringFilter<"VotingSession"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    votes?: VoteListRelationFilter
  }

  export type VotingSessionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessionId?: SortOrder
    voterHash?: SortOrder
    deviceFingerprint?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    isValid?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    votes?: VoteOrderByRelationAggregateInput
  }

  export type VotingSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId?: string
    AND?: VotingSessionWhereInput | VotingSessionWhereInput[]
    OR?: VotingSessionWhereInput[]
    NOT?: VotingSessionWhereInput | VotingSessionWhereInput[]
    createdAt?: DateTimeFilter<"VotingSession"> | Date | string
    updatedAt?: DateTimeFilter<"VotingSession"> | Date | string
    voterHash?: StringFilter<"VotingSession"> | string
    deviceFingerprint?: StringNullableFilter<"VotingSession"> | string | null
    ipAddress?: StringNullableFilter<"VotingSession"> | string | null
    userAgent?: StringNullableFilter<"VotingSession"> | string | null
    status?: EnumVotingStatusFilter<"VotingSession"> | $Enums.VotingStatus
    startTime?: DateTimeFilter<"VotingSession"> | Date | string
    endTime?: DateTimeNullableFilter<"VotingSession"> | Date | string | null
    expiresAt?: DateTimeFilter<"VotingSession"> | Date | string
    isValid?: BoolFilter<"VotingSession"> | boolean
    userId?: StringFilter<"VotingSession"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    votes?: VoteListRelationFilter
  }, "id" | "sessionId">

  export type VotingSessionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessionId?: SortOrder
    voterHash?: SortOrder
    deviceFingerprint?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    isValid?: SortOrder
    userId?: SortOrder
    _count?: VotingSessionCountOrderByAggregateInput
    _max?: VotingSessionMaxOrderByAggregateInput
    _min?: VotingSessionMinOrderByAggregateInput
  }

  export type VotingSessionScalarWhereWithAggregatesInput = {
    AND?: VotingSessionScalarWhereWithAggregatesInput | VotingSessionScalarWhereWithAggregatesInput[]
    OR?: VotingSessionScalarWhereWithAggregatesInput[]
    NOT?: VotingSessionScalarWhereWithAggregatesInput | VotingSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VotingSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VotingSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VotingSession"> | Date | string
    sessionId?: StringWithAggregatesFilter<"VotingSession"> | string
    voterHash?: StringWithAggregatesFilter<"VotingSession"> | string
    deviceFingerprint?: StringNullableWithAggregatesFilter<"VotingSession"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"VotingSession"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"VotingSession"> | string | null
    status?: EnumVotingStatusWithAggregatesFilter<"VotingSession"> | $Enums.VotingStatus
    startTime?: DateTimeWithAggregatesFilter<"VotingSession"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"VotingSession"> | Date | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"VotingSession"> | Date | string
    isValid?: BoolWithAggregatesFilter<"VotingSession"> | boolean
    userId?: StringWithAggregatesFilter<"VotingSession"> | string
  }

  export type VoteWhereInput = {
    AND?: VoteWhereInput | VoteWhereInput[]
    OR?: VoteWhereInput[]
    NOT?: VoteWhereInput | VoteWhereInput[]
    id?: StringFilter<"Vote"> | string
    createdAt?: DateTimeFilter<"Vote"> | Date | string
    encryptedVote?: StringFilter<"Vote"> | string
    voterHash?: StringFilter<"Vote"> | string
    submissionTime?: DateTimeFilter<"Vote"> | Date | string
    deviceFingerprint?: StringNullableFilter<"Vote"> | string | null
    ipAddress?: StringNullableFilter<"Vote"> | string | null
    isValid?: BoolFilter<"Vote"> | boolean
    sessionId?: StringFilter<"Vote"> | string
    session?: XOR<VotingSessionScalarRelationFilter, VotingSessionWhereInput>
  }

  export type VoteOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    encryptedVote?: SortOrder
    voterHash?: SortOrder
    submissionTime?: SortOrder
    deviceFingerprint?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    isValid?: SortOrder
    sessionId?: SortOrder
    session?: VotingSessionOrderByWithRelationInput
  }

  export type VoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VoteWhereInput | VoteWhereInput[]
    OR?: VoteWhereInput[]
    NOT?: VoteWhereInput | VoteWhereInput[]
    createdAt?: DateTimeFilter<"Vote"> | Date | string
    encryptedVote?: StringFilter<"Vote"> | string
    voterHash?: StringFilter<"Vote"> | string
    submissionTime?: DateTimeFilter<"Vote"> | Date | string
    deviceFingerprint?: StringNullableFilter<"Vote"> | string | null
    ipAddress?: StringNullableFilter<"Vote"> | string | null
    isValid?: BoolFilter<"Vote"> | boolean
    sessionId?: StringFilter<"Vote"> | string
    session?: XOR<VotingSessionScalarRelationFilter, VotingSessionWhereInput>
  }, "id">

  export type VoteOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    encryptedVote?: SortOrder
    voterHash?: SortOrder
    submissionTime?: SortOrder
    deviceFingerprint?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    isValid?: SortOrder
    sessionId?: SortOrder
    _count?: VoteCountOrderByAggregateInput
    _max?: VoteMaxOrderByAggregateInput
    _min?: VoteMinOrderByAggregateInput
  }

  export type VoteScalarWhereWithAggregatesInput = {
    AND?: VoteScalarWhereWithAggregatesInput | VoteScalarWhereWithAggregatesInput[]
    OR?: VoteScalarWhereWithAggregatesInput[]
    NOT?: VoteScalarWhereWithAggregatesInput | VoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Vote"> | Date | string
    encryptedVote?: StringWithAggregatesFilter<"Vote"> | string
    voterHash?: StringWithAggregatesFilter<"Vote"> | string
    submissionTime?: DateTimeWithAggregatesFilter<"Vote"> | Date | string
    deviceFingerprint?: StringNullableWithAggregatesFilter<"Vote"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"Vote"> | string | null
    isValid?: BoolWithAggregatesFilter<"Vote"> | boolean
    sessionId?: StringWithAggregatesFilter<"Vote"> | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringNullableFilter<"AuditLog"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrderInput | SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringNullableFilter<"AuditLog"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrderInput | SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    oldValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    newValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
  }

  export type SubgroupWhereInput = {
    AND?: SubgroupWhereInput | SubgroupWhereInput[]
    OR?: SubgroupWhereInput[]
    NOT?: SubgroupWhereInput | SubgroupWhereInput[]
    id?: StringFilter<"Subgroup"> | string
    createdAt?: DateTimeFilter<"Subgroup"> | Date | string
    updatedAt?: DateTimeFilter<"Subgroup"> | Date | string
    name?: StringFilter<"Subgroup"> | string
    description?: StringNullableFilter<"Subgroup"> | string | null
    isActive?: BoolFilter<"Subgroup"> | boolean
    users?: UserListRelationFilter
    nominations?: NominationListRelationFilter
  }

  export type SubgroupOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    users?: UserOrderByRelationAggregateInput
    nominations?: NominationOrderByRelationAggregateInput
  }

  export type SubgroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SubgroupWhereInput | SubgroupWhereInput[]
    OR?: SubgroupWhereInput[]
    NOT?: SubgroupWhereInput | SubgroupWhereInput[]
    createdAt?: DateTimeFilter<"Subgroup"> | Date | string
    updatedAt?: DateTimeFilter<"Subgroup"> | Date | string
    description?: StringNullableFilter<"Subgroup"> | string | null
    isActive?: BoolFilter<"Subgroup"> | boolean
    users?: UserListRelationFilter
    nominations?: NominationListRelationFilter
  }, "id" | "name">

  export type SubgroupOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: SubgroupCountOrderByAggregateInput
    _max?: SubgroupMaxOrderByAggregateInput
    _min?: SubgroupMinOrderByAggregateInput
  }

  export type SubgroupScalarWhereWithAggregatesInput = {
    AND?: SubgroupScalarWhereWithAggregatesInput | SubgroupScalarWhereWithAggregatesInput[]
    OR?: SubgroupScalarWhereWithAggregatesInput[]
    NOT?: SubgroupScalarWhereWithAggregatesInput | SubgroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subgroup"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Subgroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subgroup"> | Date | string
    name?: StringWithAggregatesFilter<"Subgroup"> | string
    description?: StringNullableWithAggregatesFilter<"Subgroup"> | string | null
    isActive?: BoolWithAggregatesFilter<"Subgroup"> | boolean
  }

  export type ProgrammeWhereInput = {
    AND?: ProgrammeWhereInput | ProgrammeWhereInput[]
    OR?: ProgrammeWhereInput[]
    NOT?: ProgrammeWhereInput | ProgrammeWhereInput[]
    id?: StringFilter<"Programme"> | string
    createdAt?: DateTimeFilter<"Programme"> | Date | string
    updatedAt?: DateTimeFilter<"Programme"> | Date | string
    name?: StringFilter<"Programme"> | string
    college?: StringNullableFilter<"Programme"> | string | null
    duration?: IntNullableFilter<"Programme"> | number | null
    isActive?: BoolFilter<"Programme"> | boolean
  }

  export type ProgrammeOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    college?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    isActive?: SortOrder
  }

  export type ProgrammeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ProgrammeWhereInput | ProgrammeWhereInput[]
    OR?: ProgrammeWhereInput[]
    NOT?: ProgrammeWhereInput | ProgrammeWhereInput[]
    createdAt?: DateTimeFilter<"Programme"> | Date | string
    updatedAt?: DateTimeFilter<"Programme"> | Date | string
    college?: StringNullableFilter<"Programme"> | string | null
    duration?: IntNullableFilter<"Programme"> | number | null
    isActive?: BoolFilter<"Programme"> | boolean
  }, "id" | "name">

  export type ProgrammeOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    college?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: ProgrammeCountOrderByAggregateInput
    _avg?: ProgrammeAvgOrderByAggregateInput
    _max?: ProgrammeMaxOrderByAggregateInput
    _min?: ProgrammeMinOrderByAggregateInput
    _sum?: ProgrammeSumOrderByAggregateInput
  }

  export type ProgrammeScalarWhereWithAggregatesInput = {
    AND?: ProgrammeScalarWhereWithAggregatesInput | ProgrammeScalarWhereWithAggregatesInput[]
    OR?: ProgrammeScalarWhereWithAggregatesInput[]
    NOT?: ProgrammeScalarWhereWithAggregatesInput | ProgrammeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Programme"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Programme"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Programme"> | Date | string
    name?: StringWithAggregatesFilter<"Programme"> | string
    college?: StringNullableWithAggregatesFilter<"Programme"> | string | null
    duration?: IntNullableWithAggregatesFilter<"Programme"> | number | null
    isActive?: BoolWithAggregatesFilter<"Programme"> | boolean
  }

  export type SystemConfigWhereInput = {
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    id?: StringFilter<"SystemConfig"> | string
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
    key?: StringFilter<"SystemConfig"> | string
    value?: StringFilter<"SystemConfig"> | string
    type?: StringFilter<"SystemConfig"> | string
  }

  export type SystemConfigOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
  }

  export type SystemConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
    value?: StringFilter<"SystemConfig"> | string
    type?: StringFilter<"SystemConfig"> | string
  }, "id" | "key">

  export type SystemConfigOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    _count?: SystemConfigCountOrderByAggregateInput
    _max?: SystemConfigMaxOrderByAggregateInput
    _min?: SystemConfigMinOrderByAggregateInput
  }

  export type SystemConfigScalarWhereWithAggregatesInput = {
    AND?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    OR?: SystemConfigScalarWhereWithAggregatesInput[]
    NOT?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemConfig"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
    key?: StringWithAggregatesFilter<"SystemConfig"> | string
    value?: StringWithAggregatesFilter<"SystemConfig"> | string
    type?: StringWithAggregatesFilter<"SystemConfig"> | string
  }

  export type ElectionTimelineWhereInput = {
    AND?: ElectionTimelineWhereInput | ElectionTimelineWhereInput[]
    OR?: ElectionTimelineWhereInput[]
    NOT?: ElectionTimelineWhereInput | ElectionTimelineWhereInput[]
    id?: StringFilter<"ElectionTimeline"> | string
    createdAt?: DateTimeFilter<"ElectionTimeline"> | Date | string
    updatedAt?: DateTimeFilter<"ElectionTimeline"> | Date | string
    phase?: StringFilter<"ElectionTimeline"> | string
    startDate?: DateTimeFilter<"ElectionTimeline"> | Date | string
    endDate?: DateTimeFilter<"ElectionTimeline"> | Date | string
    gracePeriodHours?: IntFilter<"ElectionTimeline"> | number
    isActive?: BoolFilter<"ElectionTimeline"> | boolean
    automaticTransition?: BoolFilter<"ElectionTimeline"> | boolean
  }

  export type ElectionTimelineOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phase?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    gracePeriodHours?: SortOrder
    isActive?: SortOrder
    automaticTransition?: SortOrder
  }

  export type ElectionTimelineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phase?: string
    AND?: ElectionTimelineWhereInput | ElectionTimelineWhereInput[]
    OR?: ElectionTimelineWhereInput[]
    NOT?: ElectionTimelineWhereInput | ElectionTimelineWhereInput[]
    createdAt?: DateTimeFilter<"ElectionTimeline"> | Date | string
    updatedAt?: DateTimeFilter<"ElectionTimeline"> | Date | string
    startDate?: DateTimeFilter<"ElectionTimeline"> | Date | string
    endDate?: DateTimeFilter<"ElectionTimeline"> | Date | string
    gracePeriodHours?: IntFilter<"ElectionTimeline"> | number
    isActive?: BoolFilter<"ElectionTimeline"> | boolean
    automaticTransition?: BoolFilter<"ElectionTimeline"> | boolean
  }, "id" | "phase">

  export type ElectionTimelineOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phase?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    gracePeriodHours?: SortOrder
    isActive?: SortOrder
    automaticTransition?: SortOrder
    _count?: ElectionTimelineCountOrderByAggregateInput
    _avg?: ElectionTimelineAvgOrderByAggregateInput
    _max?: ElectionTimelineMaxOrderByAggregateInput
    _min?: ElectionTimelineMinOrderByAggregateInput
    _sum?: ElectionTimelineSumOrderByAggregateInput
  }

  export type ElectionTimelineScalarWhereWithAggregatesInput = {
    AND?: ElectionTimelineScalarWhereWithAggregatesInput | ElectionTimelineScalarWhereWithAggregatesInput[]
    OR?: ElectionTimelineScalarWhereWithAggregatesInput[]
    NOT?: ElectionTimelineScalarWhereWithAggregatesInput | ElectionTimelineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ElectionTimeline"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ElectionTimeline"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ElectionTimeline"> | Date | string
    phase?: StringWithAggregatesFilter<"ElectionTimeline"> | string
    startDate?: DateTimeWithAggregatesFilter<"ElectionTimeline"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"ElectionTimeline"> | Date | string
    gracePeriodHours?: IntWithAggregatesFilter<"ElectionTimeline"> | number
    isActive?: BoolWithAggregatesFilter<"ElectionTimeline"> | boolean
    automaticTransition?: BoolWithAggregatesFilter<"ElectionTimeline"> | boolean
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    programme?: string | null
    level?: string | null
    subgroup?: string | null
    college?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nominations?: NominationCreateNestedManyWithoutAspirantInput
    ecReviews?: EcReviewCreateNestedManyWithoutReviewerInput
    Nomination?: NominationCreateNestedManyWithoutUserInput
    NominatorVerification?: NominatorVerificationCreateNestedManyWithoutUserInput
    GuarantorVerification?: GuarantorVerificationCreateNestedManyWithoutUserInput
    EcReview?: EcReviewCreateNestedManyWithoutUserInput
    VotingSession?: VotingSessionCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Subgroup?: SubgroupCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    programme?: string | null
    level?: string | null
    subgroup?: string | null
    college?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subgroupId?: string | null
    nominations?: NominationUncheckedCreateNestedManyWithoutAspirantInput
    ecReviews?: EcReviewUncheckedCreateNestedManyWithoutReviewerInput
    Nomination?: NominationUncheckedCreateNestedManyWithoutUserInput
    NominatorVerification?: NominatorVerificationUncheckedCreateNestedManyWithoutUserInput
    GuarantorVerification?: GuarantorVerificationUncheckedCreateNestedManyWithoutUserInput
    EcReview?: EcReviewUncheckedCreateNestedManyWithoutUserInput
    VotingSession?: VotingSessionUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nominations?: NominationUpdateManyWithoutAspirantNestedInput
    ecReviews?: EcReviewUpdateManyWithoutReviewerNestedInput
    Nomination?: NominationUpdateManyWithoutUserNestedInput
    NominatorVerification?: NominatorVerificationUpdateManyWithoutUserNestedInput
    GuarantorVerification?: GuarantorVerificationUpdateManyWithoutUserNestedInput
    EcReview?: EcReviewUpdateManyWithoutUserNestedInput
    VotingSession?: VotingSessionUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Subgroup?: SubgroupUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null
    nominations?: NominationUncheckedUpdateManyWithoutAspirantNestedInput
    ecReviews?: EcReviewUncheckedUpdateManyWithoutReviewerNestedInput
    Nomination?: NominationUncheckedUpdateManyWithoutUserNestedInput
    NominatorVerification?: NominatorVerificationUncheckedUpdateManyWithoutUserNestedInput
    GuarantorVerification?: GuarantorVerificationUncheckedUpdateManyWithoutUserNestedInput
    EcReview?: EcReviewUncheckedUpdateManyWithoutUserNestedInput
    VotingSession?: VotingSessionUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    programme?: string | null
    level?: string | null
    subgroup?: string | null
    college?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subgroupId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NominationCreateInput = {
    id?: string
    nomineeName: string
    nomineeEmail: string
    nomineeContact: string
    nomineePosition: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    status?: $Enums.NominationStatus
    nomineeCollege: string
    nomineeDepartment: string
    nomineeDateOfBirth: Date | string
    nomineeHostel: string
    nomineeRoom: string
    nomineeSex: string
    nomineeCwa: string
    nomineeProgramme: string
    nomineeLevel: string
    nomineeParish: string
    nomineeNationality: string
    nomineeRegion: string
    nomineeSubgroups?: NominationCreatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationCreatenomineeEducationInput | string[]
    hasLeadershipPosition: boolean
    leadershipPositions?: NominationCreateleadershipPositionsInput | string[]
    hasServedCommittee: boolean
    committees?: NominationCreatecommitteesInput | string[]
    skills?: NominationCreateskillsInput | string[]
    visionForOffice?: NominationCreatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationCreateknowledgeAboutOfficeInput | string[]
    approvalCount?: number
    rejectionCount?: number
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aspirant: UserCreateNestedOneWithoutNominationsInput
    nominatorVerification?: NominatorVerificationCreateNestedOneWithoutNominationInput
    guarantorVerifications?: GuarantorVerificationCreateNestedManyWithoutNominationInput
    EcReview?: EcReviewCreateNestedManyWithoutNominationInput
    candidate?: CandidateCreateNestedOneWithoutNominationInput
    User?: UserCreateNestedOneWithoutNominationInput
    Subgroup?: SubgroupCreateNestedOneWithoutNominationsInput
  }

  export type NominationUncheckedCreateInput = {
    id?: string
    aspirantId: string
    nomineeName: string
    nomineeEmail: string
    nomineeContact: string
    nomineePosition: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    status?: $Enums.NominationStatus
    nomineeCollege: string
    nomineeDepartment: string
    nomineeDateOfBirth: Date | string
    nomineeHostel: string
    nomineeRoom: string
    nomineeSex: string
    nomineeCwa: string
    nomineeProgramme: string
    nomineeLevel: string
    nomineeParish: string
    nomineeNationality: string
    nomineeRegion: string
    nomineeSubgroups?: NominationCreatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationCreatenomineeEducationInput | string[]
    hasLeadershipPosition: boolean
    leadershipPositions?: NominationCreateleadershipPositionsInput | string[]
    hasServedCommittee: boolean
    committees?: NominationCreatecommitteesInput | string[]
    skills?: NominationCreateskillsInput | string[]
    visionForOffice?: NominationCreatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationCreateknowledgeAboutOfficeInput | string[]
    approvalCount?: number
    rejectionCount?: number
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    subgroupId?: string | null
    nominatorVerification?: NominatorVerificationUncheckedCreateNestedOneWithoutNominationInput
    guarantorVerifications?: GuarantorVerificationUncheckedCreateNestedManyWithoutNominationInput
    EcReview?: EcReviewUncheckedCreateNestedManyWithoutNominationInput
    candidate?: CandidateUncheckedCreateNestedOneWithoutNominationInput
  }

  export type NominationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    nomineeEmail?: StringFieldUpdateOperationsInput | string
    nomineeContact?: StringFieldUpdateOperationsInput | string
    nomineePosition?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNominationStatusFieldUpdateOperationsInput | $Enums.NominationStatus
    nomineeCollege?: StringFieldUpdateOperationsInput | string
    nomineeDepartment?: StringFieldUpdateOperationsInput | string
    nomineeDateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nomineeHostel?: StringFieldUpdateOperationsInput | string
    nomineeRoom?: StringFieldUpdateOperationsInput | string
    nomineeSex?: StringFieldUpdateOperationsInput | string
    nomineeCwa?: StringFieldUpdateOperationsInput | string
    nomineeProgramme?: StringFieldUpdateOperationsInput | string
    nomineeLevel?: StringFieldUpdateOperationsInput | string
    nomineeParish?: StringFieldUpdateOperationsInput | string
    nomineeNationality?: StringFieldUpdateOperationsInput | string
    nomineeRegion?: StringFieldUpdateOperationsInput | string
    nomineeSubgroups?: NominationUpdatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationUpdatenomineeEducationInput | string[]
    hasLeadershipPosition?: BoolFieldUpdateOperationsInput | boolean
    leadershipPositions?: NominationUpdateleadershipPositionsInput | string[]
    hasServedCommittee?: BoolFieldUpdateOperationsInput | boolean
    committees?: NominationUpdatecommitteesInput | string[]
    skills?: NominationUpdateskillsInput | string[]
    visionForOffice?: NominationUpdatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationUpdateknowledgeAboutOfficeInput | string[]
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aspirant?: UserUpdateOneRequiredWithoutNominationsNestedInput
    nominatorVerification?: NominatorVerificationUpdateOneWithoutNominationNestedInput
    guarantorVerifications?: GuarantorVerificationUpdateManyWithoutNominationNestedInput
    EcReview?: EcReviewUpdateManyWithoutNominationNestedInput
    candidate?: CandidateUpdateOneWithoutNominationNestedInput
    User?: UserUpdateOneWithoutNominationNestedInput
    Subgroup?: SubgroupUpdateOneWithoutNominationsNestedInput
  }

  export type NominationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    aspirantId?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    nomineeEmail?: StringFieldUpdateOperationsInput | string
    nomineeContact?: StringFieldUpdateOperationsInput | string
    nomineePosition?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNominationStatusFieldUpdateOperationsInput | $Enums.NominationStatus
    nomineeCollege?: StringFieldUpdateOperationsInput | string
    nomineeDepartment?: StringFieldUpdateOperationsInput | string
    nomineeDateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nomineeHostel?: StringFieldUpdateOperationsInput | string
    nomineeRoom?: StringFieldUpdateOperationsInput | string
    nomineeSex?: StringFieldUpdateOperationsInput | string
    nomineeCwa?: StringFieldUpdateOperationsInput | string
    nomineeProgramme?: StringFieldUpdateOperationsInput | string
    nomineeLevel?: StringFieldUpdateOperationsInput | string
    nomineeParish?: StringFieldUpdateOperationsInput | string
    nomineeNationality?: StringFieldUpdateOperationsInput | string
    nomineeRegion?: StringFieldUpdateOperationsInput | string
    nomineeSubgroups?: NominationUpdatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationUpdatenomineeEducationInput | string[]
    hasLeadershipPosition?: BoolFieldUpdateOperationsInput | boolean
    leadershipPositions?: NominationUpdateleadershipPositionsInput | string[]
    hasServedCommittee?: BoolFieldUpdateOperationsInput | boolean
    committees?: NominationUpdatecommitteesInput | string[]
    skills?: NominationUpdateskillsInput | string[]
    visionForOffice?: NominationUpdatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationUpdateknowledgeAboutOfficeInput | string[]
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null
    nominatorVerification?: NominatorVerificationUncheckedUpdateOneWithoutNominationNestedInput
    guarantorVerifications?: GuarantorVerificationUncheckedUpdateManyWithoutNominationNestedInput
    EcReview?: EcReviewUncheckedUpdateManyWithoutNominationNestedInput
    candidate?: CandidateUncheckedUpdateOneWithoutNominationNestedInput
  }

  export type NominationCreateManyInput = {
    id?: string
    aspirantId: string
    nomineeName: string
    nomineeEmail: string
    nomineeContact: string
    nomineePosition: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    status?: $Enums.NominationStatus
    nomineeCollege: string
    nomineeDepartment: string
    nomineeDateOfBirth: Date | string
    nomineeHostel: string
    nomineeRoom: string
    nomineeSex: string
    nomineeCwa: string
    nomineeProgramme: string
    nomineeLevel: string
    nomineeParish: string
    nomineeNationality: string
    nomineeRegion: string
    nomineeSubgroups?: NominationCreatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationCreatenomineeEducationInput | string[]
    hasLeadershipPosition: boolean
    leadershipPositions?: NominationCreateleadershipPositionsInput | string[]
    hasServedCommittee: boolean
    committees?: NominationCreatecommitteesInput | string[]
    skills?: NominationCreateskillsInput | string[]
    visionForOffice?: NominationCreatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationCreateknowledgeAboutOfficeInput | string[]
    approvalCount?: number
    rejectionCount?: number
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    subgroupId?: string | null
  }

  export type NominationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    nomineeEmail?: StringFieldUpdateOperationsInput | string
    nomineeContact?: StringFieldUpdateOperationsInput | string
    nomineePosition?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNominationStatusFieldUpdateOperationsInput | $Enums.NominationStatus
    nomineeCollege?: StringFieldUpdateOperationsInput | string
    nomineeDepartment?: StringFieldUpdateOperationsInput | string
    nomineeDateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nomineeHostel?: StringFieldUpdateOperationsInput | string
    nomineeRoom?: StringFieldUpdateOperationsInput | string
    nomineeSex?: StringFieldUpdateOperationsInput | string
    nomineeCwa?: StringFieldUpdateOperationsInput | string
    nomineeProgramme?: StringFieldUpdateOperationsInput | string
    nomineeLevel?: StringFieldUpdateOperationsInput | string
    nomineeParish?: StringFieldUpdateOperationsInput | string
    nomineeNationality?: StringFieldUpdateOperationsInput | string
    nomineeRegion?: StringFieldUpdateOperationsInput | string
    nomineeSubgroups?: NominationUpdatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationUpdatenomineeEducationInput | string[]
    hasLeadershipPosition?: BoolFieldUpdateOperationsInput | boolean
    leadershipPositions?: NominationUpdateleadershipPositionsInput | string[]
    hasServedCommittee?: BoolFieldUpdateOperationsInput | boolean
    committees?: NominationUpdatecommitteesInput | string[]
    skills?: NominationUpdateskillsInput | string[]
    visionForOffice?: NominationUpdatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationUpdateknowledgeAboutOfficeInput | string[]
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NominationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    aspirantId?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    nomineeEmail?: StringFieldUpdateOperationsInput | string
    nomineeContact?: StringFieldUpdateOperationsInput | string
    nomineePosition?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNominationStatusFieldUpdateOperationsInput | $Enums.NominationStatus
    nomineeCollege?: StringFieldUpdateOperationsInput | string
    nomineeDepartment?: StringFieldUpdateOperationsInput | string
    nomineeDateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nomineeHostel?: StringFieldUpdateOperationsInput | string
    nomineeRoom?: StringFieldUpdateOperationsInput | string
    nomineeSex?: StringFieldUpdateOperationsInput | string
    nomineeCwa?: StringFieldUpdateOperationsInput | string
    nomineeProgramme?: StringFieldUpdateOperationsInput | string
    nomineeLevel?: StringFieldUpdateOperationsInput | string
    nomineeParish?: StringFieldUpdateOperationsInput | string
    nomineeNationality?: StringFieldUpdateOperationsInput | string
    nomineeRegion?: StringFieldUpdateOperationsInput | string
    nomineeSubgroups?: NominationUpdatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationUpdatenomineeEducationInput | string[]
    hasLeadershipPosition?: BoolFieldUpdateOperationsInput | boolean
    leadershipPositions?: NominationUpdateleadershipPositionsInput | string[]
    hasServedCommittee?: BoolFieldUpdateOperationsInput | boolean
    committees?: NominationUpdatecommitteesInput | string[]
    skills?: NominationUpdateskillsInput | string[]
    visionForOffice?: NominationUpdatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationUpdateknowledgeAboutOfficeInput | string[]
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NominatorVerificationCreateInput = {
    id?: string
    name: string
    email: string
    contact: string
    programme: string
    level: string
    subgroup: string
    status?: string
    comments?: string | null
    verifiedAt?: Date | string | null
    declinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nomination: NominationCreateNestedOneWithoutNominatorVerificationInput
    verificationToken?: VerificationTokenCreateNestedOneWithoutNominatorVerificationInput
    User?: UserCreateNestedOneWithoutNominatorVerificationInput
  }

  export type NominatorVerificationUncheckedCreateInput = {
    id?: string
    nominationId: string
    name: string
    email: string
    contact: string
    programme: string
    level: string
    subgroup: string
    status?: string
    comments?: string | null
    verifiedAt?: Date | string | null
    declinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    verificationToken?: VerificationTokenUncheckedCreateNestedOneWithoutNominatorVerificationInput
  }

  export type NominatorVerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nomination?: NominationUpdateOneRequiredWithoutNominatorVerificationNestedInput
    verificationToken?: VerificationTokenUpdateOneWithoutNominatorVerificationNestedInput
    User?: UserUpdateOneWithoutNominatorVerificationNestedInput
  }

  export type NominatorVerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nominationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationToken?: VerificationTokenUncheckedUpdateOneWithoutNominatorVerificationNestedInput
  }

  export type NominatorVerificationCreateManyInput = {
    id?: string
    nominationId: string
    name: string
    email: string
    contact: string
    programme: string
    level: string
    subgroup: string
    status?: string
    comments?: string | null
    verifiedAt?: Date | string | null
    declinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type NominatorVerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NominatorVerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nominationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GuarantorVerificationCreateInput = {
    id?: string
    name: string
    email: string
    contact: string
    programme: string
    subgroup: string
    status?: string
    comments?: string | null
    verifiedAt?: Date | string | null
    declinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verificationTokenId?: string | null
    nomination: NominationCreateNestedOneWithoutGuarantorVerificationsInput
    verificationToken?: VerificationTokenCreateNestedOneWithoutGuarantorVerificationInput
    User?: UserCreateNestedOneWithoutGuarantorVerificationInput
  }

  export type GuarantorVerificationUncheckedCreateInput = {
    id?: string
    nominationId: string
    name: string
    email: string
    contact: string
    programme: string
    subgroup: string
    status?: string
    comments?: string | null
    verifiedAt?: Date | string | null
    declinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verificationTokenId?: string | null
    userId?: string | null
    verificationToken?: VerificationTokenUncheckedCreateNestedOneWithoutGuarantorVerificationInput
  }

  export type GuarantorVerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    nomination?: NominationUpdateOneRequiredWithoutGuarantorVerificationsNestedInput
    verificationToken?: VerificationTokenUpdateOneWithoutGuarantorVerificationNestedInput
    User?: UserUpdateOneWithoutGuarantorVerificationNestedInput
  }

  export type GuarantorVerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nominationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationToken?: VerificationTokenUncheckedUpdateOneWithoutGuarantorVerificationNestedInput
  }

  export type GuarantorVerificationCreateManyInput = {
    id?: string
    nominationId: string
    name: string
    email: string
    contact: string
    programme: string
    subgroup: string
    status?: string
    comments?: string | null
    verifiedAt?: Date | string | null
    declinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verificationTokenId?: string | null
    userId?: string | null
  }

  export type GuarantorVerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationTokenId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GuarantorVerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nominationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EcReviewCreateInput = {
    id?: string
    approved: boolean
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nomination: NominationCreateNestedOneWithoutEcReviewInput
    reviewer: UserCreateNestedOneWithoutEcReviewsInput
    User?: UserCreateNestedOneWithoutEcReviewInput
  }

  export type EcReviewUncheckedCreateInput = {
    id?: string
    nominationId: string
    reviewerId: string
    approved: boolean
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type EcReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nomination?: NominationUpdateOneRequiredWithoutEcReviewNestedInput
    reviewer?: UserUpdateOneRequiredWithoutEcReviewsNestedInput
    User?: UserUpdateOneWithoutEcReviewNestedInput
  }

  export type EcReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nominationId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EcReviewCreateManyInput = {
    id?: string
    nominationId: string
    reviewerId: string
    approved: boolean
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type EcReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EcReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nominationId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerificationTokenCreateInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    email?: string | null
    phone?: string | null
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    nominatorVerification?: NominatorVerificationCreateNestedOneWithoutVerificationTokenInput
    guarantorVerification?: GuarantorVerificationCreateNestedOneWithoutVerificationTokenInput
  }

  export type VerificationTokenUncheckedCreateInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    email?: string | null
    phone?: string | null
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    nominatorVerificationId?: string | null
    guarantorVerificationId?: string | null
  }

  export type VerificationTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nominatorVerification?: NominatorVerificationUpdateOneWithoutVerificationTokenNestedInput
    guarantorVerification?: GuarantorVerificationUpdateOneWithoutVerificationTokenNestedInput
  }

  export type VerificationTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nominatorVerificationId?: NullableStringFieldUpdateOperationsInput | string | null
    guarantorVerificationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerificationTokenCreateManyInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    email?: string | null
    phone?: string | null
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    nominatorVerificationId?: string | null
    guarantorVerificationId?: string | null
  }

  export type VerificationTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nominatorVerificationId?: NullableStringFieldUpdateOperationsInput | string | null
    guarantorVerificationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CandidateCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    position: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    biography?: string | null
    displayOrder?: number
    isActive?: boolean
    candidateNumber: number
    voteCount?: number
    nomination: NominationCreateNestedOneWithoutCandidateInput
  }

  export type CandidateUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    position: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    biography?: string | null
    displayOrder?: number
    isActive?: boolean
    candidateNumber: number
    nominationId: string
    voteCount?: number
  }

  export type CandidateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    position?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    candidateNumber?: IntFieldUpdateOperationsInput | number
    voteCount?: IntFieldUpdateOperationsInput | number
    nomination?: NominationUpdateOneRequiredWithoutCandidateNestedInput
  }

  export type CandidateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    position?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    candidateNumber?: IntFieldUpdateOperationsInput | number
    nominationId?: StringFieldUpdateOperationsInput | string
    voteCount?: IntFieldUpdateOperationsInput | number
  }

  export type CandidateCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    position: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    biography?: string | null
    displayOrder?: number
    isActive?: boolean
    candidateNumber: number
    nominationId: string
    voteCount?: number
  }

  export type CandidateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    position?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    candidateNumber?: IntFieldUpdateOperationsInput | number
    voteCount?: IntFieldUpdateOperationsInput | number
  }

  export type CandidateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    position?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    candidateNumber?: IntFieldUpdateOperationsInput | number
    nominationId?: StringFieldUpdateOperationsInput | string
    voteCount?: IntFieldUpdateOperationsInput | number
  }

  export type VotingSessionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionId: string
    voterHash: string
    deviceFingerprint?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    status?: $Enums.VotingStatus
    startTime?: Date | string
    endTime?: Date | string | null
    expiresAt: Date | string
    isValid?: boolean
    user: UserCreateNestedOneWithoutVotingSessionInput
    votes?: VoteCreateNestedManyWithoutSessionInput
  }

  export type VotingSessionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionId: string
    voterHash: string
    deviceFingerprint?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    status?: $Enums.VotingStatus
    startTime?: Date | string
    endTime?: Date | string | null
    expiresAt: Date | string
    isValid?: boolean
    userId: string
    votes?: VoteUncheckedCreateNestedManyWithoutSessionInput
  }

  export type VotingSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
    voterHash?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVotingStatusFieldUpdateOperationsInput | $Enums.VotingStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValid?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutVotingSessionNestedInput
    votes?: VoteUpdateManyWithoutSessionNestedInput
  }

  export type VotingSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
    voterHash?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVotingStatusFieldUpdateOperationsInput | $Enums.VotingStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValid?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    votes?: VoteUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type VotingSessionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionId: string
    voterHash: string
    deviceFingerprint?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    status?: $Enums.VotingStatus
    startTime?: Date | string
    endTime?: Date | string | null
    expiresAt: Date | string
    isValid?: boolean
    userId: string
  }

  export type VotingSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
    voterHash?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVotingStatusFieldUpdateOperationsInput | $Enums.VotingStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VotingSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
    voterHash?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVotingStatusFieldUpdateOperationsInput | $Enums.VotingStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValid?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type VoteCreateInput = {
    id?: string
    createdAt?: Date | string
    encryptedVote: string
    voterHash: string
    submissionTime?: Date | string
    deviceFingerprint?: string | null
    ipAddress?: string | null
    isValid?: boolean
    session: VotingSessionCreateNestedOneWithoutVotesInput
  }

  export type VoteUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    encryptedVote: string
    voterHash: string
    submissionTime?: Date | string
    deviceFingerprint?: string | null
    ipAddress?: string | null
    isValid?: boolean
    sessionId: string
  }

  export type VoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encryptedVote?: StringFieldUpdateOperationsInput | string
    voterHash?: StringFieldUpdateOperationsInput | string
    submissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    session?: VotingSessionUpdateOneRequiredWithoutVotesNestedInput
  }

  export type VoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encryptedVote?: StringFieldUpdateOperationsInput | string
    voterHash?: StringFieldUpdateOperationsInput | string
    submissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    sessionId?: StringFieldUpdateOperationsInput | string
  }

  export type VoteCreateManyInput = {
    id?: string
    createdAt?: Date | string
    encryptedVote: string
    voterHash: string
    submissionTime?: Date | string
    deviceFingerprint?: string | null
    ipAddress?: string | null
    isValid?: boolean
    sessionId: string
  }

  export type VoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encryptedVote?: StringFieldUpdateOperationsInput | string
    voterHash?: StringFieldUpdateOperationsInput | string
    submissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encryptedVote?: StringFieldUpdateOperationsInput | string
    voterHash?: StringFieldUpdateOperationsInput | string
    submissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    sessionId?: StringFieldUpdateOperationsInput | string
  }

  export type AuditLogCreateInput = {
    id?: string
    createdAt?: Date | string
    action: string
    entity: string
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    user?: UserCreateNestedOneWithoutAuditLogInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    action: string
    entity: string
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    userId?: string | null
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutAuditLogNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogCreateManyInput = {
    id?: string
    createdAt?: Date | string
    action: string
    entity: string
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    userId?: string | null
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubgroupCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    isActive?: boolean
    users?: UserCreateNestedManyWithoutSubgroupInput
    nominations?: NominationCreateNestedManyWithoutSubgroupInput
  }

  export type SubgroupUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    isActive?: boolean
    users?: UserUncheckedCreateNestedManyWithoutSubgroupInput
    nominations?: NominationUncheckedCreateNestedManyWithoutSubgroupInput
  }

  export type SubgroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateManyWithoutSubgroupNestedInput
    nominations?: NominationUpdateManyWithoutSubgroupNestedInput
  }

  export type SubgroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUncheckedUpdateManyWithoutSubgroupNestedInput
    nominations?: NominationUncheckedUpdateManyWithoutSubgroupNestedInput
  }

  export type SubgroupCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    isActive?: boolean
  }

  export type SubgroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubgroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProgrammeCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    college?: string | null
    duration?: number | null
    isActive?: boolean
  }

  export type ProgrammeUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    college?: string | null
    duration?: number | null
    isActive?: boolean
  }

  export type ProgrammeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    college?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProgrammeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    college?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProgrammeCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    college?: string | null
    duration?: number | null
    isActive?: boolean
  }

  export type ProgrammeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    college?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProgrammeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    college?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SystemConfigCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    key: string
    value: string
    type: string
  }

  export type SystemConfigUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    key: string
    value: string
    type: string
  }

  export type SystemConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type SystemConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type SystemConfigCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    key: string
    value: string
    type: string
  }

  export type SystemConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type SystemConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type ElectionTimelineCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phase: string
    startDate: Date | string
    endDate: Date | string
    gracePeriodHours?: number
    isActive?: boolean
    automaticTransition?: boolean
  }

  export type ElectionTimelineUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phase: string
    startDate: Date | string
    endDate: Date | string
    gracePeriodHours?: number
    isActive?: boolean
    automaticTransition?: boolean
  }

  export type ElectionTimelineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phase?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gracePeriodHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    automaticTransition?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ElectionTimelineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phase?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gracePeriodHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    automaticTransition?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ElectionTimelineCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phase: string
    startDate: Date | string
    endDate: Date | string
    gracePeriodHours?: number
    isActive?: boolean
    automaticTransition?: boolean
  }

  export type ElectionTimelineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phase?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gracePeriodHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    automaticTransition?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ElectionTimelineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phase?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gracePeriodHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    automaticTransition?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NominationListRelationFilter = {
    every?: NominationWhereInput
    some?: NominationWhereInput
    none?: NominationWhereInput
  }

  export type EcReviewListRelationFilter = {
    every?: EcReviewWhereInput
    some?: EcReviewWhereInput
    none?: EcReviewWhereInput
  }

  export type NominatorVerificationListRelationFilter = {
    every?: NominatorVerificationWhereInput
    some?: NominatorVerificationWhereInput
    none?: NominatorVerificationWhereInput
  }

  export type GuarantorVerificationListRelationFilter = {
    every?: GuarantorVerificationWhereInput
    some?: GuarantorVerificationWhereInput
    none?: GuarantorVerificationWhereInput
  }

  export type VotingSessionListRelationFilter = {
    every?: VotingSessionWhereInput
    some?: VotingSessionWhereInput
    none?: VotingSessionWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SubgroupNullableScalarRelationFilter = {
    is?: SubgroupWhereInput | null
    isNot?: SubgroupWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type NominationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EcReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NominatorVerificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GuarantorVerificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VotingSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role?: SortOrder
    programme?: SortOrder
    level?: SortOrder
    subgroup?: SortOrder
    college?: SortOrder
    phoneVerified?: SortOrder
    emailVerified?: SortOrder
    isActive?: SortOrder
    hasVoted?: SortOrder
    inkVerified?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subgroupId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role?: SortOrder
    programme?: SortOrder
    level?: SortOrder
    subgroup?: SortOrder
    college?: SortOrder
    phoneVerified?: SortOrder
    emailVerified?: SortOrder
    isActive?: SortOrder
    hasVoted?: SortOrder
    inkVerified?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subgroupId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role?: SortOrder
    programme?: SortOrder
    level?: SortOrder
    subgroup?: SortOrder
    college?: SortOrder
    phoneVerified?: SortOrder
    emailVerified?: SortOrder
    isActive?: SortOrder
    hasVoted?: SortOrder
    inkVerified?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subgroupId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumCandidate_PositionFilter<$PrismaModel = never> = {
    equals?: $Enums.Candidate_Position | EnumCandidate_PositionFieldRefInput<$PrismaModel>
    in?: $Enums.Candidate_Position[] | ListEnumCandidate_PositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Candidate_Position[] | ListEnumCandidate_PositionFieldRefInput<$PrismaModel>
    not?: NestedEnumCandidate_PositionFilter<$PrismaModel> | $Enums.Candidate_Position
  }

  export type EnumNominationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NominationStatus | EnumNominationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NominationStatus[] | ListEnumNominationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NominationStatus[] | ListEnumNominationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNominationStatusFilter<$PrismaModel> | $Enums.NominationStatus
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type NominatorVerificationNullableScalarRelationFilter = {
    is?: NominatorVerificationWhereInput | null
    isNot?: NominatorVerificationWhereInput | null
  }

  export type CandidateNullableScalarRelationFilter = {
    is?: CandidateWhereInput | null
    isNot?: CandidateWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type NominationCountOrderByAggregateInput = {
    id?: SortOrder
    aspirantId?: SortOrder
    nomineeName?: SortOrder
    nomineeEmail?: SortOrder
    nomineeContact?: SortOrder
    nomineePosition?: SortOrder
    photoUrl?: SortOrder
    photoPublicId?: SortOrder
    status?: SortOrder
    nomineeCollege?: SortOrder
    nomineeDepartment?: SortOrder
    nomineeDateOfBirth?: SortOrder
    nomineeHostel?: SortOrder
    nomineeRoom?: SortOrder
    nomineeSex?: SortOrder
    nomineeCwa?: SortOrder
    nomineeProgramme?: SortOrder
    nomineeLevel?: SortOrder
    nomineeParish?: SortOrder
    nomineeNationality?: SortOrder
    nomineeRegion?: SortOrder
    nomineeSubgroups?: SortOrder
    nomineeEducation?: SortOrder
    hasLeadershipPosition?: SortOrder
    leadershipPositions?: SortOrder
    hasServedCommittee?: SortOrder
    committees?: SortOrder
    skills?: SortOrder
    visionForOffice?: SortOrder
    knowledgeAboutOffice?: SortOrder
    approvalCount?: SortOrder
    rejectionCount?: SortOrder
    reviewedAt?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    subgroupId?: SortOrder
  }

  export type NominationAvgOrderByAggregateInput = {
    approvalCount?: SortOrder
    rejectionCount?: SortOrder
  }

  export type NominationMaxOrderByAggregateInput = {
    id?: SortOrder
    aspirantId?: SortOrder
    nomineeName?: SortOrder
    nomineeEmail?: SortOrder
    nomineeContact?: SortOrder
    nomineePosition?: SortOrder
    photoUrl?: SortOrder
    photoPublicId?: SortOrder
    status?: SortOrder
    nomineeCollege?: SortOrder
    nomineeDepartment?: SortOrder
    nomineeDateOfBirth?: SortOrder
    nomineeHostel?: SortOrder
    nomineeRoom?: SortOrder
    nomineeSex?: SortOrder
    nomineeCwa?: SortOrder
    nomineeProgramme?: SortOrder
    nomineeLevel?: SortOrder
    nomineeParish?: SortOrder
    nomineeNationality?: SortOrder
    nomineeRegion?: SortOrder
    hasLeadershipPosition?: SortOrder
    hasServedCommittee?: SortOrder
    approvalCount?: SortOrder
    rejectionCount?: SortOrder
    reviewedAt?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    subgroupId?: SortOrder
  }

  export type NominationMinOrderByAggregateInput = {
    id?: SortOrder
    aspirantId?: SortOrder
    nomineeName?: SortOrder
    nomineeEmail?: SortOrder
    nomineeContact?: SortOrder
    nomineePosition?: SortOrder
    photoUrl?: SortOrder
    photoPublicId?: SortOrder
    status?: SortOrder
    nomineeCollege?: SortOrder
    nomineeDepartment?: SortOrder
    nomineeDateOfBirth?: SortOrder
    nomineeHostel?: SortOrder
    nomineeRoom?: SortOrder
    nomineeSex?: SortOrder
    nomineeCwa?: SortOrder
    nomineeProgramme?: SortOrder
    nomineeLevel?: SortOrder
    nomineeParish?: SortOrder
    nomineeNationality?: SortOrder
    nomineeRegion?: SortOrder
    hasLeadershipPosition?: SortOrder
    hasServedCommittee?: SortOrder
    approvalCount?: SortOrder
    rejectionCount?: SortOrder
    reviewedAt?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    subgroupId?: SortOrder
  }

  export type NominationSumOrderByAggregateInput = {
    approvalCount?: SortOrder
    rejectionCount?: SortOrder
  }

  export type EnumCandidate_PositionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Candidate_Position | EnumCandidate_PositionFieldRefInput<$PrismaModel>
    in?: $Enums.Candidate_Position[] | ListEnumCandidate_PositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Candidate_Position[] | ListEnumCandidate_PositionFieldRefInput<$PrismaModel>
    not?: NestedEnumCandidate_PositionWithAggregatesFilter<$PrismaModel> | $Enums.Candidate_Position
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCandidate_PositionFilter<$PrismaModel>
    _max?: NestedEnumCandidate_PositionFilter<$PrismaModel>
  }

  export type EnumNominationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NominationStatus | EnumNominationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NominationStatus[] | ListEnumNominationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NominationStatus[] | ListEnumNominationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNominationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NominationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNominationStatusFilter<$PrismaModel>
    _max?: NestedEnumNominationStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NominationScalarRelationFilter = {
    is?: NominationWhereInput
    isNot?: NominationWhereInput
  }

  export type VerificationTokenNullableScalarRelationFilter = {
    is?: VerificationTokenWhereInput | null
    isNot?: VerificationTokenWhereInput | null
  }

  export type NominatorVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    nominationId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    contact?: SortOrder
    programme?: SortOrder
    level?: SortOrder
    subgroup?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    verifiedAt?: SortOrder
    declinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type NominatorVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    nominationId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    contact?: SortOrder
    programme?: SortOrder
    level?: SortOrder
    subgroup?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    verifiedAt?: SortOrder
    declinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type NominatorVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    nominationId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    contact?: SortOrder
    programme?: SortOrder
    level?: SortOrder
    subgroup?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    verifiedAt?: SortOrder
    declinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type GuarantorVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    nominationId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    contact?: SortOrder
    programme?: SortOrder
    subgroup?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    verifiedAt?: SortOrder
    declinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verificationTokenId?: SortOrder
    userId?: SortOrder
  }

  export type GuarantorVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    nominationId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    contact?: SortOrder
    programme?: SortOrder
    subgroup?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    verifiedAt?: SortOrder
    declinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verificationTokenId?: SortOrder
    userId?: SortOrder
  }

  export type GuarantorVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    nominationId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    contact?: SortOrder
    programme?: SortOrder
    subgroup?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    verifiedAt?: SortOrder
    declinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verificationTokenId?: SortOrder
    userId?: SortOrder
  }

  export type EcReviewNominationIdReviewerIdCompoundUniqueInput = {
    nominationId: string
    reviewerId: string
  }

  export type EcReviewCountOrderByAggregateInput = {
    id?: SortOrder
    nominationId?: SortOrder
    reviewerId?: SortOrder
    approved?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type EcReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    nominationId?: SortOrder
    reviewerId?: SortOrder
    approved?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type EcReviewMinOrderByAggregateInput = {
    id?: SortOrder
    nominationId?: SortOrder
    reviewerId?: SortOrder
    approved?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type EnumTokenTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenTypeFilter<$PrismaModel> | $Enums.TokenType
  }

  export type GuarantorVerificationNullableScalarRelationFilter = {
    is?: GuarantorVerificationWhereInput | null
    isNot?: GuarantorVerificationWhereInput | null
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    nominatorVerificationId?: SortOrder
    guarantorVerificationId?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    nominatorVerificationId?: SortOrder
    guarantorVerificationId?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    nominatorVerificationId?: SortOrder
    guarantorVerificationId?: SortOrder
  }

  export type EnumTokenTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenTypeWithAggregatesFilter<$PrismaModel> | $Enums.TokenType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTokenTypeFilter<$PrismaModel>
    _max?: NestedEnumTokenTypeFilter<$PrismaModel>
  }

  export type CandidateCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    position?: SortOrder
    photoUrl?: SortOrder
    photoPublicId?: SortOrder
    biography?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    candidateNumber?: SortOrder
    nominationId?: SortOrder
    voteCount?: SortOrder
  }

  export type CandidateAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
    candidateNumber?: SortOrder
    voteCount?: SortOrder
  }

  export type CandidateMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    position?: SortOrder
    photoUrl?: SortOrder
    photoPublicId?: SortOrder
    biography?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    candidateNumber?: SortOrder
    nominationId?: SortOrder
    voteCount?: SortOrder
  }

  export type CandidateMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    position?: SortOrder
    photoUrl?: SortOrder
    photoPublicId?: SortOrder
    biography?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    candidateNumber?: SortOrder
    nominationId?: SortOrder
    voteCount?: SortOrder
  }

  export type CandidateSumOrderByAggregateInput = {
    displayOrder?: SortOrder
    candidateNumber?: SortOrder
    voteCount?: SortOrder
  }

  export type EnumVotingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VotingStatus | EnumVotingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VotingStatus[] | ListEnumVotingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VotingStatus[] | ListEnumVotingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVotingStatusFilter<$PrismaModel> | $Enums.VotingStatus
  }

  export type VoteListRelationFilter = {
    every?: VoteWhereInput
    some?: VoteWhereInput
    none?: VoteWhereInput
  }

  export type VoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VotingSessionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessionId?: SortOrder
    voterHash?: SortOrder
    deviceFingerprint?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    expiresAt?: SortOrder
    isValid?: SortOrder
    userId?: SortOrder
  }

  export type VotingSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessionId?: SortOrder
    voterHash?: SortOrder
    deviceFingerprint?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    expiresAt?: SortOrder
    isValid?: SortOrder
    userId?: SortOrder
  }

  export type VotingSessionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessionId?: SortOrder
    voterHash?: SortOrder
    deviceFingerprint?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    expiresAt?: SortOrder
    isValid?: SortOrder
    userId?: SortOrder
  }

  export type EnumVotingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VotingStatus | EnumVotingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VotingStatus[] | ListEnumVotingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VotingStatus[] | ListEnumVotingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVotingStatusWithAggregatesFilter<$PrismaModel> | $Enums.VotingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVotingStatusFilter<$PrismaModel>
    _max?: NestedEnumVotingStatusFilter<$PrismaModel>
  }

  export type VotingSessionScalarRelationFilter = {
    is?: VotingSessionWhereInput
    isNot?: VotingSessionWhereInput
  }

  export type VoteCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    encryptedVote?: SortOrder
    voterHash?: SortOrder
    submissionTime?: SortOrder
    deviceFingerprint?: SortOrder
    ipAddress?: SortOrder
    isValid?: SortOrder
    sessionId?: SortOrder
  }

  export type VoteMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    encryptedVote?: SortOrder
    voterHash?: SortOrder
    submissionTime?: SortOrder
    deviceFingerprint?: SortOrder
    ipAddress?: SortOrder
    isValid?: SortOrder
    sessionId?: SortOrder
  }

  export type VoteMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    encryptedVote?: SortOrder
    voterHash?: SortOrder
    submissionTime?: SortOrder
    deviceFingerprint?: SortOrder
    ipAddress?: SortOrder
    isValid?: SortOrder
    sessionId?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubgroupCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
  }

  export type SubgroupMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
  }

  export type SubgroupMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProgrammeCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    college?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
  }

  export type ProgrammeAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type ProgrammeMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    college?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
  }

  export type ProgrammeMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    college?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
  }

  export type ProgrammeSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SystemConfigCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
  }

  export type SystemConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
  }

  export type SystemConfigMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
  }

  export type ElectionTimelineCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phase?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    gracePeriodHours?: SortOrder
    isActive?: SortOrder
    automaticTransition?: SortOrder
  }

  export type ElectionTimelineAvgOrderByAggregateInput = {
    gracePeriodHours?: SortOrder
  }

  export type ElectionTimelineMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phase?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    gracePeriodHours?: SortOrder
    isActive?: SortOrder
    automaticTransition?: SortOrder
  }

  export type ElectionTimelineMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phase?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    gracePeriodHours?: SortOrder
    isActive?: SortOrder
    automaticTransition?: SortOrder
  }

  export type ElectionTimelineSumOrderByAggregateInput = {
    gracePeriodHours?: SortOrder
  }

  export type NominationCreateNestedManyWithoutAspirantInput = {
    create?: XOR<NominationCreateWithoutAspirantInput, NominationUncheckedCreateWithoutAspirantInput> | NominationCreateWithoutAspirantInput[] | NominationUncheckedCreateWithoutAspirantInput[]
    connectOrCreate?: NominationCreateOrConnectWithoutAspirantInput | NominationCreateOrConnectWithoutAspirantInput[]
    createMany?: NominationCreateManyAspirantInputEnvelope
    connect?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
  }

  export type EcReviewCreateNestedManyWithoutReviewerInput = {
    create?: XOR<EcReviewCreateWithoutReviewerInput, EcReviewUncheckedCreateWithoutReviewerInput> | EcReviewCreateWithoutReviewerInput[] | EcReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: EcReviewCreateOrConnectWithoutReviewerInput | EcReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: EcReviewCreateManyReviewerInputEnvelope
    connect?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
  }

  export type NominationCreateNestedManyWithoutUserInput = {
    create?: XOR<NominationCreateWithoutUserInput, NominationUncheckedCreateWithoutUserInput> | NominationCreateWithoutUserInput[] | NominationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NominationCreateOrConnectWithoutUserInput | NominationCreateOrConnectWithoutUserInput[]
    createMany?: NominationCreateManyUserInputEnvelope
    connect?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
  }

  export type NominatorVerificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NominatorVerificationCreateWithoutUserInput, NominatorVerificationUncheckedCreateWithoutUserInput> | NominatorVerificationCreateWithoutUserInput[] | NominatorVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NominatorVerificationCreateOrConnectWithoutUserInput | NominatorVerificationCreateOrConnectWithoutUserInput[]
    createMany?: NominatorVerificationCreateManyUserInputEnvelope
    connect?: NominatorVerificationWhereUniqueInput | NominatorVerificationWhereUniqueInput[]
  }

  export type GuarantorVerificationCreateNestedManyWithoutUserInput = {
    create?: XOR<GuarantorVerificationCreateWithoutUserInput, GuarantorVerificationUncheckedCreateWithoutUserInput> | GuarantorVerificationCreateWithoutUserInput[] | GuarantorVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GuarantorVerificationCreateOrConnectWithoutUserInput | GuarantorVerificationCreateOrConnectWithoutUserInput[]
    createMany?: GuarantorVerificationCreateManyUserInputEnvelope
    connect?: GuarantorVerificationWhereUniqueInput | GuarantorVerificationWhereUniqueInput[]
  }

  export type EcReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<EcReviewCreateWithoutUserInput, EcReviewUncheckedCreateWithoutUserInput> | EcReviewCreateWithoutUserInput[] | EcReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EcReviewCreateOrConnectWithoutUserInput | EcReviewCreateOrConnectWithoutUserInput[]
    createMany?: EcReviewCreateManyUserInputEnvelope
    connect?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
  }

  export type VotingSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<VotingSessionCreateWithoutUserInput, VotingSessionUncheckedCreateWithoutUserInput> | VotingSessionCreateWithoutUserInput[] | VotingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VotingSessionCreateOrConnectWithoutUserInput | VotingSessionCreateOrConnectWithoutUserInput[]
    createMany?: VotingSessionCreateManyUserInputEnvelope
    connect?: VotingSessionWhereUniqueInput | VotingSessionWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type SubgroupCreateNestedOneWithoutUsersInput = {
    create?: XOR<SubgroupCreateWithoutUsersInput, SubgroupUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SubgroupCreateOrConnectWithoutUsersInput
    connect?: SubgroupWhereUniqueInput
  }

  export type NominationUncheckedCreateNestedManyWithoutAspirantInput = {
    create?: XOR<NominationCreateWithoutAspirantInput, NominationUncheckedCreateWithoutAspirantInput> | NominationCreateWithoutAspirantInput[] | NominationUncheckedCreateWithoutAspirantInput[]
    connectOrCreate?: NominationCreateOrConnectWithoutAspirantInput | NominationCreateOrConnectWithoutAspirantInput[]
    createMany?: NominationCreateManyAspirantInputEnvelope
    connect?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
  }

  export type EcReviewUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<EcReviewCreateWithoutReviewerInput, EcReviewUncheckedCreateWithoutReviewerInput> | EcReviewCreateWithoutReviewerInput[] | EcReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: EcReviewCreateOrConnectWithoutReviewerInput | EcReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: EcReviewCreateManyReviewerInputEnvelope
    connect?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
  }

  export type NominationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NominationCreateWithoutUserInput, NominationUncheckedCreateWithoutUserInput> | NominationCreateWithoutUserInput[] | NominationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NominationCreateOrConnectWithoutUserInput | NominationCreateOrConnectWithoutUserInput[]
    createMany?: NominationCreateManyUserInputEnvelope
    connect?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
  }

  export type NominatorVerificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NominatorVerificationCreateWithoutUserInput, NominatorVerificationUncheckedCreateWithoutUserInput> | NominatorVerificationCreateWithoutUserInput[] | NominatorVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NominatorVerificationCreateOrConnectWithoutUserInput | NominatorVerificationCreateOrConnectWithoutUserInput[]
    createMany?: NominatorVerificationCreateManyUserInputEnvelope
    connect?: NominatorVerificationWhereUniqueInput | NominatorVerificationWhereUniqueInput[]
  }

  export type GuarantorVerificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GuarantorVerificationCreateWithoutUserInput, GuarantorVerificationUncheckedCreateWithoutUserInput> | GuarantorVerificationCreateWithoutUserInput[] | GuarantorVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GuarantorVerificationCreateOrConnectWithoutUserInput | GuarantorVerificationCreateOrConnectWithoutUserInput[]
    createMany?: GuarantorVerificationCreateManyUserInputEnvelope
    connect?: GuarantorVerificationWhereUniqueInput | GuarantorVerificationWhereUniqueInput[]
  }

  export type EcReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EcReviewCreateWithoutUserInput, EcReviewUncheckedCreateWithoutUserInput> | EcReviewCreateWithoutUserInput[] | EcReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EcReviewCreateOrConnectWithoutUserInput | EcReviewCreateOrConnectWithoutUserInput[]
    createMany?: EcReviewCreateManyUserInputEnvelope
    connect?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
  }

  export type VotingSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VotingSessionCreateWithoutUserInput, VotingSessionUncheckedCreateWithoutUserInput> | VotingSessionCreateWithoutUserInput[] | VotingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VotingSessionCreateOrConnectWithoutUserInput | VotingSessionCreateOrConnectWithoutUserInput[]
    createMany?: VotingSessionCreateManyUserInputEnvelope
    connect?: VotingSessionWhereUniqueInput | VotingSessionWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NominationUpdateManyWithoutAspirantNestedInput = {
    create?: XOR<NominationCreateWithoutAspirantInput, NominationUncheckedCreateWithoutAspirantInput> | NominationCreateWithoutAspirantInput[] | NominationUncheckedCreateWithoutAspirantInput[]
    connectOrCreate?: NominationCreateOrConnectWithoutAspirantInput | NominationCreateOrConnectWithoutAspirantInput[]
    upsert?: NominationUpsertWithWhereUniqueWithoutAspirantInput | NominationUpsertWithWhereUniqueWithoutAspirantInput[]
    createMany?: NominationCreateManyAspirantInputEnvelope
    set?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    disconnect?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    delete?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    connect?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    update?: NominationUpdateWithWhereUniqueWithoutAspirantInput | NominationUpdateWithWhereUniqueWithoutAspirantInput[]
    updateMany?: NominationUpdateManyWithWhereWithoutAspirantInput | NominationUpdateManyWithWhereWithoutAspirantInput[]
    deleteMany?: NominationScalarWhereInput | NominationScalarWhereInput[]
  }

  export type EcReviewUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<EcReviewCreateWithoutReviewerInput, EcReviewUncheckedCreateWithoutReviewerInput> | EcReviewCreateWithoutReviewerInput[] | EcReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: EcReviewCreateOrConnectWithoutReviewerInput | EcReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: EcReviewUpsertWithWhereUniqueWithoutReviewerInput | EcReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: EcReviewCreateManyReviewerInputEnvelope
    set?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    disconnect?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    delete?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    connect?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    update?: EcReviewUpdateWithWhereUniqueWithoutReviewerInput | EcReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: EcReviewUpdateManyWithWhereWithoutReviewerInput | EcReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: EcReviewScalarWhereInput | EcReviewScalarWhereInput[]
  }

  export type NominationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NominationCreateWithoutUserInput, NominationUncheckedCreateWithoutUserInput> | NominationCreateWithoutUserInput[] | NominationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NominationCreateOrConnectWithoutUserInput | NominationCreateOrConnectWithoutUserInput[]
    upsert?: NominationUpsertWithWhereUniqueWithoutUserInput | NominationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NominationCreateManyUserInputEnvelope
    set?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    disconnect?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    delete?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    connect?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    update?: NominationUpdateWithWhereUniqueWithoutUserInput | NominationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NominationUpdateManyWithWhereWithoutUserInput | NominationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NominationScalarWhereInput | NominationScalarWhereInput[]
  }

  export type NominatorVerificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NominatorVerificationCreateWithoutUserInput, NominatorVerificationUncheckedCreateWithoutUserInput> | NominatorVerificationCreateWithoutUserInput[] | NominatorVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NominatorVerificationCreateOrConnectWithoutUserInput | NominatorVerificationCreateOrConnectWithoutUserInput[]
    upsert?: NominatorVerificationUpsertWithWhereUniqueWithoutUserInput | NominatorVerificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NominatorVerificationCreateManyUserInputEnvelope
    set?: NominatorVerificationWhereUniqueInput | NominatorVerificationWhereUniqueInput[]
    disconnect?: NominatorVerificationWhereUniqueInput | NominatorVerificationWhereUniqueInput[]
    delete?: NominatorVerificationWhereUniqueInput | NominatorVerificationWhereUniqueInput[]
    connect?: NominatorVerificationWhereUniqueInput | NominatorVerificationWhereUniqueInput[]
    update?: NominatorVerificationUpdateWithWhereUniqueWithoutUserInput | NominatorVerificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NominatorVerificationUpdateManyWithWhereWithoutUserInput | NominatorVerificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NominatorVerificationScalarWhereInput | NominatorVerificationScalarWhereInput[]
  }

  export type GuarantorVerificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<GuarantorVerificationCreateWithoutUserInput, GuarantorVerificationUncheckedCreateWithoutUserInput> | GuarantorVerificationCreateWithoutUserInput[] | GuarantorVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GuarantorVerificationCreateOrConnectWithoutUserInput | GuarantorVerificationCreateOrConnectWithoutUserInput[]
    upsert?: GuarantorVerificationUpsertWithWhereUniqueWithoutUserInput | GuarantorVerificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GuarantorVerificationCreateManyUserInputEnvelope
    set?: GuarantorVerificationWhereUniqueInput | GuarantorVerificationWhereUniqueInput[]
    disconnect?: GuarantorVerificationWhereUniqueInput | GuarantorVerificationWhereUniqueInput[]
    delete?: GuarantorVerificationWhereUniqueInput | GuarantorVerificationWhereUniqueInput[]
    connect?: GuarantorVerificationWhereUniqueInput | GuarantorVerificationWhereUniqueInput[]
    update?: GuarantorVerificationUpdateWithWhereUniqueWithoutUserInput | GuarantorVerificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GuarantorVerificationUpdateManyWithWhereWithoutUserInput | GuarantorVerificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GuarantorVerificationScalarWhereInput | GuarantorVerificationScalarWhereInput[]
  }

  export type EcReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<EcReviewCreateWithoutUserInput, EcReviewUncheckedCreateWithoutUserInput> | EcReviewCreateWithoutUserInput[] | EcReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EcReviewCreateOrConnectWithoutUserInput | EcReviewCreateOrConnectWithoutUserInput[]
    upsert?: EcReviewUpsertWithWhereUniqueWithoutUserInput | EcReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EcReviewCreateManyUserInputEnvelope
    set?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    disconnect?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    delete?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    connect?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    update?: EcReviewUpdateWithWhereUniqueWithoutUserInput | EcReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EcReviewUpdateManyWithWhereWithoutUserInput | EcReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EcReviewScalarWhereInput | EcReviewScalarWhereInput[]
  }

  export type VotingSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<VotingSessionCreateWithoutUserInput, VotingSessionUncheckedCreateWithoutUserInput> | VotingSessionCreateWithoutUserInput[] | VotingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VotingSessionCreateOrConnectWithoutUserInput | VotingSessionCreateOrConnectWithoutUserInput[]
    upsert?: VotingSessionUpsertWithWhereUniqueWithoutUserInput | VotingSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VotingSessionCreateManyUserInputEnvelope
    set?: VotingSessionWhereUniqueInput | VotingSessionWhereUniqueInput[]
    disconnect?: VotingSessionWhereUniqueInput | VotingSessionWhereUniqueInput[]
    delete?: VotingSessionWhereUniqueInput | VotingSessionWhereUniqueInput[]
    connect?: VotingSessionWhereUniqueInput | VotingSessionWhereUniqueInput[]
    update?: VotingSessionUpdateWithWhereUniqueWithoutUserInput | VotingSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VotingSessionUpdateManyWithWhereWithoutUserInput | VotingSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VotingSessionScalarWhereInput | VotingSessionScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type SubgroupUpdateOneWithoutUsersNestedInput = {
    create?: XOR<SubgroupCreateWithoutUsersInput, SubgroupUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SubgroupCreateOrConnectWithoutUsersInput
    upsert?: SubgroupUpsertWithoutUsersInput
    disconnect?: SubgroupWhereInput | boolean
    delete?: SubgroupWhereInput | boolean
    connect?: SubgroupWhereUniqueInput
    update?: XOR<XOR<SubgroupUpdateToOneWithWhereWithoutUsersInput, SubgroupUpdateWithoutUsersInput>, SubgroupUncheckedUpdateWithoutUsersInput>
  }

  export type NominationUncheckedUpdateManyWithoutAspirantNestedInput = {
    create?: XOR<NominationCreateWithoutAspirantInput, NominationUncheckedCreateWithoutAspirantInput> | NominationCreateWithoutAspirantInput[] | NominationUncheckedCreateWithoutAspirantInput[]
    connectOrCreate?: NominationCreateOrConnectWithoutAspirantInput | NominationCreateOrConnectWithoutAspirantInput[]
    upsert?: NominationUpsertWithWhereUniqueWithoutAspirantInput | NominationUpsertWithWhereUniqueWithoutAspirantInput[]
    createMany?: NominationCreateManyAspirantInputEnvelope
    set?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    disconnect?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    delete?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    connect?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    update?: NominationUpdateWithWhereUniqueWithoutAspirantInput | NominationUpdateWithWhereUniqueWithoutAspirantInput[]
    updateMany?: NominationUpdateManyWithWhereWithoutAspirantInput | NominationUpdateManyWithWhereWithoutAspirantInput[]
    deleteMany?: NominationScalarWhereInput | NominationScalarWhereInput[]
  }

  export type EcReviewUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<EcReviewCreateWithoutReviewerInput, EcReviewUncheckedCreateWithoutReviewerInput> | EcReviewCreateWithoutReviewerInput[] | EcReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: EcReviewCreateOrConnectWithoutReviewerInput | EcReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: EcReviewUpsertWithWhereUniqueWithoutReviewerInput | EcReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: EcReviewCreateManyReviewerInputEnvelope
    set?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    disconnect?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    delete?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    connect?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    update?: EcReviewUpdateWithWhereUniqueWithoutReviewerInput | EcReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: EcReviewUpdateManyWithWhereWithoutReviewerInput | EcReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: EcReviewScalarWhereInput | EcReviewScalarWhereInput[]
  }

  export type NominationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NominationCreateWithoutUserInput, NominationUncheckedCreateWithoutUserInput> | NominationCreateWithoutUserInput[] | NominationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NominationCreateOrConnectWithoutUserInput | NominationCreateOrConnectWithoutUserInput[]
    upsert?: NominationUpsertWithWhereUniqueWithoutUserInput | NominationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NominationCreateManyUserInputEnvelope
    set?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    disconnect?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    delete?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    connect?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    update?: NominationUpdateWithWhereUniqueWithoutUserInput | NominationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NominationUpdateManyWithWhereWithoutUserInput | NominationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NominationScalarWhereInput | NominationScalarWhereInput[]
  }

  export type NominatorVerificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NominatorVerificationCreateWithoutUserInput, NominatorVerificationUncheckedCreateWithoutUserInput> | NominatorVerificationCreateWithoutUserInput[] | NominatorVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NominatorVerificationCreateOrConnectWithoutUserInput | NominatorVerificationCreateOrConnectWithoutUserInput[]
    upsert?: NominatorVerificationUpsertWithWhereUniqueWithoutUserInput | NominatorVerificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NominatorVerificationCreateManyUserInputEnvelope
    set?: NominatorVerificationWhereUniqueInput | NominatorVerificationWhereUniqueInput[]
    disconnect?: NominatorVerificationWhereUniqueInput | NominatorVerificationWhereUniqueInput[]
    delete?: NominatorVerificationWhereUniqueInput | NominatorVerificationWhereUniqueInput[]
    connect?: NominatorVerificationWhereUniqueInput | NominatorVerificationWhereUniqueInput[]
    update?: NominatorVerificationUpdateWithWhereUniqueWithoutUserInput | NominatorVerificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NominatorVerificationUpdateManyWithWhereWithoutUserInput | NominatorVerificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NominatorVerificationScalarWhereInput | NominatorVerificationScalarWhereInput[]
  }

  export type GuarantorVerificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GuarantorVerificationCreateWithoutUserInput, GuarantorVerificationUncheckedCreateWithoutUserInput> | GuarantorVerificationCreateWithoutUserInput[] | GuarantorVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GuarantorVerificationCreateOrConnectWithoutUserInput | GuarantorVerificationCreateOrConnectWithoutUserInput[]
    upsert?: GuarantorVerificationUpsertWithWhereUniqueWithoutUserInput | GuarantorVerificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GuarantorVerificationCreateManyUserInputEnvelope
    set?: GuarantorVerificationWhereUniqueInput | GuarantorVerificationWhereUniqueInput[]
    disconnect?: GuarantorVerificationWhereUniqueInput | GuarantorVerificationWhereUniqueInput[]
    delete?: GuarantorVerificationWhereUniqueInput | GuarantorVerificationWhereUniqueInput[]
    connect?: GuarantorVerificationWhereUniqueInput | GuarantorVerificationWhereUniqueInput[]
    update?: GuarantorVerificationUpdateWithWhereUniqueWithoutUserInput | GuarantorVerificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GuarantorVerificationUpdateManyWithWhereWithoutUserInput | GuarantorVerificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GuarantorVerificationScalarWhereInput | GuarantorVerificationScalarWhereInput[]
  }

  export type EcReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EcReviewCreateWithoutUserInput, EcReviewUncheckedCreateWithoutUserInput> | EcReviewCreateWithoutUserInput[] | EcReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EcReviewCreateOrConnectWithoutUserInput | EcReviewCreateOrConnectWithoutUserInput[]
    upsert?: EcReviewUpsertWithWhereUniqueWithoutUserInput | EcReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EcReviewCreateManyUserInputEnvelope
    set?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    disconnect?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    delete?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    connect?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    update?: EcReviewUpdateWithWhereUniqueWithoutUserInput | EcReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EcReviewUpdateManyWithWhereWithoutUserInput | EcReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EcReviewScalarWhereInput | EcReviewScalarWhereInput[]
  }

  export type VotingSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VotingSessionCreateWithoutUserInput, VotingSessionUncheckedCreateWithoutUserInput> | VotingSessionCreateWithoutUserInput[] | VotingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VotingSessionCreateOrConnectWithoutUserInput | VotingSessionCreateOrConnectWithoutUserInput[]
    upsert?: VotingSessionUpsertWithWhereUniqueWithoutUserInput | VotingSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VotingSessionCreateManyUserInputEnvelope
    set?: VotingSessionWhereUniqueInput | VotingSessionWhereUniqueInput[]
    disconnect?: VotingSessionWhereUniqueInput | VotingSessionWhereUniqueInput[]
    delete?: VotingSessionWhereUniqueInput | VotingSessionWhereUniqueInput[]
    connect?: VotingSessionWhereUniqueInput | VotingSessionWhereUniqueInput[]
    update?: VotingSessionUpdateWithWhereUniqueWithoutUserInput | VotingSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VotingSessionUpdateManyWithWhereWithoutUserInput | VotingSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VotingSessionScalarWhereInput | VotingSessionScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NominationCreatenomineeSubgroupsInput = {
    set: string[]
  }

  export type NominationCreatenomineeEducationInput = {
    set: string[]
  }

  export type NominationCreateleadershipPositionsInput = {
    set: string[]
  }

  export type NominationCreatecommitteesInput = {
    set: string[]
  }

  export type NominationCreateskillsInput = {
    set: string[]
  }

  export type NominationCreatevisionForOfficeInput = {
    set: string[]
  }

  export type NominationCreateknowledgeAboutOfficeInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutNominationsInput = {
    create?: XOR<UserCreateWithoutNominationsInput, UserUncheckedCreateWithoutNominationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNominationsInput
    connect?: UserWhereUniqueInput
  }

  export type NominatorVerificationCreateNestedOneWithoutNominationInput = {
    create?: XOR<NominatorVerificationCreateWithoutNominationInput, NominatorVerificationUncheckedCreateWithoutNominationInput>
    connectOrCreate?: NominatorVerificationCreateOrConnectWithoutNominationInput
    connect?: NominatorVerificationWhereUniqueInput
  }

  export type GuarantorVerificationCreateNestedManyWithoutNominationInput = {
    create?: XOR<GuarantorVerificationCreateWithoutNominationInput, GuarantorVerificationUncheckedCreateWithoutNominationInput> | GuarantorVerificationCreateWithoutNominationInput[] | GuarantorVerificationUncheckedCreateWithoutNominationInput[]
    connectOrCreate?: GuarantorVerificationCreateOrConnectWithoutNominationInput | GuarantorVerificationCreateOrConnectWithoutNominationInput[]
    createMany?: GuarantorVerificationCreateManyNominationInputEnvelope
    connect?: GuarantorVerificationWhereUniqueInput | GuarantorVerificationWhereUniqueInput[]
  }

  export type EcReviewCreateNestedManyWithoutNominationInput = {
    create?: XOR<EcReviewCreateWithoutNominationInput, EcReviewUncheckedCreateWithoutNominationInput> | EcReviewCreateWithoutNominationInput[] | EcReviewUncheckedCreateWithoutNominationInput[]
    connectOrCreate?: EcReviewCreateOrConnectWithoutNominationInput | EcReviewCreateOrConnectWithoutNominationInput[]
    createMany?: EcReviewCreateManyNominationInputEnvelope
    connect?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
  }

  export type CandidateCreateNestedOneWithoutNominationInput = {
    create?: XOR<CandidateCreateWithoutNominationInput, CandidateUncheckedCreateWithoutNominationInput>
    connectOrCreate?: CandidateCreateOrConnectWithoutNominationInput
    connect?: CandidateWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNominationInput = {
    create?: XOR<UserCreateWithoutNominationInput, UserUncheckedCreateWithoutNominationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNominationInput
    connect?: UserWhereUniqueInput
  }

  export type SubgroupCreateNestedOneWithoutNominationsInput = {
    create?: XOR<SubgroupCreateWithoutNominationsInput, SubgroupUncheckedCreateWithoutNominationsInput>
    connectOrCreate?: SubgroupCreateOrConnectWithoutNominationsInput
    connect?: SubgroupWhereUniqueInput
  }

  export type NominatorVerificationUncheckedCreateNestedOneWithoutNominationInput = {
    create?: XOR<NominatorVerificationCreateWithoutNominationInput, NominatorVerificationUncheckedCreateWithoutNominationInput>
    connectOrCreate?: NominatorVerificationCreateOrConnectWithoutNominationInput
    connect?: NominatorVerificationWhereUniqueInput
  }

  export type GuarantorVerificationUncheckedCreateNestedManyWithoutNominationInput = {
    create?: XOR<GuarantorVerificationCreateWithoutNominationInput, GuarantorVerificationUncheckedCreateWithoutNominationInput> | GuarantorVerificationCreateWithoutNominationInput[] | GuarantorVerificationUncheckedCreateWithoutNominationInput[]
    connectOrCreate?: GuarantorVerificationCreateOrConnectWithoutNominationInput | GuarantorVerificationCreateOrConnectWithoutNominationInput[]
    createMany?: GuarantorVerificationCreateManyNominationInputEnvelope
    connect?: GuarantorVerificationWhereUniqueInput | GuarantorVerificationWhereUniqueInput[]
  }

  export type EcReviewUncheckedCreateNestedManyWithoutNominationInput = {
    create?: XOR<EcReviewCreateWithoutNominationInput, EcReviewUncheckedCreateWithoutNominationInput> | EcReviewCreateWithoutNominationInput[] | EcReviewUncheckedCreateWithoutNominationInput[]
    connectOrCreate?: EcReviewCreateOrConnectWithoutNominationInput | EcReviewCreateOrConnectWithoutNominationInput[]
    createMany?: EcReviewCreateManyNominationInputEnvelope
    connect?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
  }

  export type CandidateUncheckedCreateNestedOneWithoutNominationInput = {
    create?: XOR<CandidateCreateWithoutNominationInput, CandidateUncheckedCreateWithoutNominationInput>
    connectOrCreate?: CandidateCreateOrConnectWithoutNominationInput
    connect?: CandidateWhereUniqueInput
  }

  export type EnumCandidate_PositionFieldUpdateOperationsInput = {
    set?: $Enums.Candidate_Position
  }

  export type EnumNominationStatusFieldUpdateOperationsInput = {
    set?: $Enums.NominationStatus
  }

  export type NominationUpdatenomineeSubgroupsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NominationUpdatenomineeEducationInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NominationUpdateleadershipPositionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NominationUpdatecommitteesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NominationUpdateskillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NominationUpdatevisionForOfficeInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NominationUpdateknowledgeAboutOfficeInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutNominationsNestedInput = {
    create?: XOR<UserCreateWithoutNominationsInput, UserUncheckedCreateWithoutNominationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNominationsInput
    upsert?: UserUpsertWithoutNominationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNominationsInput, UserUpdateWithoutNominationsInput>, UserUncheckedUpdateWithoutNominationsInput>
  }

  export type NominatorVerificationUpdateOneWithoutNominationNestedInput = {
    create?: XOR<NominatorVerificationCreateWithoutNominationInput, NominatorVerificationUncheckedCreateWithoutNominationInput>
    connectOrCreate?: NominatorVerificationCreateOrConnectWithoutNominationInput
    upsert?: NominatorVerificationUpsertWithoutNominationInput
    disconnect?: NominatorVerificationWhereInput | boolean
    delete?: NominatorVerificationWhereInput | boolean
    connect?: NominatorVerificationWhereUniqueInput
    update?: XOR<XOR<NominatorVerificationUpdateToOneWithWhereWithoutNominationInput, NominatorVerificationUpdateWithoutNominationInput>, NominatorVerificationUncheckedUpdateWithoutNominationInput>
  }

  export type GuarantorVerificationUpdateManyWithoutNominationNestedInput = {
    create?: XOR<GuarantorVerificationCreateWithoutNominationInput, GuarantorVerificationUncheckedCreateWithoutNominationInput> | GuarantorVerificationCreateWithoutNominationInput[] | GuarantorVerificationUncheckedCreateWithoutNominationInput[]
    connectOrCreate?: GuarantorVerificationCreateOrConnectWithoutNominationInput | GuarantorVerificationCreateOrConnectWithoutNominationInput[]
    upsert?: GuarantorVerificationUpsertWithWhereUniqueWithoutNominationInput | GuarantorVerificationUpsertWithWhereUniqueWithoutNominationInput[]
    createMany?: GuarantorVerificationCreateManyNominationInputEnvelope
    set?: GuarantorVerificationWhereUniqueInput | GuarantorVerificationWhereUniqueInput[]
    disconnect?: GuarantorVerificationWhereUniqueInput | GuarantorVerificationWhereUniqueInput[]
    delete?: GuarantorVerificationWhereUniqueInput | GuarantorVerificationWhereUniqueInput[]
    connect?: GuarantorVerificationWhereUniqueInput | GuarantorVerificationWhereUniqueInput[]
    update?: GuarantorVerificationUpdateWithWhereUniqueWithoutNominationInput | GuarantorVerificationUpdateWithWhereUniqueWithoutNominationInput[]
    updateMany?: GuarantorVerificationUpdateManyWithWhereWithoutNominationInput | GuarantorVerificationUpdateManyWithWhereWithoutNominationInput[]
    deleteMany?: GuarantorVerificationScalarWhereInput | GuarantorVerificationScalarWhereInput[]
  }

  export type EcReviewUpdateManyWithoutNominationNestedInput = {
    create?: XOR<EcReviewCreateWithoutNominationInput, EcReviewUncheckedCreateWithoutNominationInput> | EcReviewCreateWithoutNominationInput[] | EcReviewUncheckedCreateWithoutNominationInput[]
    connectOrCreate?: EcReviewCreateOrConnectWithoutNominationInput | EcReviewCreateOrConnectWithoutNominationInput[]
    upsert?: EcReviewUpsertWithWhereUniqueWithoutNominationInput | EcReviewUpsertWithWhereUniqueWithoutNominationInput[]
    createMany?: EcReviewCreateManyNominationInputEnvelope
    set?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    disconnect?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    delete?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    connect?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    update?: EcReviewUpdateWithWhereUniqueWithoutNominationInput | EcReviewUpdateWithWhereUniqueWithoutNominationInput[]
    updateMany?: EcReviewUpdateManyWithWhereWithoutNominationInput | EcReviewUpdateManyWithWhereWithoutNominationInput[]
    deleteMany?: EcReviewScalarWhereInput | EcReviewScalarWhereInput[]
  }

  export type CandidateUpdateOneWithoutNominationNestedInput = {
    create?: XOR<CandidateCreateWithoutNominationInput, CandidateUncheckedCreateWithoutNominationInput>
    connectOrCreate?: CandidateCreateOrConnectWithoutNominationInput
    upsert?: CandidateUpsertWithoutNominationInput
    disconnect?: CandidateWhereInput | boolean
    delete?: CandidateWhereInput | boolean
    connect?: CandidateWhereUniqueInput
    update?: XOR<XOR<CandidateUpdateToOneWithWhereWithoutNominationInput, CandidateUpdateWithoutNominationInput>, CandidateUncheckedUpdateWithoutNominationInput>
  }

  export type UserUpdateOneWithoutNominationNestedInput = {
    create?: XOR<UserCreateWithoutNominationInput, UserUncheckedCreateWithoutNominationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNominationInput
    upsert?: UserUpsertWithoutNominationInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNominationInput, UserUpdateWithoutNominationInput>, UserUncheckedUpdateWithoutNominationInput>
  }

  export type SubgroupUpdateOneWithoutNominationsNestedInput = {
    create?: XOR<SubgroupCreateWithoutNominationsInput, SubgroupUncheckedCreateWithoutNominationsInput>
    connectOrCreate?: SubgroupCreateOrConnectWithoutNominationsInput
    upsert?: SubgroupUpsertWithoutNominationsInput
    disconnect?: SubgroupWhereInput | boolean
    delete?: SubgroupWhereInput | boolean
    connect?: SubgroupWhereUniqueInput
    update?: XOR<XOR<SubgroupUpdateToOneWithWhereWithoutNominationsInput, SubgroupUpdateWithoutNominationsInput>, SubgroupUncheckedUpdateWithoutNominationsInput>
  }

  export type NominatorVerificationUncheckedUpdateOneWithoutNominationNestedInput = {
    create?: XOR<NominatorVerificationCreateWithoutNominationInput, NominatorVerificationUncheckedCreateWithoutNominationInput>
    connectOrCreate?: NominatorVerificationCreateOrConnectWithoutNominationInput
    upsert?: NominatorVerificationUpsertWithoutNominationInput
    disconnect?: NominatorVerificationWhereInput | boolean
    delete?: NominatorVerificationWhereInput | boolean
    connect?: NominatorVerificationWhereUniqueInput
    update?: XOR<XOR<NominatorVerificationUpdateToOneWithWhereWithoutNominationInput, NominatorVerificationUpdateWithoutNominationInput>, NominatorVerificationUncheckedUpdateWithoutNominationInput>
  }

  export type GuarantorVerificationUncheckedUpdateManyWithoutNominationNestedInput = {
    create?: XOR<GuarantorVerificationCreateWithoutNominationInput, GuarantorVerificationUncheckedCreateWithoutNominationInput> | GuarantorVerificationCreateWithoutNominationInput[] | GuarantorVerificationUncheckedCreateWithoutNominationInput[]
    connectOrCreate?: GuarantorVerificationCreateOrConnectWithoutNominationInput | GuarantorVerificationCreateOrConnectWithoutNominationInput[]
    upsert?: GuarantorVerificationUpsertWithWhereUniqueWithoutNominationInput | GuarantorVerificationUpsertWithWhereUniqueWithoutNominationInput[]
    createMany?: GuarantorVerificationCreateManyNominationInputEnvelope
    set?: GuarantorVerificationWhereUniqueInput | GuarantorVerificationWhereUniqueInput[]
    disconnect?: GuarantorVerificationWhereUniqueInput | GuarantorVerificationWhereUniqueInput[]
    delete?: GuarantorVerificationWhereUniqueInput | GuarantorVerificationWhereUniqueInput[]
    connect?: GuarantorVerificationWhereUniqueInput | GuarantorVerificationWhereUniqueInput[]
    update?: GuarantorVerificationUpdateWithWhereUniqueWithoutNominationInput | GuarantorVerificationUpdateWithWhereUniqueWithoutNominationInput[]
    updateMany?: GuarantorVerificationUpdateManyWithWhereWithoutNominationInput | GuarantorVerificationUpdateManyWithWhereWithoutNominationInput[]
    deleteMany?: GuarantorVerificationScalarWhereInput | GuarantorVerificationScalarWhereInput[]
  }

  export type EcReviewUncheckedUpdateManyWithoutNominationNestedInput = {
    create?: XOR<EcReviewCreateWithoutNominationInput, EcReviewUncheckedCreateWithoutNominationInput> | EcReviewCreateWithoutNominationInput[] | EcReviewUncheckedCreateWithoutNominationInput[]
    connectOrCreate?: EcReviewCreateOrConnectWithoutNominationInput | EcReviewCreateOrConnectWithoutNominationInput[]
    upsert?: EcReviewUpsertWithWhereUniqueWithoutNominationInput | EcReviewUpsertWithWhereUniqueWithoutNominationInput[]
    createMany?: EcReviewCreateManyNominationInputEnvelope
    set?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    disconnect?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    delete?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    connect?: EcReviewWhereUniqueInput | EcReviewWhereUniqueInput[]
    update?: EcReviewUpdateWithWhereUniqueWithoutNominationInput | EcReviewUpdateWithWhereUniqueWithoutNominationInput[]
    updateMany?: EcReviewUpdateManyWithWhereWithoutNominationInput | EcReviewUpdateManyWithWhereWithoutNominationInput[]
    deleteMany?: EcReviewScalarWhereInput | EcReviewScalarWhereInput[]
  }

  export type CandidateUncheckedUpdateOneWithoutNominationNestedInput = {
    create?: XOR<CandidateCreateWithoutNominationInput, CandidateUncheckedCreateWithoutNominationInput>
    connectOrCreate?: CandidateCreateOrConnectWithoutNominationInput
    upsert?: CandidateUpsertWithoutNominationInput
    disconnect?: CandidateWhereInput | boolean
    delete?: CandidateWhereInput | boolean
    connect?: CandidateWhereUniqueInput
    update?: XOR<XOR<CandidateUpdateToOneWithWhereWithoutNominationInput, CandidateUpdateWithoutNominationInput>, CandidateUncheckedUpdateWithoutNominationInput>
  }

  export type NominationCreateNestedOneWithoutNominatorVerificationInput = {
    create?: XOR<NominationCreateWithoutNominatorVerificationInput, NominationUncheckedCreateWithoutNominatorVerificationInput>
    connectOrCreate?: NominationCreateOrConnectWithoutNominatorVerificationInput
    connect?: NominationWhereUniqueInput
  }

  export type VerificationTokenCreateNestedOneWithoutNominatorVerificationInput = {
    create?: XOR<VerificationTokenCreateWithoutNominatorVerificationInput, VerificationTokenUncheckedCreateWithoutNominatorVerificationInput>
    connectOrCreate?: VerificationTokenCreateOrConnectWithoutNominatorVerificationInput
    connect?: VerificationTokenWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNominatorVerificationInput = {
    create?: XOR<UserCreateWithoutNominatorVerificationInput, UserUncheckedCreateWithoutNominatorVerificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNominatorVerificationInput
    connect?: UserWhereUniqueInput
  }

  export type VerificationTokenUncheckedCreateNestedOneWithoutNominatorVerificationInput = {
    create?: XOR<VerificationTokenCreateWithoutNominatorVerificationInput, VerificationTokenUncheckedCreateWithoutNominatorVerificationInput>
    connectOrCreate?: VerificationTokenCreateOrConnectWithoutNominatorVerificationInput
    connect?: VerificationTokenWhereUniqueInput
  }

  export type NominationUpdateOneRequiredWithoutNominatorVerificationNestedInput = {
    create?: XOR<NominationCreateWithoutNominatorVerificationInput, NominationUncheckedCreateWithoutNominatorVerificationInput>
    connectOrCreate?: NominationCreateOrConnectWithoutNominatorVerificationInput
    upsert?: NominationUpsertWithoutNominatorVerificationInput
    connect?: NominationWhereUniqueInput
    update?: XOR<XOR<NominationUpdateToOneWithWhereWithoutNominatorVerificationInput, NominationUpdateWithoutNominatorVerificationInput>, NominationUncheckedUpdateWithoutNominatorVerificationInput>
  }

  export type VerificationTokenUpdateOneWithoutNominatorVerificationNestedInput = {
    create?: XOR<VerificationTokenCreateWithoutNominatorVerificationInput, VerificationTokenUncheckedCreateWithoutNominatorVerificationInput>
    connectOrCreate?: VerificationTokenCreateOrConnectWithoutNominatorVerificationInput
    upsert?: VerificationTokenUpsertWithoutNominatorVerificationInput
    disconnect?: VerificationTokenWhereInput | boolean
    delete?: VerificationTokenWhereInput | boolean
    connect?: VerificationTokenWhereUniqueInput
    update?: XOR<XOR<VerificationTokenUpdateToOneWithWhereWithoutNominatorVerificationInput, VerificationTokenUpdateWithoutNominatorVerificationInput>, VerificationTokenUncheckedUpdateWithoutNominatorVerificationInput>
  }

  export type UserUpdateOneWithoutNominatorVerificationNestedInput = {
    create?: XOR<UserCreateWithoutNominatorVerificationInput, UserUncheckedCreateWithoutNominatorVerificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNominatorVerificationInput
    upsert?: UserUpsertWithoutNominatorVerificationInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNominatorVerificationInput, UserUpdateWithoutNominatorVerificationInput>, UserUncheckedUpdateWithoutNominatorVerificationInput>
  }

  export type VerificationTokenUncheckedUpdateOneWithoutNominatorVerificationNestedInput = {
    create?: XOR<VerificationTokenCreateWithoutNominatorVerificationInput, VerificationTokenUncheckedCreateWithoutNominatorVerificationInput>
    connectOrCreate?: VerificationTokenCreateOrConnectWithoutNominatorVerificationInput
    upsert?: VerificationTokenUpsertWithoutNominatorVerificationInput
    disconnect?: VerificationTokenWhereInput | boolean
    delete?: VerificationTokenWhereInput | boolean
    connect?: VerificationTokenWhereUniqueInput
    update?: XOR<XOR<VerificationTokenUpdateToOneWithWhereWithoutNominatorVerificationInput, VerificationTokenUpdateWithoutNominatorVerificationInput>, VerificationTokenUncheckedUpdateWithoutNominatorVerificationInput>
  }

  export type NominationCreateNestedOneWithoutGuarantorVerificationsInput = {
    create?: XOR<NominationCreateWithoutGuarantorVerificationsInput, NominationUncheckedCreateWithoutGuarantorVerificationsInput>
    connectOrCreate?: NominationCreateOrConnectWithoutGuarantorVerificationsInput
    connect?: NominationWhereUniqueInput
  }

  export type VerificationTokenCreateNestedOneWithoutGuarantorVerificationInput = {
    create?: XOR<VerificationTokenCreateWithoutGuarantorVerificationInput, VerificationTokenUncheckedCreateWithoutGuarantorVerificationInput>
    connectOrCreate?: VerificationTokenCreateOrConnectWithoutGuarantorVerificationInput
    connect?: VerificationTokenWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGuarantorVerificationInput = {
    create?: XOR<UserCreateWithoutGuarantorVerificationInput, UserUncheckedCreateWithoutGuarantorVerificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutGuarantorVerificationInput
    connect?: UserWhereUniqueInput
  }

  export type VerificationTokenUncheckedCreateNestedOneWithoutGuarantorVerificationInput = {
    create?: XOR<VerificationTokenCreateWithoutGuarantorVerificationInput, VerificationTokenUncheckedCreateWithoutGuarantorVerificationInput>
    connectOrCreate?: VerificationTokenCreateOrConnectWithoutGuarantorVerificationInput
    connect?: VerificationTokenWhereUniqueInput
  }

  export type NominationUpdateOneRequiredWithoutGuarantorVerificationsNestedInput = {
    create?: XOR<NominationCreateWithoutGuarantorVerificationsInput, NominationUncheckedCreateWithoutGuarantorVerificationsInput>
    connectOrCreate?: NominationCreateOrConnectWithoutGuarantorVerificationsInput
    upsert?: NominationUpsertWithoutGuarantorVerificationsInput
    connect?: NominationWhereUniqueInput
    update?: XOR<XOR<NominationUpdateToOneWithWhereWithoutGuarantorVerificationsInput, NominationUpdateWithoutGuarantorVerificationsInput>, NominationUncheckedUpdateWithoutGuarantorVerificationsInput>
  }

  export type VerificationTokenUpdateOneWithoutGuarantorVerificationNestedInput = {
    create?: XOR<VerificationTokenCreateWithoutGuarantorVerificationInput, VerificationTokenUncheckedCreateWithoutGuarantorVerificationInput>
    connectOrCreate?: VerificationTokenCreateOrConnectWithoutGuarantorVerificationInput
    upsert?: VerificationTokenUpsertWithoutGuarantorVerificationInput
    disconnect?: VerificationTokenWhereInput | boolean
    delete?: VerificationTokenWhereInput | boolean
    connect?: VerificationTokenWhereUniqueInput
    update?: XOR<XOR<VerificationTokenUpdateToOneWithWhereWithoutGuarantorVerificationInput, VerificationTokenUpdateWithoutGuarantorVerificationInput>, VerificationTokenUncheckedUpdateWithoutGuarantorVerificationInput>
  }

  export type UserUpdateOneWithoutGuarantorVerificationNestedInput = {
    create?: XOR<UserCreateWithoutGuarantorVerificationInput, UserUncheckedCreateWithoutGuarantorVerificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutGuarantorVerificationInput
    upsert?: UserUpsertWithoutGuarantorVerificationInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGuarantorVerificationInput, UserUpdateWithoutGuarantorVerificationInput>, UserUncheckedUpdateWithoutGuarantorVerificationInput>
  }

  export type VerificationTokenUncheckedUpdateOneWithoutGuarantorVerificationNestedInput = {
    create?: XOR<VerificationTokenCreateWithoutGuarantorVerificationInput, VerificationTokenUncheckedCreateWithoutGuarantorVerificationInput>
    connectOrCreate?: VerificationTokenCreateOrConnectWithoutGuarantorVerificationInput
    upsert?: VerificationTokenUpsertWithoutGuarantorVerificationInput
    disconnect?: VerificationTokenWhereInput | boolean
    delete?: VerificationTokenWhereInput | boolean
    connect?: VerificationTokenWhereUniqueInput
    update?: XOR<XOR<VerificationTokenUpdateToOneWithWhereWithoutGuarantorVerificationInput, VerificationTokenUpdateWithoutGuarantorVerificationInput>, VerificationTokenUncheckedUpdateWithoutGuarantorVerificationInput>
  }

  export type NominationCreateNestedOneWithoutEcReviewInput = {
    create?: XOR<NominationCreateWithoutEcReviewInput, NominationUncheckedCreateWithoutEcReviewInput>
    connectOrCreate?: NominationCreateOrConnectWithoutEcReviewInput
    connect?: NominationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEcReviewsInput = {
    create?: XOR<UserCreateWithoutEcReviewsInput, UserUncheckedCreateWithoutEcReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEcReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEcReviewInput = {
    create?: XOR<UserCreateWithoutEcReviewInput, UserUncheckedCreateWithoutEcReviewInput>
    connectOrCreate?: UserCreateOrConnectWithoutEcReviewInput
    connect?: UserWhereUniqueInput
  }

  export type NominationUpdateOneRequiredWithoutEcReviewNestedInput = {
    create?: XOR<NominationCreateWithoutEcReviewInput, NominationUncheckedCreateWithoutEcReviewInput>
    connectOrCreate?: NominationCreateOrConnectWithoutEcReviewInput
    upsert?: NominationUpsertWithoutEcReviewInput
    connect?: NominationWhereUniqueInput
    update?: XOR<XOR<NominationUpdateToOneWithWhereWithoutEcReviewInput, NominationUpdateWithoutEcReviewInput>, NominationUncheckedUpdateWithoutEcReviewInput>
  }

  export type UserUpdateOneRequiredWithoutEcReviewsNestedInput = {
    create?: XOR<UserCreateWithoutEcReviewsInput, UserUncheckedCreateWithoutEcReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEcReviewsInput
    upsert?: UserUpsertWithoutEcReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEcReviewsInput, UserUpdateWithoutEcReviewsInput>, UserUncheckedUpdateWithoutEcReviewsInput>
  }

  export type UserUpdateOneWithoutEcReviewNestedInput = {
    create?: XOR<UserCreateWithoutEcReviewInput, UserUncheckedCreateWithoutEcReviewInput>
    connectOrCreate?: UserCreateOrConnectWithoutEcReviewInput
    upsert?: UserUpsertWithoutEcReviewInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEcReviewInput, UserUpdateWithoutEcReviewInput>, UserUncheckedUpdateWithoutEcReviewInput>
  }

  export type NominatorVerificationCreateNestedOneWithoutVerificationTokenInput = {
    create?: XOR<NominatorVerificationCreateWithoutVerificationTokenInput, NominatorVerificationUncheckedCreateWithoutVerificationTokenInput>
    connectOrCreate?: NominatorVerificationCreateOrConnectWithoutVerificationTokenInput
    connect?: NominatorVerificationWhereUniqueInput
  }

  export type GuarantorVerificationCreateNestedOneWithoutVerificationTokenInput = {
    create?: XOR<GuarantorVerificationCreateWithoutVerificationTokenInput, GuarantorVerificationUncheckedCreateWithoutVerificationTokenInput>
    connectOrCreate?: GuarantorVerificationCreateOrConnectWithoutVerificationTokenInput
    connect?: GuarantorVerificationWhereUniqueInput
  }

  export type EnumTokenTypeFieldUpdateOperationsInput = {
    set?: $Enums.TokenType
  }

  export type NominatorVerificationUpdateOneWithoutVerificationTokenNestedInput = {
    create?: XOR<NominatorVerificationCreateWithoutVerificationTokenInput, NominatorVerificationUncheckedCreateWithoutVerificationTokenInput>
    connectOrCreate?: NominatorVerificationCreateOrConnectWithoutVerificationTokenInput
    upsert?: NominatorVerificationUpsertWithoutVerificationTokenInput
    disconnect?: NominatorVerificationWhereInput | boolean
    delete?: NominatorVerificationWhereInput | boolean
    connect?: NominatorVerificationWhereUniqueInput
    update?: XOR<XOR<NominatorVerificationUpdateToOneWithWhereWithoutVerificationTokenInput, NominatorVerificationUpdateWithoutVerificationTokenInput>, NominatorVerificationUncheckedUpdateWithoutVerificationTokenInput>
  }

  export type GuarantorVerificationUpdateOneWithoutVerificationTokenNestedInput = {
    create?: XOR<GuarantorVerificationCreateWithoutVerificationTokenInput, GuarantorVerificationUncheckedCreateWithoutVerificationTokenInput>
    connectOrCreate?: GuarantorVerificationCreateOrConnectWithoutVerificationTokenInput
    upsert?: GuarantorVerificationUpsertWithoutVerificationTokenInput
    disconnect?: GuarantorVerificationWhereInput | boolean
    delete?: GuarantorVerificationWhereInput | boolean
    connect?: GuarantorVerificationWhereUniqueInput
    update?: XOR<XOR<GuarantorVerificationUpdateToOneWithWhereWithoutVerificationTokenInput, GuarantorVerificationUpdateWithoutVerificationTokenInput>, GuarantorVerificationUncheckedUpdateWithoutVerificationTokenInput>
  }

  export type NominationCreateNestedOneWithoutCandidateInput = {
    create?: XOR<NominationCreateWithoutCandidateInput, NominationUncheckedCreateWithoutCandidateInput>
    connectOrCreate?: NominationCreateOrConnectWithoutCandidateInput
    connect?: NominationWhereUniqueInput
  }

  export type NominationUpdateOneRequiredWithoutCandidateNestedInput = {
    create?: XOR<NominationCreateWithoutCandidateInput, NominationUncheckedCreateWithoutCandidateInput>
    connectOrCreate?: NominationCreateOrConnectWithoutCandidateInput
    upsert?: NominationUpsertWithoutCandidateInput
    connect?: NominationWhereUniqueInput
    update?: XOR<XOR<NominationUpdateToOneWithWhereWithoutCandidateInput, NominationUpdateWithoutCandidateInput>, NominationUncheckedUpdateWithoutCandidateInput>
  }

  export type UserCreateNestedOneWithoutVotingSessionInput = {
    create?: XOR<UserCreateWithoutVotingSessionInput, UserUncheckedCreateWithoutVotingSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutVotingSessionInput
    connect?: UserWhereUniqueInput
  }

  export type VoteCreateNestedManyWithoutSessionInput = {
    create?: XOR<VoteCreateWithoutSessionInput, VoteUncheckedCreateWithoutSessionInput> | VoteCreateWithoutSessionInput[] | VoteUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutSessionInput | VoteCreateOrConnectWithoutSessionInput[]
    createMany?: VoteCreateManySessionInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type VoteUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<VoteCreateWithoutSessionInput, VoteUncheckedCreateWithoutSessionInput> | VoteCreateWithoutSessionInput[] | VoteUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutSessionInput | VoteCreateOrConnectWithoutSessionInput[]
    createMany?: VoteCreateManySessionInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type EnumVotingStatusFieldUpdateOperationsInput = {
    set?: $Enums.VotingStatus
  }

  export type UserUpdateOneRequiredWithoutVotingSessionNestedInput = {
    create?: XOR<UserCreateWithoutVotingSessionInput, UserUncheckedCreateWithoutVotingSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutVotingSessionInput
    upsert?: UserUpsertWithoutVotingSessionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVotingSessionInput, UserUpdateWithoutVotingSessionInput>, UserUncheckedUpdateWithoutVotingSessionInput>
  }

  export type VoteUpdateManyWithoutSessionNestedInput = {
    create?: XOR<VoteCreateWithoutSessionInput, VoteUncheckedCreateWithoutSessionInput> | VoteCreateWithoutSessionInput[] | VoteUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutSessionInput | VoteCreateOrConnectWithoutSessionInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutSessionInput | VoteUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: VoteCreateManySessionInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutSessionInput | VoteUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutSessionInput | VoteUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type VoteUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<VoteCreateWithoutSessionInput, VoteUncheckedCreateWithoutSessionInput> | VoteCreateWithoutSessionInput[] | VoteUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutSessionInput | VoteCreateOrConnectWithoutSessionInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutSessionInput | VoteUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: VoteCreateManySessionInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutSessionInput | VoteUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutSessionInput | VoteUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type VotingSessionCreateNestedOneWithoutVotesInput = {
    create?: XOR<VotingSessionCreateWithoutVotesInput, VotingSessionUncheckedCreateWithoutVotesInput>
    connectOrCreate?: VotingSessionCreateOrConnectWithoutVotesInput
    connect?: VotingSessionWhereUniqueInput
  }

  export type VotingSessionUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<VotingSessionCreateWithoutVotesInput, VotingSessionUncheckedCreateWithoutVotesInput>
    connectOrCreate?: VotingSessionCreateOrConnectWithoutVotesInput
    upsert?: VotingSessionUpsertWithoutVotesInput
    connect?: VotingSessionWhereUniqueInput
    update?: XOR<XOR<VotingSessionUpdateToOneWithWhereWithoutVotesInput, VotingSessionUpdateWithoutVotesInput>, VotingSessionUncheckedUpdateWithoutVotesInput>
  }

  export type UserCreateNestedOneWithoutAuditLogInput = {
    create?: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogInput
    upsert?: UserUpsertWithoutAuditLogInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogInput, UserUpdateWithoutAuditLogInput>, UserUncheckedUpdateWithoutAuditLogInput>
  }

  export type UserCreateNestedManyWithoutSubgroupInput = {
    create?: XOR<UserCreateWithoutSubgroupInput, UserUncheckedCreateWithoutSubgroupInput> | UserCreateWithoutSubgroupInput[] | UserUncheckedCreateWithoutSubgroupInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSubgroupInput | UserCreateOrConnectWithoutSubgroupInput[]
    createMany?: UserCreateManySubgroupInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type NominationCreateNestedManyWithoutSubgroupInput = {
    create?: XOR<NominationCreateWithoutSubgroupInput, NominationUncheckedCreateWithoutSubgroupInput> | NominationCreateWithoutSubgroupInput[] | NominationUncheckedCreateWithoutSubgroupInput[]
    connectOrCreate?: NominationCreateOrConnectWithoutSubgroupInput | NominationCreateOrConnectWithoutSubgroupInput[]
    createMany?: NominationCreateManySubgroupInputEnvelope
    connect?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSubgroupInput = {
    create?: XOR<UserCreateWithoutSubgroupInput, UserUncheckedCreateWithoutSubgroupInput> | UserCreateWithoutSubgroupInput[] | UserUncheckedCreateWithoutSubgroupInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSubgroupInput | UserCreateOrConnectWithoutSubgroupInput[]
    createMany?: UserCreateManySubgroupInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type NominationUncheckedCreateNestedManyWithoutSubgroupInput = {
    create?: XOR<NominationCreateWithoutSubgroupInput, NominationUncheckedCreateWithoutSubgroupInput> | NominationCreateWithoutSubgroupInput[] | NominationUncheckedCreateWithoutSubgroupInput[]
    connectOrCreate?: NominationCreateOrConnectWithoutSubgroupInput | NominationCreateOrConnectWithoutSubgroupInput[]
    createMany?: NominationCreateManySubgroupInputEnvelope
    connect?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutSubgroupNestedInput = {
    create?: XOR<UserCreateWithoutSubgroupInput, UserUncheckedCreateWithoutSubgroupInput> | UserCreateWithoutSubgroupInput[] | UserUncheckedCreateWithoutSubgroupInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSubgroupInput | UserCreateOrConnectWithoutSubgroupInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSubgroupInput | UserUpsertWithWhereUniqueWithoutSubgroupInput[]
    createMany?: UserCreateManySubgroupInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSubgroupInput | UserUpdateWithWhereUniqueWithoutSubgroupInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSubgroupInput | UserUpdateManyWithWhereWithoutSubgroupInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type NominationUpdateManyWithoutSubgroupNestedInput = {
    create?: XOR<NominationCreateWithoutSubgroupInput, NominationUncheckedCreateWithoutSubgroupInput> | NominationCreateWithoutSubgroupInput[] | NominationUncheckedCreateWithoutSubgroupInput[]
    connectOrCreate?: NominationCreateOrConnectWithoutSubgroupInput | NominationCreateOrConnectWithoutSubgroupInput[]
    upsert?: NominationUpsertWithWhereUniqueWithoutSubgroupInput | NominationUpsertWithWhereUniqueWithoutSubgroupInput[]
    createMany?: NominationCreateManySubgroupInputEnvelope
    set?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    disconnect?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    delete?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    connect?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    update?: NominationUpdateWithWhereUniqueWithoutSubgroupInput | NominationUpdateWithWhereUniqueWithoutSubgroupInput[]
    updateMany?: NominationUpdateManyWithWhereWithoutSubgroupInput | NominationUpdateManyWithWhereWithoutSubgroupInput[]
    deleteMany?: NominationScalarWhereInput | NominationScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSubgroupNestedInput = {
    create?: XOR<UserCreateWithoutSubgroupInput, UserUncheckedCreateWithoutSubgroupInput> | UserCreateWithoutSubgroupInput[] | UserUncheckedCreateWithoutSubgroupInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSubgroupInput | UserCreateOrConnectWithoutSubgroupInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSubgroupInput | UserUpsertWithWhereUniqueWithoutSubgroupInput[]
    createMany?: UserCreateManySubgroupInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSubgroupInput | UserUpdateWithWhereUniqueWithoutSubgroupInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSubgroupInput | UserUpdateManyWithWhereWithoutSubgroupInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type NominationUncheckedUpdateManyWithoutSubgroupNestedInput = {
    create?: XOR<NominationCreateWithoutSubgroupInput, NominationUncheckedCreateWithoutSubgroupInput> | NominationCreateWithoutSubgroupInput[] | NominationUncheckedCreateWithoutSubgroupInput[]
    connectOrCreate?: NominationCreateOrConnectWithoutSubgroupInput | NominationCreateOrConnectWithoutSubgroupInput[]
    upsert?: NominationUpsertWithWhereUniqueWithoutSubgroupInput | NominationUpsertWithWhereUniqueWithoutSubgroupInput[]
    createMany?: NominationCreateManySubgroupInputEnvelope
    set?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    disconnect?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    delete?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    connect?: NominationWhereUniqueInput | NominationWhereUniqueInput[]
    update?: NominationUpdateWithWhereUniqueWithoutSubgroupInput | NominationUpdateWithWhereUniqueWithoutSubgroupInput[]
    updateMany?: NominationUpdateManyWithWhereWithoutSubgroupInput | NominationUpdateManyWithWhereWithoutSubgroupInput[]
    deleteMany?: NominationScalarWhereInput | NominationScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumCandidate_PositionFilter<$PrismaModel = never> = {
    equals?: $Enums.Candidate_Position | EnumCandidate_PositionFieldRefInput<$PrismaModel>
    in?: $Enums.Candidate_Position[] | ListEnumCandidate_PositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Candidate_Position[] | ListEnumCandidate_PositionFieldRefInput<$PrismaModel>
    not?: NestedEnumCandidate_PositionFilter<$PrismaModel> | $Enums.Candidate_Position
  }

  export type NestedEnumNominationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NominationStatus | EnumNominationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NominationStatus[] | ListEnumNominationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NominationStatus[] | ListEnumNominationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNominationStatusFilter<$PrismaModel> | $Enums.NominationStatus
  }

  export type NestedEnumCandidate_PositionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Candidate_Position | EnumCandidate_PositionFieldRefInput<$PrismaModel>
    in?: $Enums.Candidate_Position[] | ListEnumCandidate_PositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Candidate_Position[] | ListEnumCandidate_PositionFieldRefInput<$PrismaModel>
    not?: NestedEnumCandidate_PositionWithAggregatesFilter<$PrismaModel> | $Enums.Candidate_Position
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCandidate_PositionFilter<$PrismaModel>
    _max?: NestedEnumCandidate_PositionFilter<$PrismaModel>
  }

  export type NestedEnumNominationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NominationStatus | EnumNominationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NominationStatus[] | ListEnumNominationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NominationStatus[] | ListEnumNominationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNominationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NominationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNominationStatusFilter<$PrismaModel>
    _max?: NestedEnumNominationStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumTokenTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenTypeFilter<$PrismaModel> | $Enums.TokenType
  }

  export type NestedEnumTokenTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenTypeWithAggregatesFilter<$PrismaModel> | $Enums.TokenType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTokenTypeFilter<$PrismaModel>
    _max?: NestedEnumTokenTypeFilter<$PrismaModel>
  }

  export type NestedEnumVotingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VotingStatus | EnumVotingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VotingStatus[] | ListEnumVotingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VotingStatus[] | ListEnumVotingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVotingStatusFilter<$PrismaModel> | $Enums.VotingStatus
  }

  export type NestedEnumVotingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VotingStatus | EnumVotingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VotingStatus[] | ListEnumVotingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VotingStatus[] | ListEnumVotingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVotingStatusWithAggregatesFilter<$PrismaModel> | $Enums.VotingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVotingStatusFilter<$PrismaModel>
    _max?: NestedEnumVotingStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NominationCreateWithoutAspirantInput = {
    id?: string
    nomineeName: string
    nomineeEmail: string
    nomineeContact: string
    nomineePosition: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    status?: $Enums.NominationStatus
    nomineeCollege: string
    nomineeDepartment: string
    nomineeDateOfBirth: Date | string
    nomineeHostel: string
    nomineeRoom: string
    nomineeSex: string
    nomineeCwa: string
    nomineeProgramme: string
    nomineeLevel: string
    nomineeParish: string
    nomineeNationality: string
    nomineeRegion: string
    nomineeSubgroups?: NominationCreatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationCreatenomineeEducationInput | string[]
    hasLeadershipPosition: boolean
    leadershipPositions?: NominationCreateleadershipPositionsInput | string[]
    hasServedCommittee: boolean
    committees?: NominationCreatecommitteesInput | string[]
    skills?: NominationCreateskillsInput | string[]
    visionForOffice?: NominationCreatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationCreateknowledgeAboutOfficeInput | string[]
    approvalCount?: number
    rejectionCount?: number
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nominatorVerification?: NominatorVerificationCreateNestedOneWithoutNominationInput
    guarantorVerifications?: GuarantorVerificationCreateNestedManyWithoutNominationInput
    EcReview?: EcReviewCreateNestedManyWithoutNominationInput
    candidate?: CandidateCreateNestedOneWithoutNominationInput
    User?: UserCreateNestedOneWithoutNominationInput
    Subgroup?: SubgroupCreateNestedOneWithoutNominationsInput
  }

  export type NominationUncheckedCreateWithoutAspirantInput = {
    id?: string
    nomineeName: string
    nomineeEmail: string
    nomineeContact: string
    nomineePosition: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    status?: $Enums.NominationStatus
    nomineeCollege: string
    nomineeDepartment: string
    nomineeDateOfBirth: Date | string
    nomineeHostel: string
    nomineeRoom: string
    nomineeSex: string
    nomineeCwa: string
    nomineeProgramme: string
    nomineeLevel: string
    nomineeParish: string
    nomineeNationality: string
    nomineeRegion: string
    nomineeSubgroups?: NominationCreatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationCreatenomineeEducationInput | string[]
    hasLeadershipPosition: boolean
    leadershipPositions?: NominationCreateleadershipPositionsInput | string[]
    hasServedCommittee: boolean
    committees?: NominationCreatecommitteesInput | string[]
    skills?: NominationCreateskillsInput | string[]
    visionForOffice?: NominationCreatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationCreateknowledgeAboutOfficeInput | string[]
    approvalCount?: number
    rejectionCount?: number
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    subgroupId?: string | null
    nominatorVerification?: NominatorVerificationUncheckedCreateNestedOneWithoutNominationInput
    guarantorVerifications?: GuarantorVerificationUncheckedCreateNestedManyWithoutNominationInput
    EcReview?: EcReviewUncheckedCreateNestedManyWithoutNominationInput
    candidate?: CandidateUncheckedCreateNestedOneWithoutNominationInput
  }

  export type NominationCreateOrConnectWithoutAspirantInput = {
    where: NominationWhereUniqueInput
    create: XOR<NominationCreateWithoutAspirantInput, NominationUncheckedCreateWithoutAspirantInput>
  }

  export type NominationCreateManyAspirantInputEnvelope = {
    data: NominationCreateManyAspirantInput | NominationCreateManyAspirantInput[]
    skipDuplicates?: boolean
  }

  export type EcReviewCreateWithoutReviewerInput = {
    id?: string
    approved: boolean
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nomination: NominationCreateNestedOneWithoutEcReviewInput
    User?: UserCreateNestedOneWithoutEcReviewInput
  }

  export type EcReviewUncheckedCreateWithoutReviewerInput = {
    id?: string
    nominationId: string
    approved: boolean
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type EcReviewCreateOrConnectWithoutReviewerInput = {
    where: EcReviewWhereUniqueInput
    create: XOR<EcReviewCreateWithoutReviewerInput, EcReviewUncheckedCreateWithoutReviewerInput>
  }

  export type EcReviewCreateManyReviewerInputEnvelope = {
    data: EcReviewCreateManyReviewerInput | EcReviewCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type NominationCreateWithoutUserInput = {
    id?: string
    nomineeName: string
    nomineeEmail: string
    nomineeContact: string
    nomineePosition: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    status?: $Enums.NominationStatus
    nomineeCollege: string
    nomineeDepartment: string
    nomineeDateOfBirth: Date | string
    nomineeHostel: string
    nomineeRoom: string
    nomineeSex: string
    nomineeCwa: string
    nomineeProgramme: string
    nomineeLevel: string
    nomineeParish: string
    nomineeNationality: string
    nomineeRegion: string
    nomineeSubgroups?: NominationCreatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationCreatenomineeEducationInput | string[]
    hasLeadershipPosition: boolean
    leadershipPositions?: NominationCreateleadershipPositionsInput | string[]
    hasServedCommittee: boolean
    committees?: NominationCreatecommitteesInput | string[]
    skills?: NominationCreateskillsInput | string[]
    visionForOffice?: NominationCreatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationCreateknowledgeAboutOfficeInput | string[]
    approvalCount?: number
    rejectionCount?: number
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aspirant: UserCreateNestedOneWithoutNominationsInput
    nominatorVerification?: NominatorVerificationCreateNestedOneWithoutNominationInput
    guarantorVerifications?: GuarantorVerificationCreateNestedManyWithoutNominationInput
    EcReview?: EcReviewCreateNestedManyWithoutNominationInput
    candidate?: CandidateCreateNestedOneWithoutNominationInput
    Subgroup?: SubgroupCreateNestedOneWithoutNominationsInput
  }

  export type NominationUncheckedCreateWithoutUserInput = {
    id?: string
    aspirantId: string
    nomineeName: string
    nomineeEmail: string
    nomineeContact: string
    nomineePosition: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    status?: $Enums.NominationStatus
    nomineeCollege: string
    nomineeDepartment: string
    nomineeDateOfBirth: Date | string
    nomineeHostel: string
    nomineeRoom: string
    nomineeSex: string
    nomineeCwa: string
    nomineeProgramme: string
    nomineeLevel: string
    nomineeParish: string
    nomineeNationality: string
    nomineeRegion: string
    nomineeSubgroups?: NominationCreatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationCreatenomineeEducationInput | string[]
    hasLeadershipPosition: boolean
    leadershipPositions?: NominationCreateleadershipPositionsInput | string[]
    hasServedCommittee: boolean
    committees?: NominationCreatecommitteesInput | string[]
    skills?: NominationCreateskillsInput | string[]
    visionForOffice?: NominationCreatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationCreateknowledgeAboutOfficeInput | string[]
    approvalCount?: number
    rejectionCount?: number
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subgroupId?: string | null
    nominatorVerification?: NominatorVerificationUncheckedCreateNestedOneWithoutNominationInput
    guarantorVerifications?: GuarantorVerificationUncheckedCreateNestedManyWithoutNominationInput
    EcReview?: EcReviewUncheckedCreateNestedManyWithoutNominationInput
    candidate?: CandidateUncheckedCreateNestedOneWithoutNominationInput
  }

  export type NominationCreateOrConnectWithoutUserInput = {
    where: NominationWhereUniqueInput
    create: XOR<NominationCreateWithoutUserInput, NominationUncheckedCreateWithoutUserInput>
  }

  export type NominationCreateManyUserInputEnvelope = {
    data: NominationCreateManyUserInput | NominationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NominatorVerificationCreateWithoutUserInput = {
    id?: string
    name: string
    email: string
    contact: string
    programme: string
    level: string
    subgroup: string
    status?: string
    comments?: string | null
    verifiedAt?: Date | string | null
    declinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nomination: NominationCreateNestedOneWithoutNominatorVerificationInput
    verificationToken?: VerificationTokenCreateNestedOneWithoutNominatorVerificationInput
  }

  export type NominatorVerificationUncheckedCreateWithoutUserInput = {
    id?: string
    nominationId: string
    name: string
    email: string
    contact: string
    programme: string
    level: string
    subgroup: string
    status?: string
    comments?: string | null
    verifiedAt?: Date | string | null
    declinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verificationToken?: VerificationTokenUncheckedCreateNestedOneWithoutNominatorVerificationInput
  }

  export type NominatorVerificationCreateOrConnectWithoutUserInput = {
    where: NominatorVerificationWhereUniqueInput
    create: XOR<NominatorVerificationCreateWithoutUserInput, NominatorVerificationUncheckedCreateWithoutUserInput>
  }

  export type NominatorVerificationCreateManyUserInputEnvelope = {
    data: NominatorVerificationCreateManyUserInput | NominatorVerificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GuarantorVerificationCreateWithoutUserInput = {
    id?: string
    name: string
    email: string
    contact: string
    programme: string
    subgroup: string
    status?: string
    comments?: string | null
    verifiedAt?: Date | string | null
    declinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verificationTokenId?: string | null
    nomination: NominationCreateNestedOneWithoutGuarantorVerificationsInput
    verificationToken?: VerificationTokenCreateNestedOneWithoutGuarantorVerificationInput
  }

  export type GuarantorVerificationUncheckedCreateWithoutUserInput = {
    id?: string
    nominationId: string
    name: string
    email: string
    contact: string
    programme: string
    subgroup: string
    status?: string
    comments?: string | null
    verifiedAt?: Date | string | null
    declinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verificationTokenId?: string | null
    verificationToken?: VerificationTokenUncheckedCreateNestedOneWithoutGuarantorVerificationInput
  }

  export type GuarantorVerificationCreateOrConnectWithoutUserInput = {
    where: GuarantorVerificationWhereUniqueInput
    create: XOR<GuarantorVerificationCreateWithoutUserInput, GuarantorVerificationUncheckedCreateWithoutUserInput>
  }

  export type GuarantorVerificationCreateManyUserInputEnvelope = {
    data: GuarantorVerificationCreateManyUserInput | GuarantorVerificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EcReviewCreateWithoutUserInput = {
    id?: string
    approved: boolean
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nomination: NominationCreateNestedOneWithoutEcReviewInput
    reviewer: UserCreateNestedOneWithoutEcReviewsInput
  }

  export type EcReviewUncheckedCreateWithoutUserInput = {
    id?: string
    nominationId: string
    reviewerId: string
    approved: boolean
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EcReviewCreateOrConnectWithoutUserInput = {
    where: EcReviewWhereUniqueInput
    create: XOR<EcReviewCreateWithoutUserInput, EcReviewUncheckedCreateWithoutUserInput>
  }

  export type EcReviewCreateManyUserInputEnvelope = {
    data: EcReviewCreateManyUserInput | EcReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VotingSessionCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionId: string
    voterHash: string
    deviceFingerprint?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    status?: $Enums.VotingStatus
    startTime?: Date | string
    endTime?: Date | string | null
    expiresAt: Date | string
    isValid?: boolean
    votes?: VoteCreateNestedManyWithoutSessionInput
  }

  export type VotingSessionUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionId: string
    voterHash: string
    deviceFingerprint?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    status?: $Enums.VotingStatus
    startTime?: Date | string
    endTime?: Date | string | null
    expiresAt: Date | string
    isValid?: boolean
    votes?: VoteUncheckedCreateNestedManyWithoutSessionInput
  }

  export type VotingSessionCreateOrConnectWithoutUserInput = {
    where: VotingSessionWhereUniqueInput
    create: XOR<VotingSessionCreateWithoutUserInput, VotingSessionUncheckedCreateWithoutUserInput>
  }

  export type VotingSessionCreateManyUserInputEnvelope = {
    data: VotingSessionCreateManyUserInput | VotingSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    action: string
    entity: string
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    action: string
    entity: string
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubgroupCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    isActive?: boolean
    nominations?: NominationCreateNestedManyWithoutSubgroupInput
  }

  export type SubgroupUncheckedCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    isActive?: boolean
    nominations?: NominationUncheckedCreateNestedManyWithoutSubgroupInput
  }

  export type SubgroupCreateOrConnectWithoutUsersInput = {
    where: SubgroupWhereUniqueInput
    create: XOR<SubgroupCreateWithoutUsersInput, SubgroupUncheckedCreateWithoutUsersInput>
  }

  export type NominationUpsertWithWhereUniqueWithoutAspirantInput = {
    where: NominationWhereUniqueInput
    update: XOR<NominationUpdateWithoutAspirantInput, NominationUncheckedUpdateWithoutAspirantInput>
    create: XOR<NominationCreateWithoutAspirantInput, NominationUncheckedCreateWithoutAspirantInput>
  }

  export type NominationUpdateWithWhereUniqueWithoutAspirantInput = {
    where: NominationWhereUniqueInput
    data: XOR<NominationUpdateWithoutAspirantInput, NominationUncheckedUpdateWithoutAspirantInput>
  }

  export type NominationUpdateManyWithWhereWithoutAspirantInput = {
    where: NominationScalarWhereInput
    data: XOR<NominationUpdateManyMutationInput, NominationUncheckedUpdateManyWithoutAspirantInput>
  }

  export type NominationScalarWhereInput = {
    AND?: NominationScalarWhereInput | NominationScalarWhereInput[]
    OR?: NominationScalarWhereInput[]
    NOT?: NominationScalarWhereInput | NominationScalarWhereInput[]
    id?: StringFilter<"Nomination"> | string
    aspirantId?: StringFilter<"Nomination"> | string
    nomineeName?: StringFilter<"Nomination"> | string
    nomineeEmail?: StringFilter<"Nomination"> | string
    nomineeContact?: StringFilter<"Nomination"> | string
    nomineePosition?: EnumCandidate_PositionFilter<"Nomination"> | $Enums.Candidate_Position
    photoUrl?: StringNullableFilter<"Nomination"> | string | null
    photoPublicId?: StringNullableFilter<"Nomination"> | string | null
    status?: EnumNominationStatusFilter<"Nomination"> | $Enums.NominationStatus
    nomineeCollege?: StringFilter<"Nomination"> | string
    nomineeDepartment?: StringFilter<"Nomination"> | string
    nomineeDateOfBirth?: DateTimeFilter<"Nomination"> | Date | string
    nomineeHostel?: StringFilter<"Nomination"> | string
    nomineeRoom?: StringFilter<"Nomination"> | string
    nomineeSex?: StringFilter<"Nomination"> | string
    nomineeCwa?: StringFilter<"Nomination"> | string
    nomineeProgramme?: StringFilter<"Nomination"> | string
    nomineeLevel?: StringFilter<"Nomination"> | string
    nomineeParish?: StringFilter<"Nomination"> | string
    nomineeNationality?: StringFilter<"Nomination"> | string
    nomineeRegion?: StringFilter<"Nomination"> | string
    nomineeSubgroups?: StringNullableListFilter<"Nomination">
    nomineeEducation?: StringNullableListFilter<"Nomination">
    hasLeadershipPosition?: BoolFilter<"Nomination"> | boolean
    leadershipPositions?: StringNullableListFilter<"Nomination">
    hasServedCommittee?: BoolFilter<"Nomination"> | boolean
    committees?: StringNullableListFilter<"Nomination">
    skills?: StringNullableListFilter<"Nomination">
    visionForOffice?: StringNullableListFilter<"Nomination">
    knowledgeAboutOffice?: StringNullableListFilter<"Nomination">
    approvalCount?: IntFilter<"Nomination"> | number
    rejectionCount?: IntFilter<"Nomination"> | number
    reviewedAt?: DateTimeNullableFilter<"Nomination"> | Date | string | null
    rejectionReason?: StringNullableFilter<"Nomination"> | string | null
    createdAt?: DateTimeFilter<"Nomination"> | Date | string
    updatedAt?: DateTimeFilter<"Nomination"> | Date | string
    userId?: StringNullableFilter<"Nomination"> | string | null
    subgroupId?: StringNullableFilter<"Nomination"> | string | null
  }

  export type EcReviewUpsertWithWhereUniqueWithoutReviewerInput = {
    where: EcReviewWhereUniqueInput
    update: XOR<EcReviewUpdateWithoutReviewerInput, EcReviewUncheckedUpdateWithoutReviewerInput>
    create: XOR<EcReviewCreateWithoutReviewerInput, EcReviewUncheckedCreateWithoutReviewerInput>
  }

  export type EcReviewUpdateWithWhereUniqueWithoutReviewerInput = {
    where: EcReviewWhereUniqueInput
    data: XOR<EcReviewUpdateWithoutReviewerInput, EcReviewUncheckedUpdateWithoutReviewerInput>
  }

  export type EcReviewUpdateManyWithWhereWithoutReviewerInput = {
    where: EcReviewScalarWhereInput
    data: XOR<EcReviewUpdateManyMutationInput, EcReviewUncheckedUpdateManyWithoutReviewerInput>
  }

  export type EcReviewScalarWhereInput = {
    AND?: EcReviewScalarWhereInput | EcReviewScalarWhereInput[]
    OR?: EcReviewScalarWhereInput[]
    NOT?: EcReviewScalarWhereInput | EcReviewScalarWhereInput[]
    id?: StringFilter<"EcReview"> | string
    nominationId?: StringFilter<"EcReview"> | string
    reviewerId?: StringFilter<"EcReview"> | string
    approved?: BoolFilter<"EcReview"> | boolean
    comments?: StringNullableFilter<"EcReview"> | string | null
    createdAt?: DateTimeFilter<"EcReview"> | Date | string
    updatedAt?: DateTimeFilter<"EcReview"> | Date | string
    userId?: StringNullableFilter<"EcReview"> | string | null
  }

  export type NominationUpsertWithWhereUniqueWithoutUserInput = {
    where: NominationWhereUniqueInput
    update: XOR<NominationUpdateWithoutUserInput, NominationUncheckedUpdateWithoutUserInput>
    create: XOR<NominationCreateWithoutUserInput, NominationUncheckedCreateWithoutUserInput>
  }

  export type NominationUpdateWithWhereUniqueWithoutUserInput = {
    where: NominationWhereUniqueInput
    data: XOR<NominationUpdateWithoutUserInput, NominationUncheckedUpdateWithoutUserInput>
  }

  export type NominationUpdateManyWithWhereWithoutUserInput = {
    where: NominationScalarWhereInput
    data: XOR<NominationUpdateManyMutationInput, NominationUncheckedUpdateManyWithoutUserInput>
  }

  export type NominatorVerificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NominatorVerificationWhereUniqueInput
    update: XOR<NominatorVerificationUpdateWithoutUserInput, NominatorVerificationUncheckedUpdateWithoutUserInput>
    create: XOR<NominatorVerificationCreateWithoutUserInput, NominatorVerificationUncheckedCreateWithoutUserInput>
  }

  export type NominatorVerificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NominatorVerificationWhereUniqueInput
    data: XOR<NominatorVerificationUpdateWithoutUserInput, NominatorVerificationUncheckedUpdateWithoutUserInput>
  }

  export type NominatorVerificationUpdateManyWithWhereWithoutUserInput = {
    where: NominatorVerificationScalarWhereInput
    data: XOR<NominatorVerificationUpdateManyMutationInput, NominatorVerificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NominatorVerificationScalarWhereInput = {
    AND?: NominatorVerificationScalarWhereInput | NominatorVerificationScalarWhereInput[]
    OR?: NominatorVerificationScalarWhereInput[]
    NOT?: NominatorVerificationScalarWhereInput | NominatorVerificationScalarWhereInput[]
    id?: StringFilter<"NominatorVerification"> | string
    nominationId?: StringFilter<"NominatorVerification"> | string
    name?: StringFilter<"NominatorVerification"> | string
    email?: StringFilter<"NominatorVerification"> | string
    contact?: StringFilter<"NominatorVerification"> | string
    programme?: StringFilter<"NominatorVerification"> | string
    level?: StringFilter<"NominatorVerification"> | string
    subgroup?: StringFilter<"NominatorVerification"> | string
    status?: StringFilter<"NominatorVerification"> | string
    comments?: StringNullableFilter<"NominatorVerification"> | string | null
    verifiedAt?: DateTimeNullableFilter<"NominatorVerification"> | Date | string | null
    declinedAt?: DateTimeNullableFilter<"NominatorVerification"> | Date | string | null
    createdAt?: DateTimeFilter<"NominatorVerification"> | Date | string
    updatedAt?: DateTimeFilter<"NominatorVerification"> | Date | string
    userId?: StringNullableFilter<"NominatorVerification"> | string | null
  }

  export type GuarantorVerificationUpsertWithWhereUniqueWithoutUserInput = {
    where: GuarantorVerificationWhereUniqueInput
    update: XOR<GuarantorVerificationUpdateWithoutUserInput, GuarantorVerificationUncheckedUpdateWithoutUserInput>
    create: XOR<GuarantorVerificationCreateWithoutUserInput, GuarantorVerificationUncheckedCreateWithoutUserInput>
  }

  export type GuarantorVerificationUpdateWithWhereUniqueWithoutUserInput = {
    where: GuarantorVerificationWhereUniqueInput
    data: XOR<GuarantorVerificationUpdateWithoutUserInput, GuarantorVerificationUncheckedUpdateWithoutUserInput>
  }

  export type GuarantorVerificationUpdateManyWithWhereWithoutUserInput = {
    where: GuarantorVerificationScalarWhereInput
    data: XOR<GuarantorVerificationUpdateManyMutationInput, GuarantorVerificationUncheckedUpdateManyWithoutUserInput>
  }

  export type GuarantorVerificationScalarWhereInput = {
    AND?: GuarantorVerificationScalarWhereInput | GuarantorVerificationScalarWhereInput[]
    OR?: GuarantorVerificationScalarWhereInput[]
    NOT?: GuarantorVerificationScalarWhereInput | GuarantorVerificationScalarWhereInput[]
    id?: StringFilter<"GuarantorVerification"> | string
    nominationId?: StringFilter<"GuarantorVerification"> | string
    name?: StringFilter<"GuarantorVerification"> | string
    email?: StringFilter<"GuarantorVerification"> | string
    contact?: StringFilter<"GuarantorVerification"> | string
    programme?: StringFilter<"GuarantorVerification"> | string
    subgroup?: StringFilter<"GuarantorVerification"> | string
    status?: StringFilter<"GuarantorVerification"> | string
    comments?: StringNullableFilter<"GuarantorVerification"> | string | null
    verifiedAt?: DateTimeNullableFilter<"GuarantorVerification"> | Date | string | null
    declinedAt?: DateTimeNullableFilter<"GuarantorVerification"> | Date | string | null
    createdAt?: DateTimeFilter<"GuarantorVerification"> | Date | string
    updatedAt?: DateTimeFilter<"GuarantorVerification"> | Date | string
    verificationTokenId?: StringNullableFilter<"GuarantorVerification"> | string | null
    userId?: StringNullableFilter<"GuarantorVerification"> | string | null
  }

  export type EcReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: EcReviewWhereUniqueInput
    update: XOR<EcReviewUpdateWithoutUserInput, EcReviewUncheckedUpdateWithoutUserInput>
    create: XOR<EcReviewCreateWithoutUserInput, EcReviewUncheckedCreateWithoutUserInput>
  }

  export type EcReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: EcReviewWhereUniqueInput
    data: XOR<EcReviewUpdateWithoutUserInput, EcReviewUncheckedUpdateWithoutUserInput>
  }

  export type EcReviewUpdateManyWithWhereWithoutUserInput = {
    where: EcReviewScalarWhereInput
    data: XOR<EcReviewUpdateManyMutationInput, EcReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type VotingSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: VotingSessionWhereUniqueInput
    update: XOR<VotingSessionUpdateWithoutUserInput, VotingSessionUncheckedUpdateWithoutUserInput>
    create: XOR<VotingSessionCreateWithoutUserInput, VotingSessionUncheckedCreateWithoutUserInput>
  }

  export type VotingSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: VotingSessionWhereUniqueInput
    data: XOR<VotingSessionUpdateWithoutUserInput, VotingSessionUncheckedUpdateWithoutUserInput>
  }

  export type VotingSessionUpdateManyWithWhereWithoutUserInput = {
    where: VotingSessionScalarWhereInput
    data: XOR<VotingSessionUpdateManyMutationInput, VotingSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type VotingSessionScalarWhereInput = {
    AND?: VotingSessionScalarWhereInput | VotingSessionScalarWhereInput[]
    OR?: VotingSessionScalarWhereInput[]
    NOT?: VotingSessionScalarWhereInput | VotingSessionScalarWhereInput[]
    id?: StringFilter<"VotingSession"> | string
    createdAt?: DateTimeFilter<"VotingSession"> | Date | string
    updatedAt?: DateTimeFilter<"VotingSession"> | Date | string
    sessionId?: StringFilter<"VotingSession"> | string
    voterHash?: StringFilter<"VotingSession"> | string
    deviceFingerprint?: StringNullableFilter<"VotingSession"> | string | null
    ipAddress?: StringNullableFilter<"VotingSession"> | string | null
    userAgent?: StringNullableFilter<"VotingSession"> | string | null
    status?: EnumVotingStatusFilter<"VotingSession"> | $Enums.VotingStatus
    startTime?: DateTimeFilter<"VotingSession"> | Date | string
    endTime?: DateTimeNullableFilter<"VotingSession"> | Date | string | null
    expiresAt?: DateTimeFilter<"VotingSession"> | Date | string
    isValid?: BoolFilter<"VotingSession"> | boolean
    userId?: StringFilter<"VotingSession"> | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringNullableFilter<"AuditLog"> | string | null
  }

  export type SubgroupUpsertWithoutUsersInput = {
    update: XOR<SubgroupUpdateWithoutUsersInput, SubgroupUncheckedUpdateWithoutUsersInput>
    create: XOR<SubgroupCreateWithoutUsersInput, SubgroupUncheckedCreateWithoutUsersInput>
    where?: SubgroupWhereInput
  }

  export type SubgroupUpdateToOneWithWhereWithoutUsersInput = {
    where?: SubgroupWhereInput
    data: XOR<SubgroupUpdateWithoutUsersInput, SubgroupUncheckedUpdateWithoutUsersInput>
  }

  export type SubgroupUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nominations?: NominationUpdateManyWithoutSubgroupNestedInput
  }

  export type SubgroupUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nominations?: NominationUncheckedUpdateManyWithoutSubgroupNestedInput
  }

  export type UserCreateWithoutNominationsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    programme?: string | null
    level?: string | null
    subgroup?: string | null
    college?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ecReviews?: EcReviewCreateNestedManyWithoutReviewerInput
    Nomination?: NominationCreateNestedManyWithoutUserInput
    NominatorVerification?: NominatorVerificationCreateNestedManyWithoutUserInput
    GuarantorVerification?: GuarantorVerificationCreateNestedManyWithoutUserInput
    EcReview?: EcReviewCreateNestedManyWithoutUserInput
    VotingSession?: VotingSessionCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Subgroup?: SubgroupCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutNominationsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    programme?: string | null
    level?: string | null
    subgroup?: string | null
    college?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subgroupId?: string | null
    ecReviews?: EcReviewUncheckedCreateNestedManyWithoutReviewerInput
    Nomination?: NominationUncheckedCreateNestedManyWithoutUserInput
    NominatorVerification?: NominatorVerificationUncheckedCreateNestedManyWithoutUserInput
    GuarantorVerification?: GuarantorVerificationUncheckedCreateNestedManyWithoutUserInput
    EcReview?: EcReviewUncheckedCreateNestedManyWithoutUserInput
    VotingSession?: VotingSessionUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNominationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNominationsInput, UserUncheckedCreateWithoutNominationsInput>
  }

  export type NominatorVerificationCreateWithoutNominationInput = {
    id?: string
    name: string
    email: string
    contact: string
    programme: string
    level: string
    subgroup: string
    status?: string
    comments?: string | null
    verifiedAt?: Date | string | null
    declinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verificationToken?: VerificationTokenCreateNestedOneWithoutNominatorVerificationInput
    User?: UserCreateNestedOneWithoutNominatorVerificationInput
  }

  export type NominatorVerificationUncheckedCreateWithoutNominationInput = {
    id?: string
    name: string
    email: string
    contact: string
    programme: string
    level: string
    subgroup: string
    status?: string
    comments?: string | null
    verifiedAt?: Date | string | null
    declinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    verificationToken?: VerificationTokenUncheckedCreateNestedOneWithoutNominatorVerificationInput
  }

  export type NominatorVerificationCreateOrConnectWithoutNominationInput = {
    where: NominatorVerificationWhereUniqueInput
    create: XOR<NominatorVerificationCreateWithoutNominationInput, NominatorVerificationUncheckedCreateWithoutNominationInput>
  }

  export type GuarantorVerificationCreateWithoutNominationInput = {
    id?: string
    name: string
    email: string
    contact: string
    programme: string
    subgroup: string
    status?: string
    comments?: string | null
    verifiedAt?: Date | string | null
    declinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verificationTokenId?: string | null
    verificationToken?: VerificationTokenCreateNestedOneWithoutGuarantorVerificationInput
    User?: UserCreateNestedOneWithoutGuarantorVerificationInput
  }

  export type GuarantorVerificationUncheckedCreateWithoutNominationInput = {
    id?: string
    name: string
    email: string
    contact: string
    programme: string
    subgroup: string
    status?: string
    comments?: string | null
    verifiedAt?: Date | string | null
    declinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verificationTokenId?: string | null
    userId?: string | null
    verificationToken?: VerificationTokenUncheckedCreateNestedOneWithoutGuarantorVerificationInput
  }

  export type GuarantorVerificationCreateOrConnectWithoutNominationInput = {
    where: GuarantorVerificationWhereUniqueInput
    create: XOR<GuarantorVerificationCreateWithoutNominationInput, GuarantorVerificationUncheckedCreateWithoutNominationInput>
  }

  export type GuarantorVerificationCreateManyNominationInputEnvelope = {
    data: GuarantorVerificationCreateManyNominationInput | GuarantorVerificationCreateManyNominationInput[]
    skipDuplicates?: boolean
  }

  export type EcReviewCreateWithoutNominationInput = {
    id?: string
    approved: boolean
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewer: UserCreateNestedOneWithoutEcReviewsInput
    User?: UserCreateNestedOneWithoutEcReviewInput
  }

  export type EcReviewUncheckedCreateWithoutNominationInput = {
    id?: string
    reviewerId: string
    approved: boolean
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type EcReviewCreateOrConnectWithoutNominationInput = {
    where: EcReviewWhereUniqueInput
    create: XOR<EcReviewCreateWithoutNominationInput, EcReviewUncheckedCreateWithoutNominationInput>
  }

  export type EcReviewCreateManyNominationInputEnvelope = {
    data: EcReviewCreateManyNominationInput | EcReviewCreateManyNominationInput[]
    skipDuplicates?: boolean
  }

  export type CandidateCreateWithoutNominationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    position: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    biography?: string | null
    displayOrder?: number
    isActive?: boolean
    candidateNumber: number
    voteCount?: number
  }

  export type CandidateUncheckedCreateWithoutNominationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    position: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    biography?: string | null
    displayOrder?: number
    isActive?: boolean
    candidateNumber: number
    voteCount?: number
  }

  export type CandidateCreateOrConnectWithoutNominationInput = {
    where: CandidateWhereUniqueInput
    create: XOR<CandidateCreateWithoutNominationInput, CandidateUncheckedCreateWithoutNominationInput>
  }

  export type UserCreateWithoutNominationInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    programme?: string | null
    level?: string | null
    subgroup?: string | null
    college?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nominations?: NominationCreateNestedManyWithoutAspirantInput
    ecReviews?: EcReviewCreateNestedManyWithoutReviewerInput
    NominatorVerification?: NominatorVerificationCreateNestedManyWithoutUserInput
    GuarantorVerification?: GuarantorVerificationCreateNestedManyWithoutUserInput
    EcReview?: EcReviewCreateNestedManyWithoutUserInput
    VotingSession?: VotingSessionCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Subgroup?: SubgroupCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutNominationInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    programme?: string | null
    level?: string | null
    subgroup?: string | null
    college?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subgroupId?: string | null
    nominations?: NominationUncheckedCreateNestedManyWithoutAspirantInput
    ecReviews?: EcReviewUncheckedCreateNestedManyWithoutReviewerInput
    NominatorVerification?: NominatorVerificationUncheckedCreateNestedManyWithoutUserInput
    GuarantorVerification?: GuarantorVerificationUncheckedCreateNestedManyWithoutUserInput
    EcReview?: EcReviewUncheckedCreateNestedManyWithoutUserInput
    VotingSession?: VotingSessionUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNominationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNominationInput, UserUncheckedCreateWithoutNominationInput>
  }

  export type SubgroupCreateWithoutNominationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    isActive?: boolean
    users?: UserCreateNestedManyWithoutSubgroupInput
  }

  export type SubgroupUncheckedCreateWithoutNominationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    isActive?: boolean
    users?: UserUncheckedCreateNestedManyWithoutSubgroupInput
  }

  export type SubgroupCreateOrConnectWithoutNominationsInput = {
    where: SubgroupWhereUniqueInput
    create: XOR<SubgroupCreateWithoutNominationsInput, SubgroupUncheckedCreateWithoutNominationsInput>
  }

  export type UserUpsertWithoutNominationsInput = {
    update: XOR<UserUpdateWithoutNominationsInput, UserUncheckedUpdateWithoutNominationsInput>
    create: XOR<UserCreateWithoutNominationsInput, UserUncheckedCreateWithoutNominationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNominationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNominationsInput, UserUncheckedUpdateWithoutNominationsInput>
  }

  export type UserUpdateWithoutNominationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ecReviews?: EcReviewUpdateManyWithoutReviewerNestedInput
    Nomination?: NominationUpdateManyWithoutUserNestedInput
    NominatorVerification?: NominatorVerificationUpdateManyWithoutUserNestedInput
    GuarantorVerification?: GuarantorVerificationUpdateManyWithoutUserNestedInput
    EcReview?: EcReviewUpdateManyWithoutUserNestedInput
    VotingSession?: VotingSessionUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Subgroup?: SubgroupUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutNominationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null
    ecReviews?: EcReviewUncheckedUpdateManyWithoutReviewerNestedInput
    Nomination?: NominationUncheckedUpdateManyWithoutUserNestedInput
    NominatorVerification?: NominatorVerificationUncheckedUpdateManyWithoutUserNestedInput
    GuarantorVerification?: GuarantorVerificationUncheckedUpdateManyWithoutUserNestedInput
    EcReview?: EcReviewUncheckedUpdateManyWithoutUserNestedInput
    VotingSession?: VotingSessionUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NominatorVerificationUpsertWithoutNominationInput = {
    update: XOR<NominatorVerificationUpdateWithoutNominationInput, NominatorVerificationUncheckedUpdateWithoutNominationInput>
    create: XOR<NominatorVerificationCreateWithoutNominationInput, NominatorVerificationUncheckedCreateWithoutNominationInput>
    where?: NominatorVerificationWhereInput
  }

  export type NominatorVerificationUpdateToOneWithWhereWithoutNominationInput = {
    where?: NominatorVerificationWhereInput
    data: XOR<NominatorVerificationUpdateWithoutNominationInput, NominatorVerificationUncheckedUpdateWithoutNominationInput>
  }

  export type NominatorVerificationUpdateWithoutNominationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: VerificationTokenUpdateOneWithoutNominatorVerificationNestedInput
    User?: UserUpdateOneWithoutNominatorVerificationNestedInput
  }

  export type NominatorVerificationUncheckedUpdateWithoutNominationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationToken?: VerificationTokenUncheckedUpdateOneWithoutNominatorVerificationNestedInput
  }

  export type GuarantorVerificationUpsertWithWhereUniqueWithoutNominationInput = {
    where: GuarantorVerificationWhereUniqueInput
    update: XOR<GuarantorVerificationUpdateWithoutNominationInput, GuarantorVerificationUncheckedUpdateWithoutNominationInput>
    create: XOR<GuarantorVerificationCreateWithoutNominationInput, GuarantorVerificationUncheckedCreateWithoutNominationInput>
  }

  export type GuarantorVerificationUpdateWithWhereUniqueWithoutNominationInput = {
    where: GuarantorVerificationWhereUniqueInput
    data: XOR<GuarantorVerificationUpdateWithoutNominationInput, GuarantorVerificationUncheckedUpdateWithoutNominationInput>
  }

  export type GuarantorVerificationUpdateManyWithWhereWithoutNominationInput = {
    where: GuarantorVerificationScalarWhereInput
    data: XOR<GuarantorVerificationUpdateManyMutationInput, GuarantorVerificationUncheckedUpdateManyWithoutNominationInput>
  }

  export type EcReviewUpsertWithWhereUniqueWithoutNominationInput = {
    where: EcReviewWhereUniqueInput
    update: XOR<EcReviewUpdateWithoutNominationInput, EcReviewUncheckedUpdateWithoutNominationInput>
    create: XOR<EcReviewCreateWithoutNominationInput, EcReviewUncheckedCreateWithoutNominationInput>
  }

  export type EcReviewUpdateWithWhereUniqueWithoutNominationInput = {
    where: EcReviewWhereUniqueInput
    data: XOR<EcReviewUpdateWithoutNominationInput, EcReviewUncheckedUpdateWithoutNominationInput>
  }

  export type EcReviewUpdateManyWithWhereWithoutNominationInput = {
    where: EcReviewScalarWhereInput
    data: XOR<EcReviewUpdateManyMutationInput, EcReviewUncheckedUpdateManyWithoutNominationInput>
  }

  export type CandidateUpsertWithoutNominationInput = {
    update: XOR<CandidateUpdateWithoutNominationInput, CandidateUncheckedUpdateWithoutNominationInput>
    create: XOR<CandidateCreateWithoutNominationInput, CandidateUncheckedCreateWithoutNominationInput>
    where?: CandidateWhereInput
  }

  export type CandidateUpdateToOneWithWhereWithoutNominationInput = {
    where?: CandidateWhereInput
    data: XOR<CandidateUpdateWithoutNominationInput, CandidateUncheckedUpdateWithoutNominationInput>
  }

  export type CandidateUpdateWithoutNominationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    position?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    candidateNumber?: IntFieldUpdateOperationsInput | number
    voteCount?: IntFieldUpdateOperationsInput | number
  }

  export type CandidateUncheckedUpdateWithoutNominationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    position?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    candidateNumber?: IntFieldUpdateOperationsInput | number
    voteCount?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutNominationInput = {
    update: XOR<UserUpdateWithoutNominationInput, UserUncheckedUpdateWithoutNominationInput>
    create: XOR<UserCreateWithoutNominationInput, UserUncheckedCreateWithoutNominationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNominationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNominationInput, UserUncheckedUpdateWithoutNominationInput>
  }

  export type UserUpdateWithoutNominationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nominations?: NominationUpdateManyWithoutAspirantNestedInput
    ecReviews?: EcReviewUpdateManyWithoutReviewerNestedInput
    NominatorVerification?: NominatorVerificationUpdateManyWithoutUserNestedInput
    GuarantorVerification?: GuarantorVerificationUpdateManyWithoutUserNestedInput
    EcReview?: EcReviewUpdateManyWithoutUserNestedInput
    VotingSession?: VotingSessionUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Subgroup?: SubgroupUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutNominationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null
    nominations?: NominationUncheckedUpdateManyWithoutAspirantNestedInput
    ecReviews?: EcReviewUncheckedUpdateManyWithoutReviewerNestedInput
    NominatorVerification?: NominatorVerificationUncheckedUpdateManyWithoutUserNestedInput
    GuarantorVerification?: GuarantorVerificationUncheckedUpdateManyWithoutUserNestedInput
    EcReview?: EcReviewUncheckedUpdateManyWithoutUserNestedInput
    VotingSession?: VotingSessionUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubgroupUpsertWithoutNominationsInput = {
    update: XOR<SubgroupUpdateWithoutNominationsInput, SubgroupUncheckedUpdateWithoutNominationsInput>
    create: XOR<SubgroupCreateWithoutNominationsInput, SubgroupUncheckedCreateWithoutNominationsInput>
    where?: SubgroupWhereInput
  }

  export type SubgroupUpdateToOneWithWhereWithoutNominationsInput = {
    where?: SubgroupWhereInput
    data: XOR<SubgroupUpdateWithoutNominationsInput, SubgroupUncheckedUpdateWithoutNominationsInput>
  }

  export type SubgroupUpdateWithoutNominationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateManyWithoutSubgroupNestedInput
  }

  export type SubgroupUncheckedUpdateWithoutNominationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUncheckedUpdateManyWithoutSubgroupNestedInput
  }

  export type NominationCreateWithoutNominatorVerificationInput = {
    id?: string
    nomineeName: string
    nomineeEmail: string
    nomineeContact: string
    nomineePosition: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    status?: $Enums.NominationStatus
    nomineeCollege: string
    nomineeDepartment: string
    nomineeDateOfBirth: Date | string
    nomineeHostel: string
    nomineeRoom: string
    nomineeSex: string
    nomineeCwa: string
    nomineeProgramme: string
    nomineeLevel: string
    nomineeParish: string
    nomineeNationality: string
    nomineeRegion: string
    nomineeSubgroups?: NominationCreatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationCreatenomineeEducationInput | string[]
    hasLeadershipPosition: boolean
    leadershipPositions?: NominationCreateleadershipPositionsInput | string[]
    hasServedCommittee: boolean
    committees?: NominationCreatecommitteesInput | string[]
    skills?: NominationCreateskillsInput | string[]
    visionForOffice?: NominationCreatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationCreateknowledgeAboutOfficeInput | string[]
    approvalCount?: number
    rejectionCount?: number
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aspirant: UserCreateNestedOneWithoutNominationsInput
    guarantorVerifications?: GuarantorVerificationCreateNestedManyWithoutNominationInput
    EcReview?: EcReviewCreateNestedManyWithoutNominationInput
    candidate?: CandidateCreateNestedOneWithoutNominationInput
    User?: UserCreateNestedOneWithoutNominationInput
    Subgroup?: SubgroupCreateNestedOneWithoutNominationsInput
  }

  export type NominationUncheckedCreateWithoutNominatorVerificationInput = {
    id?: string
    aspirantId: string
    nomineeName: string
    nomineeEmail: string
    nomineeContact: string
    nomineePosition: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    status?: $Enums.NominationStatus
    nomineeCollege: string
    nomineeDepartment: string
    nomineeDateOfBirth: Date | string
    nomineeHostel: string
    nomineeRoom: string
    nomineeSex: string
    nomineeCwa: string
    nomineeProgramme: string
    nomineeLevel: string
    nomineeParish: string
    nomineeNationality: string
    nomineeRegion: string
    nomineeSubgroups?: NominationCreatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationCreatenomineeEducationInput | string[]
    hasLeadershipPosition: boolean
    leadershipPositions?: NominationCreateleadershipPositionsInput | string[]
    hasServedCommittee: boolean
    committees?: NominationCreatecommitteesInput | string[]
    skills?: NominationCreateskillsInput | string[]
    visionForOffice?: NominationCreatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationCreateknowledgeAboutOfficeInput | string[]
    approvalCount?: number
    rejectionCount?: number
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    subgroupId?: string | null
    guarantorVerifications?: GuarantorVerificationUncheckedCreateNestedManyWithoutNominationInput
    EcReview?: EcReviewUncheckedCreateNestedManyWithoutNominationInput
    candidate?: CandidateUncheckedCreateNestedOneWithoutNominationInput
  }

  export type NominationCreateOrConnectWithoutNominatorVerificationInput = {
    where: NominationWhereUniqueInput
    create: XOR<NominationCreateWithoutNominatorVerificationInput, NominationUncheckedCreateWithoutNominatorVerificationInput>
  }

  export type VerificationTokenCreateWithoutNominatorVerificationInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    email?: string | null
    phone?: string | null
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    guarantorVerification?: GuarantorVerificationCreateNestedOneWithoutVerificationTokenInput
  }

  export type VerificationTokenUncheckedCreateWithoutNominatorVerificationInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    email?: string | null
    phone?: string | null
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    guarantorVerificationId?: string | null
  }

  export type VerificationTokenCreateOrConnectWithoutNominatorVerificationInput = {
    where: VerificationTokenWhereUniqueInput
    create: XOR<VerificationTokenCreateWithoutNominatorVerificationInput, VerificationTokenUncheckedCreateWithoutNominatorVerificationInput>
  }

  export type UserCreateWithoutNominatorVerificationInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    programme?: string | null
    level?: string | null
    subgroup?: string | null
    college?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nominations?: NominationCreateNestedManyWithoutAspirantInput
    ecReviews?: EcReviewCreateNestedManyWithoutReviewerInput
    Nomination?: NominationCreateNestedManyWithoutUserInput
    GuarantorVerification?: GuarantorVerificationCreateNestedManyWithoutUserInput
    EcReview?: EcReviewCreateNestedManyWithoutUserInput
    VotingSession?: VotingSessionCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Subgroup?: SubgroupCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutNominatorVerificationInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    programme?: string | null
    level?: string | null
    subgroup?: string | null
    college?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subgroupId?: string | null
    nominations?: NominationUncheckedCreateNestedManyWithoutAspirantInput
    ecReviews?: EcReviewUncheckedCreateNestedManyWithoutReviewerInput
    Nomination?: NominationUncheckedCreateNestedManyWithoutUserInput
    GuarantorVerification?: GuarantorVerificationUncheckedCreateNestedManyWithoutUserInput
    EcReview?: EcReviewUncheckedCreateNestedManyWithoutUserInput
    VotingSession?: VotingSessionUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNominatorVerificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNominatorVerificationInput, UserUncheckedCreateWithoutNominatorVerificationInput>
  }

  export type NominationUpsertWithoutNominatorVerificationInput = {
    update: XOR<NominationUpdateWithoutNominatorVerificationInput, NominationUncheckedUpdateWithoutNominatorVerificationInput>
    create: XOR<NominationCreateWithoutNominatorVerificationInput, NominationUncheckedCreateWithoutNominatorVerificationInput>
    where?: NominationWhereInput
  }

  export type NominationUpdateToOneWithWhereWithoutNominatorVerificationInput = {
    where?: NominationWhereInput
    data: XOR<NominationUpdateWithoutNominatorVerificationInput, NominationUncheckedUpdateWithoutNominatorVerificationInput>
  }

  export type NominationUpdateWithoutNominatorVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    nomineeEmail?: StringFieldUpdateOperationsInput | string
    nomineeContact?: StringFieldUpdateOperationsInput | string
    nomineePosition?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNominationStatusFieldUpdateOperationsInput | $Enums.NominationStatus
    nomineeCollege?: StringFieldUpdateOperationsInput | string
    nomineeDepartment?: StringFieldUpdateOperationsInput | string
    nomineeDateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nomineeHostel?: StringFieldUpdateOperationsInput | string
    nomineeRoom?: StringFieldUpdateOperationsInput | string
    nomineeSex?: StringFieldUpdateOperationsInput | string
    nomineeCwa?: StringFieldUpdateOperationsInput | string
    nomineeProgramme?: StringFieldUpdateOperationsInput | string
    nomineeLevel?: StringFieldUpdateOperationsInput | string
    nomineeParish?: StringFieldUpdateOperationsInput | string
    nomineeNationality?: StringFieldUpdateOperationsInput | string
    nomineeRegion?: StringFieldUpdateOperationsInput | string
    nomineeSubgroups?: NominationUpdatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationUpdatenomineeEducationInput | string[]
    hasLeadershipPosition?: BoolFieldUpdateOperationsInput | boolean
    leadershipPositions?: NominationUpdateleadershipPositionsInput | string[]
    hasServedCommittee?: BoolFieldUpdateOperationsInput | boolean
    committees?: NominationUpdatecommitteesInput | string[]
    skills?: NominationUpdateskillsInput | string[]
    visionForOffice?: NominationUpdatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationUpdateknowledgeAboutOfficeInput | string[]
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aspirant?: UserUpdateOneRequiredWithoutNominationsNestedInput
    guarantorVerifications?: GuarantorVerificationUpdateManyWithoutNominationNestedInput
    EcReview?: EcReviewUpdateManyWithoutNominationNestedInput
    candidate?: CandidateUpdateOneWithoutNominationNestedInput
    User?: UserUpdateOneWithoutNominationNestedInput
    Subgroup?: SubgroupUpdateOneWithoutNominationsNestedInput
  }

  export type NominationUncheckedUpdateWithoutNominatorVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    aspirantId?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    nomineeEmail?: StringFieldUpdateOperationsInput | string
    nomineeContact?: StringFieldUpdateOperationsInput | string
    nomineePosition?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNominationStatusFieldUpdateOperationsInput | $Enums.NominationStatus
    nomineeCollege?: StringFieldUpdateOperationsInput | string
    nomineeDepartment?: StringFieldUpdateOperationsInput | string
    nomineeDateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nomineeHostel?: StringFieldUpdateOperationsInput | string
    nomineeRoom?: StringFieldUpdateOperationsInput | string
    nomineeSex?: StringFieldUpdateOperationsInput | string
    nomineeCwa?: StringFieldUpdateOperationsInput | string
    nomineeProgramme?: StringFieldUpdateOperationsInput | string
    nomineeLevel?: StringFieldUpdateOperationsInput | string
    nomineeParish?: StringFieldUpdateOperationsInput | string
    nomineeNationality?: StringFieldUpdateOperationsInput | string
    nomineeRegion?: StringFieldUpdateOperationsInput | string
    nomineeSubgroups?: NominationUpdatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationUpdatenomineeEducationInput | string[]
    hasLeadershipPosition?: BoolFieldUpdateOperationsInput | boolean
    leadershipPositions?: NominationUpdateleadershipPositionsInput | string[]
    hasServedCommittee?: BoolFieldUpdateOperationsInput | boolean
    committees?: NominationUpdatecommitteesInput | string[]
    skills?: NominationUpdateskillsInput | string[]
    visionForOffice?: NominationUpdatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationUpdateknowledgeAboutOfficeInput | string[]
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null
    guarantorVerifications?: GuarantorVerificationUncheckedUpdateManyWithoutNominationNestedInput
    EcReview?: EcReviewUncheckedUpdateManyWithoutNominationNestedInput
    candidate?: CandidateUncheckedUpdateOneWithoutNominationNestedInput
  }

  export type VerificationTokenUpsertWithoutNominatorVerificationInput = {
    update: XOR<VerificationTokenUpdateWithoutNominatorVerificationInput, VerificationTokenUncheckedUpdateWithoutNominatorVerificationInput>
    create: XOR<VerificationTokenCreateWithoutNominatorVerificationInput, VerificationTokenUncheckedCreateWithoutNominatorVerificationInput>
    where?: VerificationTokenWhereInput
  }

  export type VerificationTokenUpdateToOneWithWhereWithoutNominatorVerificationInput = {
    where?: VerificationTokenWhereInput
    data: XOR<VerificationTokenUpdateWithoutNominatorVerificationInput, VerificationTokenUncheckedUpdateWithoutNominatorVerificationInput>
  }

  export type VerificationTokenUpdateWithoutNominatorVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guarantorVerification?: GuarantorVerificationUpdateOneWithoutVerificationTokenNestedInput
  }

  export type VerificationTokenUncheckedUpdateWithoutNominatorVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guarantorVerificationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutNominatorVerificationInput = {
    update: XOR<UserUpdateWithoutNominatorVerificationInput, UserUncheckedUpdateWithoutNominatorVerificationInput>
    create: XOR<UserCreateWithoutNominatorVerificationInput, UserUncheckedCreateWithoutNominatorVerificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNominatorVerificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNominatorVerificationInput, UserUncheckedUpdateWithoutNominatorVerificationInput>
  }

  export type UserUpdateWithoutNominatorVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nominations?: NominationUpdateManyWithoutAspirantNestedInput
    ecReviews?: EcReviewUpdateManyWithoutReviewerNestedInput
    Nomination?: NominationUpdateManyWithoutUserNestedInput
    GuarantorVerification?: GuarantorVerificationUpdateManyWithoutUserNestedInput
    EcReview?: EcReviewUpdateManyWithoutUserNestedInput
    VotingSession?: VotingSessionUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Subgroup?: SubgroupUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutNominatorVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null
    nominations?: NominationUncheckedUpdateManyWithoutAspirantNestedInput
    ecReviews?: EcReviewUncheckedUpdateManyWithoutReviewerNestedInput
    Nomination?: NominationUncheckedUpdateManyWithoutUserNestedInput
    GuarantorVerification?: GuarantorVerificationUncheckedUpdateManyWithoutUserNestedInput
    EcReview?: EcReviewUncheckedUpdateManyWithoutUserNestedInput
    VotingSession?: VotingSessionUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NominationCreateWithoutGuarantorVerificationsInput = {
    id?: string
    nomineeName: string
    nomineeEmail: string
    nomineeContact: string
    nomineePosition: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    status?: $Enums.NominationStatus
    nomineeCollege: string
    nomineeDepartment: string
    nomineeDateOfBirth: Date | string
    nomineeHostel: string
    nomineeRoom: string
    nomineeSex: string
    nomineeCwa: string
    nomineeProgramme: string
    nomineeLevel: string
    nomineeParish: string
    nomineeNationality: string
    nomineeRegion: string
    nomineeSubgroups?: NominationCreatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationCreatenomineeEducationInput | string[]
    hasLeadershipPosition: boolean
    leadershipPositions?: NominationCreateleadershipPositionsInput | string[]
    hasServedCommittee: boolean
    committees?: NominationCreatecommitteesInput | string[]
    skills?: NominationCreateskillsInput | string[]
    visionForOffice?: NominationCreatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationCreateknowledgeAboutOfficeInput | string[]
    approvalCount?: number
    rejectionCount?: number
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aspirant: UserCreateNestedOneWithoutNominationsInput
    nominatorVerification?: NominatorVerificationCreateNestedOneWithoutNominationInput
    EcReview?: EcReviewCreateNestedManyWithoutNominationInput
    candidate?: CandidateCreateNestedOneWithoutNominationInput
    User?: UserCreateNestedOneWithoutNominationInput
    Subgroup?: SubgroupCreateNestedOneWithoutNominationsInput
  }

  export type NominationUncheckedCreateWithoutGuarantorVerificationsInput = {
    id?: string
    aspirantId: string
    nomineeName: string
    nomineeEmail: string
    nomineeContact: string
    nomineePosition: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    status?: $Enums.NominationStatus
    nomineeCollege: string
    nomineeDepartment: string
    nomineeDateOfBirth: Date | string
    nomineeHostel: string
    nomineeRoom: string
    nomineeSex: string
    nomineeCwa: string
    nomineeProgramme: string
    nomineeLevel: string
    nomineeParish: string
    nomineeNationality: string
    nomineeRegion: string
    nomineeSubgroups?: NominationCreatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationCreatenomineeEducationInput | string[]
    hasLeadershipPosition: boolean
    leadershipPositions?: NominationCreateleadershipPositionsInput | string[]
    hasServedCommittee: boolean
    committees?: NominationCreatecommitteesInput | string[]
    skills?: NominationCreateskillsInput | string[]
    visionForOffice?: NominationCreatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationCreateknowledgeAboutOfficeInput | string[]
    approvalCount?: number
    rejectionCount?: number
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    subgroupId?: string | null
    nominatorVerification?: NominatorVerificationUncheckedCreateNestedOneWithoutNominationInput
    EcReview?: EcReviewUncheckedCreateNestedManyWithoutNominationInput
    candidate?: CandidateUncheckedCreateNestedOneWithoutNominationInput
  }

  export type NominationCreateOrConnectWithoutGuarantorVerificationsInput = {
    where: NominationWhereUniqueInput
    create: XOR<NominationCreateWithoutGuarantorVerificationsInput, NominationUncheckedCreateWithoutGuarantorVerificationsInput>
  }

  export type VerificationTokenCreateWithoutGuarantorVerificationInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    email?: string | null
    phone?: string | null
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    nominatorVerification?: NominatorVerificationCreateNestedOneWithoutVerificationTokenInput
  }

  export type VerificationTokenUncheckedCreateWithoutGuarantorVerificationInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    email?: string | null
    phone?: string | null
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    nominatorVerificationId?: string | null
  }

  export type VerificationTokenCreateOrConnectWithoutGuarantorVerificationInput = {
    where: VerificationTokenWhereUniqueInput
    create: XOR<VerificationTokenCreateWithoutGuarantorVerificationInput, VerificationTokenUncheckedCreateWithoutGuarantorVerificationInput>
  }

  export type UserCreateWithoutGuarantorVerificationInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    programme?: string | null
    level?: string | null
    subgroup?: string | null
    college?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nominations?: NominationCreateNestedManyWithoutAspirantInput
    ecReviews?: EcReviewCreateNestedManyWithoutReviewerInput
    Nomination?: NominationCreateNestedManyWithoutUserInput
    NominatorVerification?: NominatorVerificationCreateNestedManyWithoutUserInput
    EcReview?: EcReviewCreateNestedManyWithoutUserInput
    VotingSession?: VotingSessionCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Subgroup?: SubgroupCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutGuarantorVerificationInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    programme?: string | null
    level?: string | null
    subgroup?: string | null
    college?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subgroupId?: string | null
    nominations?: NominationUncheckedCreateNestedManyWithoutAspirantInput
    ecReviews?: EcReviewUncheckedCreateNestedManyWithoutReviewerInput
    Nomination?: NominationUncheckedCreateNestedManyWithoutUserInput
    NominatorVerification?: NominatorVerificationUncheckedCreateNestedManyWithoutUserInput
    EcReview?: EcReviewUncheckedCreateNestedManyWithoutUserInput
    VotingSession?: VotingSessionUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGuarantorVerificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGuarantorVerificationInput, UserUncheckedCreateWithoutGuarantorVerificationInput>
  }

  export type NominationUpsertWithoutGuarantorVerificationsInput = {
    update: XOR<NominationUpdateWithoutGuarantorVerificationsInput, NominationUncheckedUpdateWithoutGuarantorVerificationsInput>
    create: XOR<NominationCreateWithoutGuarantorVerificationsInput, NominationUncheckedCreateWithoutGuarantorVerificationsInput>
    where?: NominationWhereInput
  }

  export type NominationUpdateToOneWithWhereWithoutGuarantorVerificationsInput = {
    where?: NominationWhereInput
    data: XOR<NominationUpdateWithoutGuarantorVerificationsInput, NominationUncheckedUpdateWithoutGuarantorVerificationsInput>
  }

  export type NominationUpdateWithoutGuarantorVerificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    nomineeEmail?: StringFieldUpdateOperationsInput | string
    nomineeContact?: StringFieldUpdateOperationsInput | string
    nomineePosition?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNominationStatusFieldUpdateOperationsInput | $Enums.NominationStatus
    nomineeCollege?: StringFieldUpdateOperationsInput | string
    nomineeDepartment?: StringFieldUpdateOperationsInput | string
    nomineeDateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nomineeHostel?: StringFieldUpdateOperationsInput | string
    nomineeRoom?: StringFieldUpdateOperationsInput | string
    nomineeSex?: StringFieldUpdateOperationsInput | string
    nomineeCwa?: StringFieldUpdateOperationsInput | string
    nomineeProgramme?: StringFieldUpdateOperationsInput | string
    nomineeLevel?: StringFieldUpdateOperationsInput | string
    nomineeParish?: StringFieldUpdateOperationsInput | string
    nomineeNationality?: StringFieldUpdateOperationsInput | string
    nomineeRegion?: StringFieldUpdateOperationsInput | string
    nomineeSubgroups?: NominationUpdatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationUpdatenomineeEducationInput | string[]
    hasLeadershipPosition?: BoolFieldUpdateOperationsInput | boolean
    leadershipPositions?: NominationUpdateleadershipPositionsInput | string[]
    hasServedCommittee?: BoolFieldUpdateOperationsInput | boolean
    committees?: NominationUpdatecommitteesInput | string[]
    skills?: NominationUpdateskillsInput | string[]
    visionForOffice?: NominationUpdatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationUpdateknowledgeAboutOfficeInput | string[]
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aspirant?: UserUpdateOneRequiredWithoutNominationsNestedInput
    nominatorVerification?: NominatorVerificationUpdateOneWithoutNominationNestedInput
    EcReview?: EcReviewUpdateManyWithoutNominationNestedInput
    candidate?: CandidateUpdateOneWithoutNominationNestedInput
    User?: UserUpdateOneWithoutNominationNestedInput
    Subgroup?: SubgroupUpdateOneWithoutNominationsNestedInput
  }

  export type NominationUncheckedUpdateWithoutGuarantorVerificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    aspirantId?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    nomineeEmail?: StringFieldUpdateOperationsInput | string
    nomineeContact?: StringFieldUpdateOperationsInput | string
    nomineePosition?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNominationStatusFieldUpdateOperationsInput | $Enums.NominationStatus
    nomineeCollege?: StringFieldUpdateOperationsInput | string
    nomineeDepartment?: StringFieldUpdateOperationsInput | string
    nomineeDateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nomineeHostel?: StringFieldUpdateOperationsInput | string
    nomineeRoom?: StringFieldUpdateOperationsInput | string
    nomineeSex?: StringFieldUpdateOperationsInput | string
    nomineeCwa?: StringFieldUpdateOperationsInput | string
    nomineeProgramme?: StringFieldUpdateOperationsInput | string
    nomineeLevel?: StringFieldUpdateOperationsInput | string
    nomineeParish?: StringFieldUpdateOperationsInput | string
    nomineeNationality?: StringFieldUpdateOperationsInput | string
    nomineeRegion?: StringFieldUpdateOperationsInput | string
    nomineeSubgroups?: NominationUpdatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationUpdatenomineeEducationInput | string[]
    hasLeadershipPosition?: BoolFieldUpdateOperationsInput | boolean
    leadershipPositions?: NominationUpdateleadershipPositionsInput | string[]
    hasServedCommittee?: BoolFieldUpdateOperationsInput | boolean
    committees?: NominationUpdatecommitteesInput | string[]
    skills?: NominationUpdateskillsInput | string[]
    visionForOffice?: NominationUpdatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationUpdateknowledgeAboutOfficeInput | string[]
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null
    nominatorVerification?: NominatorVerificationUncheckedUpdateOneWithoutNominationNestedInput
    EcReview?: EcReviewUncheckedUpdateManyWithoutNominationNestedInput
    candidate?: CandidateUncheckedUpdateOneWithoutNominationNestedInput
  }

  export type VerificationTokenUpsertWithoutGuarantorVerificationInput = {
    update: XOR<VerificationTokenUpdateWithoutGuarantorVerificationInput, VerificationTokenUncheckedUpdateWithoutGuarantorVerificationInput>
    create: XOR<VerificationTokenCreateWithoutGuarantorVerificationInput, VerificationTokenUncheckedCreateWithoutGuarantorVerificationInput>
    where?: VerificationTokenWhereInput
  }

  export type VerificationTokenUpdateToOneWithWhereWithoutGuarantorVerificationInput = {
    where?: VerificationTokenWhereInput
    data: XOR<VerificationTokenUpdateWithoutGuarantorVerificationInput, VerificationTokenUncheckedUpdateWithoutGuarantorVerificationInput>
  }

  export type VerificationTokenUpdateWithoutGuarantorVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nominatorVerification?: NominatorVerificationUpdateOneWithoutVerificationTokenNestedInput
  }

  export type VerificationTokenUncheckedUpdateWithoutGuarantorVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nominatorVerificationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutGuarantorVerificationInput = {
    update: XOR<UserUpdateWithoutGuarantorVerificationInput, UserUncheckedUpdateWithoutGuarantorVerificationInput>
    create: XOR<UserCreateWithoutGuarantorVerificationInput, UserUncheckedCreateWithoutGuarantorVerificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGuarantorVerificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGuarantorVerificationInput, UserUncheckedUpdateWithoutGuarantorVerificationInput>
  }

  export type UserUpdateWithoutGuarantorVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nominations?: NominationUpdateManyWithoutAspirantNestedInput
    ecReviews?: EcReviewUpdateManyWithoutReviewerNestedInput
    Nomination?: NominationUpdateManyWithoutUserNestedInput
    NominatorVerification?: NominatorVerificationUpdateManyWithoutUserNestedInput
    EcReview?: EcReviewUpdateManyWithoutUserNestedInput
    VotingSession?: VotingSessionUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Subgroup?: SubgroupUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutGuarantorVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null
    nominations?: NominationUncheckedUpdateManyWithoutAspirantNestedInput
    ecReviews?: EcReviewUncheckedUpdateManyWithoutReviewerNestedInput
    Nomination?: NominationUncheckedUpdateManyWithoutUserNestedInput
    NominatorVerification?: NominatorVerificationUncheckedUpdateManyWithoutUserNestedInput
    EcReview?: EcReviewUncheckedUpdateManyWithoutUserNestedInput
    VotingSession?: VotingSessionUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NominationCreateWithoutEcReviewInput = {
    id?: string
    nomineeName: string
    nomineeEmail: string
    nomineeContact: string
    nomineePosition: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    status?: $Enums.NominationStatus
    nomineeCollege: string
    nomineeDepartment: string
    nomineeDateOfBirth: Date | string
    nomineeHostel: string
    nomineeRoom: string
    nomineeSex: string
    nomineeCwa: string
    nomineeProgramme: string
    nomineeLevel: string
    nomineeParish: string
    nomineeNationality: string
    nomineeRegion: string
    nomineeSubgroups?: NominationCreatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationCreatenomineeEducationInput | string[]
    hasLeadershipPosition: boolean
    leadershipPositions?: NominationCreateleadershipPositionsInput | string[]
    hasServedCommittee: boolean
    committees?: NominationCreatecommitteesInput | string[]
    skills?: NominationCreateskillsInput | string[]
    visionForOffice?: NominationCreatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationCreateknowledgeAboutOfficeInput | string[]
    approvalCount?: number
    rejectionCount?: number
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aspirant: UserCreateNestedOneWithoutNominationsInput
    nominatorVerification?: NominatorVerificationCreateNestedOneWithoutNominationInput
    guarantorVerifications?: GuarantorVerificationCreateNestedManyWithoutNominationInput
    candidate?: CandidateCreateNestedOneWithoutNominationInput
    User?: UserCreateNestedOneWithoutNominationInput
    Subgroup?: SubgroupCreateNestedOneWithoutNominationsInput
  }

  export type NominationUncheckedCreateWithoutEcReviewInput = {
    id?: string
    aspirantId: string
    nomineeName: string
    nomineeEmail: string
    nomineeContact: string
    nomineePosition: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    status?: $Enums.NominationStatus
    nomineeCollege: string
    nomineeDepartment: string
    nomineeDateOfBirth: Date | string
    nomineeHostel: string
    nomineeRoom: string
    nomineeSex: string
    nomineeCwa: string
    nomineeProgramme: string
    nomineeLevel: string
    nomineeParish: string
    nomineeNationality: string
    nomineeRegion: string
    nomineeSubgroups?: NominationCreatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationCreatenomineeEducationInput | string[]
    hasLeadershipPosition: boolean
    leadershipPositions?: NominationCreateleadershipPositionsInput | string[]
    hasServedCommittee: boolean
    committees?: NominationCreatecommitteesInput | string[]
    skills?: NominationCreateskillsInput | string[]
    visionForOffice?: NominationCreatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationCreateknowledgeAboutOfficeInput | string[]
    approvalCount?: number
    rejectionCount?: number
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    subgroupId?: string | null
    nominatorVerification?: NominatorVerificationUncheckedCreateNestedOneWithoutNominationInput
    guarantorVerifications?: GuarantorVerificationUncheckedCreateNestedManyWithoutNominationInput
    candidate?: CandidateUncheckedCreateNestedOneWithoutNominationInput
  }

  export type NominationCreateOrConnectWithoutEcReviewInput = {
    where: NominationWhereUniqueInput
    create: XOR<NominationCreateWithoutEcReviewInput, NominationUncheckedCreateWithoutEcReviewInput>
  }

  export type UserCreateWithoutEcReviewsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    programme?: string | null
    level?: string | null
    subgroup?: string | null
    college?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nominations?: NominationCreateNestedManyWithoutAspirantInput
    Nomination?: NominationCreateNestedManyWithoutUserInput
    NominatorVerification?: NominatorVerificationCreateNestedManyWithoutUserInput
    GuarantorVerification?: GuarantorVerificationCreateNestedManyWithoutUserInput
    EcReview?: EcReviewCreateNestedManyWithoutUserInput
    VotingSession?: VotingSessionCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Subgroup?: SubgroupCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutEcReviewsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    programme?: string | null
    level?: string | null
    subgroup?: string | null
    college?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subgroupId?: string | null
    nominations?: NominationUncheckedCreateNestedManyWithoutAspirantInput
    Nomination?: NominationUncheckedCreateNestedManyWithoutUserInput
    NominatorVerification?: NominatorVerificationUncheckedCreateNestedManyWithoutUserInput
    GuarantorVerification?: GuarantorVerificationUncheckedCreateNestedManyWithoutUserInput
    EcReview?: EcReviewUncheckedCreateNestedManyWithoutUserInput
    VotingSession?: VotingSessionUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEcReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEcReviewsInput, UserUncheckedCreateWithoutEcReviewsInput>
  }

  export type UserCreateWithoutEcReviewInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    programme?: string | null
    level?: string | null
    subgroup?: string | null
    college?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nominations?: NominationCreateNestedManyWithoutAspirantInput
    ecReviews?: EcReviewCreateNestedManyWithoutReviewerInput
    Nomination?: NominationCreateNestedManyWithoutUserInput
    NominatorVerification?: NominatorVerificationCreateNestedManyWithoutUserInput
    GuarantorVerification?: GuarantorVerificationCreateNestedManyWithoutUserInput
    VotingSession?: VotingSessionCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Subgroup?: SubgroupCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutEcReviewInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    programme?: string | null
    level?: string | null
    subgroup?: string | null
    college?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subgroupId?: string | null
    nominations?: NominationUncheckedCreateNestedManyWithoutAspirantInput
    ecReviews?: EcReviewUncheckedCreateNestedManyWithoutReviewerInput
    Nomination?: NominationUncheckedCreateNestedManyWithoutUserInput
    NominatorVerification?: NominatorVerificationUncheckedCreateNestedManyWithoutUserInput
    GuarantorVerification?: GuarantorVerificationUncheckedCreateNestedManyWithoutUserInput
    VotingSession?: VotingSessionUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEcReviewInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEcReviewInput, UserUncheckedCreateWithoutEcReviewInput>
  }

  export type NominationUpsertWithoutEcReviewInput = {
    update: XOR<NominationUpdateWithoutEcReviewInput, NominationUncheckedUpdateWithoutEcReviewInput>
    create: XOR<NominationCreateWithoutEcReviewInput, NominationUncheckedCreateWithoutEcReviewInput>
    where?: NominationWhereInput
  }

  export type NominationUpdateToOneWithWhereWithoutEcReviewInput = {
    where?: NominationWhereInput
    data: XOR<NominationUpdateWithoutEcReviewInput, NominationUncheckedUpdateWithoutEcReviewInput>
  }

  export type NominationUpdateWithoutEcReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    nomineeEmail?: StringFieldUpdateOperationsInput | string
    nomineeContact?: StringFieldUpdateOperationsInput | string
    nomineePosition?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNominationStatusFieldUpdateOperationsInput | $Enums.NominationStatus
    nomineeCollege?: StringFieldUpdateOperationsInput | string
    nomineeDepartment?: StringFieldUpdateOperationsInput | string
    nomineeDateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nomineeHostel?: StringFieldUpdateOperationsInput | string
    nomineeRoom?: StringFieldUpdateOperationsInput | string
    nomineeSex?: StringFieldUpdateOperationsInput | string
    nomineeCwa?: StringFieldUpdateOperationsInput | string
    nomineeProgramme?: StringFieldUpdateOperationsInput | string
    nomineeLevel?: StringFieldUpdateOperationsInput | string
    nomineeParish?: StringFieldUpdateOperationsInput | string
    nomineeNationality?: StringFieldUpdateOperationsInput | string
    nomineeRegion?: StringFieldUpdateOperationsInput | string
    nomineeSubgroups?: NominationUpdatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationUpdatenomineeEducationInput | string[]
    hasLeadershipPosition?: BoolFieldUpdateOperationsInput | boolean
    leadershipPositions?: NominationUpdateleadershipPositionsInput | string[]
    hasServedCommittee?: BoolFieldUpdateOperationsInput | boolean
    committees?: NominationUpdatecommitteesInput | string[]
    skills?: NominationUpdateskillsInput | string[]
    visionForOffice?: NominationUpdatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationUpdateknowledgeAboutOfficeInput | string[]
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aspirant?: UserUpdateOneRequiredWithoutNominationsNestedInput
    nominatorVerification?: NominatorVerificationUpdateOneWithoutNominationNestedInput
    guarantorVerifications?: GuarantorVerificationUpdateManyWithoutNominationNestedInput
    candidate?: CandidateUpdateOneWithoutNominationNestedInput
    User?: UserUpdateOneWithoutNominationNestedInput
    Subgroup?: SubgroupUpdateOneWithoutNominationsNestedInput
  }

  export type NominationUncheckedUpdateWithoutEcReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    aspirantId?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    nomineeEmail?: StringFieldUpdateOperationsInput | string
    nomineeContact?: StringFieldUpdateOperationsInput | string
    nomineePosition?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNominationStatusFieldUpdateOperationsInput | $Enums.NominationStatus
    nomineeCollege?: StringFieldUpdateOperationsInput | string
    nomineeDepartment?: StringFieldUpdateOperationsInput | string
    nomineeDateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nomineeHostel?: StringFieldUpdateOperationsInput | string
    nomineeRoom?: StringFieldUpdateOperationsInput | string
    nomineeSex?: StringFieldUpdateOperationsInput | string
    nomineeCwa?: StringFieldUpdateOperationsInput | string
    nomineeProgramme?: StringFieldUpdateOperationsInput | string
    nomineeLevel?: StringFieldUpdateOperationsInput | string
    nomineeParish?: StringFieldUpdateOperationsInput | string
    nomineeNationality?: StringFieldUpdateOperationsInput | string
    nomineeRegion?: StringFieldUpdateOperationsInput | string
    nomineeSubgroups?: NominationUpdatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationUpdatenomineeEducationInput | string[]
    hasLeadershipPosition?: BoolFieldUpdateOperationsInput | boolean
    leadershipPositions?: NominationUpdateleadershipPositionsInput | string[]
    hasServedCommittee?: BoolFieldUpdateOperationsInput | boolean
    committees?: NominationUpdatecommitteesInput | string[]
    skills?: NominationUpdateskillsInput | string[]
    visionForOffice?: NominationUpdatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationUpdateknowledgeAboutOfficeInput | string[]
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null
    nominatorVerification?: NominatorVerificationUncheckedUpdateOneWithoutNominationNestedInput
    guarantorVerifications?: GuarantorVerificationUncheckedUpdateManyWithoutNominationNestedInput
    candidate?: CandidateUncheckedUpdateOneWithoutNominationNestedInput
  }

  export type UserUpsertWithoutEcReviewsInput = {
    update: XOR<UserUpdateWithoutEcReviewsInput, UserUncheckedUpdateWithoutEcReviewsInput>
    create: XOR<UserCreateWithoutEcReviewsInput, UserUncheckedCreateWithoutEcReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEcReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEcReviewsInput, UserUncheckedUpdateWithoutEcReviewsInput>
  }

  export type UserUpdateWithoutEcReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nominations?: NominationUpdateManyWithoutAspirantNestedInput
    Nomination?: NominationUpdateManyWithoutUserNestedInput
    NominatorVerification?: NominatorVerificationUpdateManyWithoutUserNestedInput
    GuarantorVerification?: GuarantorVerificationUpdateManyWithoutUserNestedInput
    EcReview?: EcReviewUpdateManyWithoutUserNestedInput
    VotingSession?: VotingSessionUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Subgroup?: SubgroupUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutEcReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null
    nominations?: NominationUncheckedUpdateManyWithoutAspirantNestedInput
    Nomination?: NominationUncheckedUpdateManyWithoutUserNestedInput
    NominatorVerification?: NominatorVerificationUncheckedUpdateManyWithoutUserNestedInput
    GuarantorVerification?: GuarantorVerificationUncheckedUpdateManyWithoutUserNestedInput
    EcReview?: EcReviewUncheckedUpdateManyWithoutUserNestedInput
    VotingSession?: VotingSessionUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutEcReviewInput = {
    update: XOR<UserUpdateWithoutEcReviewInput, UserUncheckedUpdateWithoutEcReviewInput>
    create: XOR<UserCreateWithoutEcReviewInput, UserUncheckedCreateWithoutEcReviewInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEcReviewInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEcReviewInput, UserUncheckedUpdateWithoutEcReviewInput>
  }

  export type UserUpdateWithoutEcReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nominations?: NominationUpdateManyWithoutAspirantNestedInput
    ecReviews?: EcReviewUpdateManyWithoutReviewerNestedInput
    Nomination?: NominationUpdateManyWithoutUserNestedInput
    NominatorVerification?: NominatorVerificationUpdateManyWithoutUserNestedInput
    GuarantorVerification?: GuarantorVerificationUpdateManyWithoutUserNestedInput
    VotingSession?: VotingSessionUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Subgroup?: SubgroupUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutEcReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null
    nominations?: NominationUncheckedUpdateManyWithoutAspirantNestedInput
    ecReviews?: EcReviewUncheckedUpdateManyWithoutReviewerNestedInput
    Nomination?: NominationUncheckedUpdateManyWithoutUserNestedInput
    NominatorVerification?: NominatorVerificationUncheckedUpdateManyWithoutUserNestedInput
    GuarantorVerification?: GuarantorVerificationUncheckedUpdateManyWithoutUserNestedInput
    VotingSession?: VotingSessionUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NominatorVerificationCreateWithoutVerificationTokenInput = {
    id?: string
    name: string
    email: string
    contact: string
    programme: string
    level: string
    subgroup: string
    status?: string
    comments?: string | null
    verifiedAt?: Date | string | null
    declinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nomination: NominationCreateNestedOneWithoutNominatorVerificationInput
    User?: UserCreateNestedOneWithoutNominatorVerificationInput
  }

  export type NominatorVerificationUncheckedCreateWithoutVerificationTokenInput = {
    id?: string
    nominationId: string
    name: string
    email: string
    contact: string
    programme: string
    level: string
    subgroup: string
    status?: string
    comments?: string | null
    verifiedAt?: Date | string | null
    declinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type NominatorVerificationCreateOrConnectWithoutVerificationTokenInput = {
    where: NominatorVerificationWhereUniqueInput
    create: XOR<NominatorVerificationCreateWithoutVerificationTokenInput, NominatorVerificationUncheckedCreateWithoutVerificationTokenInput>
  }

  export type GuarantorVerificationCreateWithoutVerificationTokenInput = {
    id?: string
    name: string
    email: string
    contact: string
    programme: string
    subgroup: string
    status?: string
    comments?: string | null
    verifiedAt?: Date | string | null
    declinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verificationTokenId?: string | null
    nomination: NominationCreateNestedOneWithoutGuarantorVerificationsInput
    User?: UserCreateNestedOneWithoutGuarantorVerificationInput
  }

  export type GuarantorVerificationUncheckedCreateWithoutVerificationTokenInput = {
    id?: string
    nominationId: string
    name: string
    email: string
    contact: string
    programme: string
    subgroup: string
    status?: string
    comments?: string | null
    verifiedAt?: Date | string | null
    declinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verificationTokenId?: string | null
    userId?: string | null
  }

  export type GuarantorVerificationCreateOrConnectWithoutVerificationTokenInput = {
    where: GuarantorVerificationWhereUniqueInput
    create: XOR<GuarantorVerificationCreateWithoutVerificationTokenInput, GuarantorVerificationUncheckedCreateWithoutVerificationTokenInput>
  }

  export type NominatorVerificationUpsertWithoutVerificationTokenInput = {
    update: XOR<NominatorVerificationUpdateWithoutVerificationTokenInput, NominatorVerificationUncheckedUpdateWithoutVerificationTokenInput>
    create: XOR<NominatorVerificationCreateWithoutVerificationTokenInput, NominatorVerificationUncheckedCreateWithoutVerificationTokenInput>
    where?: NominatorVerificationWhereInput
  }

  export type NominatorVerificationUpdateToOneWithWhereWithoutVerificationTokenInput = {
    where?: NominatorVerificationWhereInput
    data: XOR<NominatorVerificationUpdateWithoutVerificationTokenInput, NominatorVerificationUncheckedUpdateWithoutVerificationTokenInput>
  }

  export type NominatorVerificationUpdateWithoutVerificationTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nomination?: NominationUpdateOneRequiredWithoutNominatorVerificationNestedInput
    User?: UserUpdateOneWithoutNominatorVerificationNestedInput
  }

  export type NominatorVerificationUncheckedUpdateWithoutVerificationTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    nominationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GuarantorVerificationUpsertWithoutVerificationTokenInput = {
    update: XOR<GuarantorVerificationUpdateWithoutVerificationTokenInput, GuarantorVerificationUncheckedUpdateWithoutVerificationTokenInput>
    create: XOR<GuarantorVerificationCreateWithoutVerificationTokenInput, GuarantorVerificationUncheckedCreateWithoutVerificationTokenInput>
    where?: GuarantorVerificationWhereInput
  }

  export type GuarantorVerificationUpdateToOneWithWhereWithoutVerificationTokenInput = {
    where?: GuarantorVerificationWhereInput
    data: XOR<GuarantorVerificationUpdateWithoutVerificationTokenInput, GuarantorVerificationUncheckedUpdateWithoutVerificationTokenInput>
  }

  export type GuarantorVerificationUpdateWithoutVerificationTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    nomination?: NominationUpdateOneRequiredWithoutGuarantorVerificationsNestedInput
    User?: UserUpdateOneWithoutGuarantorVerificationNestedInput
  }

  export type GuarantorVerificationUncheckedUpdateWithoutVerificationTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    nominationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NominationCreateWithoutCandidateInput = {
    id?: string
    nomineeName: string
    nomineeEmail: string
    nomineeContact: string
    nomineePosition: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    status?: $Enums.NominationStatus
    nomineeCollege: string
    nomineeDepartment: string
    nomineeDateOfBirth: Date | string
    nomineeHostel: string
    nomineeRoom: string
    nomineeSex: string
    nomineeCwa: string
    nomineeProgramme: string
    nomineeLevel: string
    nomineeParish: string
    nomineeNationality: string
    nomineeRegion: string
    nomineeSubgroups?: NominationCreatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationCreatenomineeEducationInput | string[]
    hasLeadershipPosition: boolean
    leadershipPositions?: NominationCreateleadershipPositionsInput | string[]
    hasServedCommittee: boolean
    committees?: NominationCreatecommitteesInput | string[]
    skills?: NominationCreateskillsInput | string[]
    visionForOffice?: NominationCreatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationCreateknowledgeAboutOfficeInput | string[]
    approvalCount?: number
    rejectionCount?: number
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aspirant: UserCreateNestedOneWithoutNominationsInput
    nominatorVerification?: NominatorVerificationCreateNestedOneWithoutNominationInput
    guarantorVerifications?: GuarantorVerificationCreateNestedManyWithoutNominationInput
    EcReview?: EcReviewCreateNestedManyWithoutNominationInput
    User?: UserCreateNestedOneWithoutNominationInput
    Subgroup?: SubgroupCreateNestedOneWithoutNominationsInput
  }

  export type NominationUncheckedCreateWithoutCandidateInput = {
    id?: string
    aspirantId: string
    nomineeName: string
    nomineeEmail: string
    nomineeContact: string
    nomineePosition: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    status?: $Enums.NominationStatus
    nomineeCollege: string
    nomineeDepartment: string
    nomineeDateOfBirth: Date | string
    nomineeHostel: string
    nomineeRoom: string
    nomineeSex: string
    nomineeCwa: string
    nomineeProgramme: string
    nomineeLevel: string
    nomineeParish: string
    nomineeNationality: string
    nomineeRegion: string
    nomineeSubgroups?: NominationCreatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationCreatenomineeEducationInput | string[]
    hasLeadershipPosition: boolean
    leadershipPositions?: NominationCreateleadershipPositionsInput | string[]
    hasServedCommittee: boolean
    committees?: NominationCreatecommitteesInput | string[]
    skills?: NominationCreateskillsInput | string[]
    visionForOffice?: NominationCreatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationCreateknowledgeAboutOfficeInput | string[]
    approvalCount?: number
    rejectionCount?: number
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    subgroupId?: string | null
    nominatorVerification?: NominatorVerificationUncheckedCreateNestedOneWithoutNominationInput
    guarantorVerifications?: GuarantorVerificationUncheckedCreateNestedManyWithoutNominationInput
    EcReview?: EcReviewUncheckedCreateNestedManyWithoutNominationInput
  }

  export type NominationCreateOrConnectWithoutCandidateInput = {
    where: NominationWhereUniqueInput
    create: XOR<NominationCreateWithoutCandidateInput, NominationUncheckedCreateWithoutCandidateInput>
  }

  export type NominationUpsertWithoutCandidateInput = {
    update: XOR<NominationUpdateWithoutCandidateInput, NominationUncheckedUpdateWithoutCandidateInput>
    create: XOR<NominationCreateWithoutCandidateInput, NominationUncheckedCreateWithoutCandidateInput>
    where?: NominationWhereInput
  }

  export type NominationUpdateToOneWithWhereWithoutCandidateInput = {
    where?: NominationWhereInput
    data: XOR<NominationUpdateWithoutCandidateInput, NominationUncheckedUpdateWithoutCandidateInput>
  }

  export type NominationUpdateWithoutCandidateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    nomineeEmail?: StringFieldUpdateOperationsInput | string
    nomineeContact?: StringFieldUpdateOperationsInput | string
    nomineePosition?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNominationStatusFieldUpdateOperationsInput | $Enums.NominationStatus
    nomineeCollege?: StringFieldUpdateOperationsInput | string
    nomineeDepartment?: StringFieldUpdateOperationsInput | string
    nomineeDateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nomineeHostel?: StringFieldUpdateOperationsInput | string
    nomineeRoom?: StringFieldUpdateOperationsInput | string
    nomineeSex?: StringFieldUpdateOperationsInput | string
    nomineeCwa?: StringFieldUpdateOperationsInput | string
    nomineeProgramme?: StringFieldUpdateOperationsInput | string
    nomineeLevel?: StringFieldUpdateOperationsInput | string
    nomineeParish?: StringFieldUpdateOperationsInput | string
    nomineeNationality?: StringFieldUpdateOperationsInput | string
    nomineeRegion?: StringFieldUpdateOperationsInput | string
    nomineeSubgroups?: NominationUpdatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationUpdatenomineeEducationInput | string[]
    hasLeadershipPosition?: BoolFieldUpdateOperationsInput | boolean
    leadershipPositions?: NominationUpdateleadershipPositionsInput | string[]
    hasServedCommittee?: BoolFieldUpdateOperationsInput | boolean
    committees?: NominationUpdatecommitteesInput | string[]
    skills?: NominationUpdateskillsInput | string[]
    visionForOffice?: NominationUpdatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationUpdateknowledgeAboutOfficeInput | string[]
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aspirant?: UserUpdateOneRequiredWithoutNominationsNestedInput
    nominatorVerification?: NominatorVerificationUpdateOneWithoutNominationNestedInput
    guarantorVerifications?: GuarantorVerificationUpdateManyWithoutNominationNestedInput
    EcReview?: EcReviewUpdateManyWithoutNominationNestedInput
    User?: UserUpdateOneWithoutNominationNestedInput
    Subgroup?: SubgroupUpdateOneWithoutNominationsNestedInput
  }

  export type NominationUncheckedUpdateWithoutCandidateInput = {
    id?: StringFieldUpdateOperationsInput | string
    aspirantId?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    nomineeEmail?: StringFieldUpdateOperationsInput | string
    nomineeContact?: StringFieldUpdateOperationsInput | string
    nomineePosition?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNominationStatusFieldUpdateOperationsInput | $Enums.NominationStatus
    nomineeCollege?: StringFieldUpdateOperationsInput | string
    nomineeDepartment?: StringFieldUpdateOperationsInput | string
    nomineeDateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nomineeHostel?: StringFieldUpdateOperationsInput | string
    nomineeRoom?: StringFieldUpdateOperationsInput | string
    nomineeSex?: StringFieldUpdateOperationsInput | string
    nomineeCwa?: StringFieldUpdateOperationsInput | string
    nomineeProgramme?: StringFieldUpdateOperationsInput | string
    nomineeLevel?: StringFieldUpdateOperationsInput | string
    nomineeParish?: StringFieldUpdateOperationsInput | string
    nomineeNationality?: StringFieldUpdateOperationsInput | string
    nomineeRegion?: StringFieldUpdateOperationsInput | string
    nomineeSubgroups?: NominationUpdatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationUpdatenomineeEducationInput | string[]
    hasLeadershipPosition?: BoolFieldUpdateOperationsInput | boolean
    leadershipPositions?: NominationUpdateleadershipPositionsInput | string[]
    hasServedCommittee?: BoolFieldUpdateOperationsInput | boolean
    committees?: NominationUpdatecommitteesInput | string[]
    skills?: NominationUpdateskillsInput | string[]
    visionForOffice?: NominationUpdatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationUpdateknowledgeAboutOfficeInput | string[]
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null
    nominatorVerification?: NominatorVerificationUncheckedUpdateOneWithoutNominationNestedInput
    guarantorVerifications?: GuarantorVerificationUncheckedUpdateManyWithoutNominationNestedInput
    EcReview?: EcReviewUncheckedUpdateManyWithoutNominationNestedInput
  }

  export type UserCreateWithoutVotingSessionInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    programme?: string | null
    level?: string | null
    subgroup?: string | null
    college?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nominations?: NominationCreateNestedManyWithoutAspirantInput
    ecReviews?: EcReviewCreateNestedManyWithoutReviewerInput
    Nomination?: NominationCreateNestedManyWithoutUserInput
    NominatorVerification?: NominatorVerificationCreateNestedManyWithoutUserInput
    GuarantorVerification?: GuarantorVerificationCreateNestedManyWithoutUserInput
    EcReview?: EcReviewCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Subgroup?: SubgroupCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutVotingSessionInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    programme?: string | null
    level?: string | null
    subgroup?: string | null
    college?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subgroupId?: string | null
    nominations?: NominationUncheckedCreateNestedManyWithoutAspirantInput
    ecReviews?: EcReviewUncheckedCreateNestedManyWithoutReviewerInput
    Nomination?: NominationUncheckedCreateNestedManyWithoutUserInput
    NominatorVerification?: NominatorVerificationUncheckedCreateNestedManyWithoutUserInput
    GuarantorVerification?: GuarantorVerificationUncheckedCreateNestedManyWithoutUserInput
    EcReview?: EcReviewUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVotingSessionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVotingSessionInput, UserUncheckedCreateWithoutVotingSessionInput>
  }

  export type VoteCreateWithoutSessionInput = {
    id?: string
    createdAt?: Date | string
    encryptedVote: string
    voterHash: string
    submissionTime?: Date | string
    deviceFingerprint?: string | null
    ipAddress?: string | null
    isValid?: boolean
  }

  export type VoteUncheckedCreateWithoutSessionInput = {
    id?: string
    createdAt?: Date | string
    encryptedVote: string
    voterHash: string
    submissionTime?: Date | string
    deviceFingerprint?: string | null
    ipAddress?: string | null
    isValid?: boolean
  }

  export type VoteCreateOrConnectWithoutSessionInput = {
    where: VoteWhereUniqueInput
    create: XOR<VoteCreateWithoutSessionInput, VoteUncheckedCreateWithoutSessionInput>
  }

  export type VoteCreateManySessionInputEnvelope = {
    data: VoteCreateManySessionInput | VoteCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutVotingSessionInput = {
    update: XOR<UserUpdateWithoutVotingSessionInput, UserUncheckedUpdateWithoutVotingSessionInput>
    create: XOR<UserCreateWithoutVotingSessionInput, UserUncheckedCreateWithoutVotingSessionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVotingSessionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVotingSessionInput, UserUncheckedUpdateWithoutVotingSessionInput>
  }

  export type UserUpdateWithoutVotingSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nominations?: NominationUpdateManyWithoutAspirantNestedInput
    ecReviews?: EcReviewUpdateManyWithoutReviewerNestedInput
    Nomination?: NominationUpdateManyWithoutUserNestedInput
    NominatorVerification?: NominatorVerificationUpdateManyWithoutUserNestedInput
    GuarantorVerification?: GuarantorVerificationUpdateManyWithoutUserNestedInput
    EcReview?: EcReviewUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Subgroup?: SubgroupUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutVotingSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null
    nominations?: NominationUncheckedUpdateManyWithoutAspirantNestedInput
    ecReviews?: EcReviewUncheckedUpdateManyWithoutReviewerNestedInput
    Nomination?: NominationUncheckedUpdateManyWithoutUserNestedInput
    NominatorVerification?: NominatorVerificationUncheckedUpdateManyWithoutUserNestedInput
    GuarantorVerification?: GuarantorVerificationUncheckedUpdateManyWithoutUserNestedInput
    EcReview?: EcReviewUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VoteUpsertWithWhereUniqueWithoutSessionInput = {
    where: VoteWhereUniqueInput
    update: XOR<VoteUpdateWithoutSessionInput, VoteUncheckedUpdateWithoutSessionInput>
    create: XOR<VoteCreateWithoutSessionInput, VoteUncheckedCreateWithoutSessionInput>
  }

  export type VoteUpdateWithWhereUniqueWithoutSessionInput = {
    where: VoteWhereUniqueInput
    data: XOR<VoteUpdateWithoutSessionInput, VoteUncheckedUpdateWithoutSessionInput>
  }

  export type VoteUpdateManyWithWhereWithoutSessionInput = {
    where: VoteScalarWhereInput
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyWithoutSessionInput>
  }

  export type VoteScalarWhereInput = {
    AND?: VoteScalarWhereInput | VoteScalarWhereInput[]
    OR?: VoteScalarWhereInput[]
    NOT?: VoteScalarWhereInput | VoteScalarWhereInput[]
    id?: StringFilter<"Vote"> | string
    createdAt?: DateTimeFilter<"Vote"> | Date | string
    encryptedVote?: StringFilter<"Vote"> | string
    voterHash?: StringFilter<"Vote"> | string
    submissionTime?: DateTimeFilter<"Vote"> | Date | string
    deviceFingerprint?: StringNullableFilter<"Vote"> | string | null
    ipAddress?: StringNullableFilter<"Vote"> | string | null
    isValid?: BoolFilter<"Vote"> | boolean
    sessionId?: StringFilter<"Vote"> | string
  }

  export type VotingSessionCreateWithoutVotesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionId: string
    voterHash: string
    deviceFingerprint?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    status?: $Enums.VotingStatus
    startTime?: Date | string
    endTime?: Date | string | null
    expiresAt: Date | string
    isValid?: boolean
    user: UserCreateNestedOneWithoutVotingSessionInput
  }

  export type VotingSessionUncheckedCreateWithoutVotesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionId: string
    voterHash: string
    deviceFingerprint?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    status?: $Enums.VotingStatus
    startTime?: Date | string
    endTime?: Date | string | null
    expiresAt: Date | string
    isValid?: boolean
    userId: string
  }

  export type VotingSessionCreateOrConnectWithoutVotesInput = {
    where: VotingSessionWhereUniqueInput
    create: XOR<VotingSessionCreateWithoutVotesInput, VotingSessionUncheckedCreateWithoutVotesInput>
  }

  export type VotingSessionUpsertWithoutVotesInput = {
    update: XOR<VotingSessionUpdateWithoutVotesInput, VotingSessionUncheckedUpdateWithoutVotesInput>
    create: XOR<VotingSessionCreateWithoutVotesInput, VotingSessionUncheckedCreateWithoutVotesInput>
    where?: VotingSessionWhereInput
  }

  export type VotingSessionUpdateToOneWithWhereWithoutVotesInput = {
    where?: VotingSessionWhereInput
    data: XOR<VotingSessionUpdateWithoutVotesInput, VotingSessionUncheckedUpdateWithoutVotesInput>
  }

  export type VotingSessionUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
    voterHash?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVotingStatusFieldUpdateOperationsInput | $Enums.VotingStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValid?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutVotingSessionNestedInput
  }

  export type VotingSessionUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
    voterHash?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVotingStatusFieldUpdateOperationsInput | $Enums.VotingStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValid?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutAuditLogInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    programme?: string | null
    level?: string | null
    subgroup?: string | null
    college?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nominations?: NominationCreateNestedManyWithoutAspirantInput
    ecReviews?: EcReviewCreateNestedManyWithoutReviewerInput
    Nomination?: NominationCreateNestedManyWithoutUserInput
    NominatorVerification?: NominatorVerificationCreateNestedManyWithoutUserInput
    GuarantorVerification?: GuarantorVerificationCreateNestedManyWithoutUserInput
    EcReview?: EcReviewCreateNestedManyWithoutUserInput
    VotingSession?: VotingSessionCreateNestedManyWithoutUserInput
    Subgroup?: SubgroupCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAuditLogInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    programme?: string | null
    level?: string | null
    subgroup?: string | null
    college?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subgroupId?: string | null
    nominations?: NominationUncheckedCreateNestedManyWithoutAspirantInput
    ecReviews?: EcReviewUncheckedCreateNestedManyWithoutReviewerInput
    Nomination?: NominationUncheckedCreateNestedManyWithoutUserInput
    NominatorVerification?: NominatorVerificationUncheckedCreateNestedManyWithoutUserInput
    GuarantorVerification?: GuarantorVerificationUncheckedCreateNestedManyWithoutUserInput
    EcReview?: EcReviewUncheckedCreateNestedManyWithoutUserInput
    VotingSession?: VotingSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
  }

  export type UserUpsertWithoutAuditLogInput = {
    update: XOR<UserUpdateWithoutAuditLogInput, UserUncheckedUpdateWithoutAuditLogInput>
    create: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogInput, UserUncheckedUpdateWithoutAuditLogInput>
  }

  export type UserUpdateWithoutAuditLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nominations?: NominationUpdateManyWithoutAspirantNestedInput
    ecReviews?: EcReviewUpdateManyWithoutReviewerNestedInput
    Nomination?: NominationUpdateManyWithoutUserNestedInput
    NominatorVerification?: NominatorVerificationUpdateManyWithoutUserNestedInput
    GuarantorVerification?: GuarantorVerificationUpdateManyWithoutUserNestedInput
    EcReview?: EcReviewUpdateManyWithoutUserNestedInput
    VotingSession?: VotingSessionUpdateManyWithoutUserNestedInput
    Subgroup?: SubgroupUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null
    nominations?: NominationUncheckedUpdateManyWithoutAspirantNestedInput
    ecReviews?: EcReviewUncheckedUpdateManyWithoutReviewerNestedInput
    Nomination?: NominationUncheckedUpdateManyWithoutUserNestedInput
    NominatorVerification?: NominatorVerificationUncheckedUpdateManyWithoutUserNestedInput
    GuarantorVerification?: GuarantorVerificationUncheckedUpdateManyWithoutUserNestedInput
    EcReview?: EcReviewUncheckedUpdateManyWithoutUserNestedInput
    VotingSession?: VotingSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSubgroupInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    programme?: string | null
    level?: string | null
    subgroup?: string | null
    college?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nominations?: NominationCreateNestedManyWithoutAspirantInput
    ecReviews?: EcReviewCreateNestedManyWithoutReviewerInput
    Nomination?: NominationCreateNestedManyWithoutUserInput
    NominatorVerification?: NominatorVerificationCreateNestedManyWithoutUserInput
    GuarantorVerification?: GuarantorVerificationCreateNestedManyWithoutUserInput
    EcReview?: EcReviewCreateNestedManyWithoutUserInput
    VotingSession?: VotingSessionCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubgroupInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    programme?: string | null
    level?: string | null
    subgroup?: string | null
    college?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nominations?: NominationUncheckedCreateNestedManyWithoutAspirantInput
    ecReviews?: EcReviewUncheckedCreateNestedManyWithoutReviewerInput
    Nomination?: NominationUncheckedCreateNestedManyWithoutUserInput
    NominatorVerification?: NominatorVerificationUncheckedCreateNestedManyWithoutUserInput
    GuarantorVerification?: GuarantorVerificationUncheckedCreateNestedManyWithoutUserInput
    EcReview?: EcReviewUncheckedCreateNestedManyWithoutUserInput
    VotingSession?: VotingSessionUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubgroupInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubgroupInput, UserUncheckedCreateWithoutSubgroupInput>
  }

  export type UserCreateManySubgroupInputEnvelope = {
    data: UserCreateManySubgroupInput | UserCreateManySubgroupInput[]
    skipDuplicates?: boolean
  }

  export type NominationCreateWithoutSubgroupInput = {
    id?: string
    nomineeName: string
    nomineeEmail: string
    nomineeContact: string
    nomineePosition: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    status?: $Enums.NominationStatus
    nomineeCollege: string
    nomineeDepartment: string
    nomineeDateOfBirth: Date | string
    nomineeHostel: string
    nomineeRoom: string
    nomineeSex: string
    nomineeCwa: string
    nomineeProgramme: string
    nomineeLevel: string
    nomineeParish: string
    nomineeNationality: string
    nomineeRegion: string
    nomineeSubgroups?: NominationCreatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationCreatenomineeEducationInput | string[]
    hasLeadershipPosition: boolean
    leadershipPositions?: NominationCreateleadershipPositionsInput | string[]
    hasServedCommittee: boolean
    committees?: NominationCreatecommitteesInput | string[]
    skills?: NominationCreateskillsInput | string[]
    visionForOffice?: NominationCreatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationCreateknowledgeAboutOfficeInput | string[]
    approvalCount?: number
    rejectionCount?: number
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aspirant: UserCreateNestedOneWithoutNominationsInput
    nominatorVerification?: NominatorVerificationCreateNestedOneWithoutNominationInput
    guarantorVerifications?: GuarantorVerificationCreateNestedManyWithoutNominationInput
    EcReview?: EcReviewCreateNestedManyWithoutNominationInput
    candidate?: CandidateCreateNestedOneWithoutNominationInput
    User?: UserCreateNestedOneWithoutNominationInput
  }

  export type NominationUncheckedCreateWithoutSubgroupInput = {
    id?: string
    aspirantId: string
    nomineeName: string
    nomineeEmail: string
    nomineeContact: string
    nomineePosition: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    status?: $Enums.NominationStatus
    nomineeCollege: string
    nomineeDepartment: string
    nomineeDateOfBirth: Date | string
    nomineeHostel: string
    nomineeRoom: string
    nomineeSex: string
    nomineeCwa: string
    nomineeProgramme: string
    nomineeLevel: string
    nomineeParish: string
    nomineeNationality: string
    nomineeRegion: string
    nomineeSubgroups?: NominationCreatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationCreatenomineeEducationInput | string[]
    hasLeadershipPosition: boolean
    leadershipPositions?: NominationCreateleadershipPositionsInput | string[]
    hasServedCommittee: boolean
    committees?: NominationCreatecommitteesInput | string[]
    skills?: NominationCreateskillsInput | string[]
    visionForOffice?: NominationCreatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationCreateknowledgeAboutOfficeInput | string[]
    approvalCount?: number
    rejectionCount?: number
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    nominatorVerification?: NominatorVerificationUncheckedCreateNestedOneWithoutNominationInput
    guarantorVerifications?: GuarantorVerificationUncheckedCreateNestedManyWithoutNominationInput
    EcReview?: EcReviewUncheckedCreateNestedManyWithoutNominationInput
    candidate?: CandidateUncheckedCreateNestedOneWithoutNominationInput
  }

  export type NominationCreateOrConnectWithoutSubgroupInput = {
    where: NominationWhereUniqueInput
    create: XOR<NominationCreateWithoutSubgroupInput, NominationUncheckedCreateWithoutSubgroupInput>
  }

  export type NominationCreateManySubgroupInputEnvelope = {
    data: NominationCreateManySubgroupInput | NominationCreateManySubgroupInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutSubgroupInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSubgroupInput, UserUncheckedUpdateWithoutSubgroupInput>
    create: XOR<UserCreateWithoutSubgroupInput, UserUncheckedCreateWithoutSubgroupInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSubgroupInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSubgroupInput, UserUncheckedUpdateWithoutSubgroupInput>
  }

  export type UserUpdateManyWithWhereWithoutSubgroupInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSubgroupInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    programme?: StringNullableFilter<"User"> | string | null
    level?: StringNullableFilter<"User"> | string | null
    subgroup?: StringNullableFilter<"User"> | string | null
    college?: StringNullableFilter<"User"> | string | null
    phoneVerified?: BoolFilter<"User"> | boolean
    emailVerified?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    hasVoted?: BoolFilter<"User"> | boolean
    inkVerified?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    subgroupId?: StringNullableFilter<"User"> | string | null
  }

  export type NominationUpsertWithWhereUniqueWithoutSubgroupInput = {
    where: NominationWhereUniqueInput
    update: XOR<NominationUpdateWithoutSubgroupInput, NominationUncheckedUpdateWithoutSubgroupInput>
    create: XOR<NominationCreateWithoutSubgroupInput, NominationUncheckedCreateWithoutSubgroupInput>
  }

  export type NominationUpdateWithWhereUniqueWithoutSubgroupInput = {
    where: NominationWhereUniqueInput
    data: XOR<NominationUpdateWithoutSubgroupInput, NominationUncheckedUpdateWithoutSubgroupInput>
  }

  export type NominationUpdateManyWithWhereWithoutSubgroupInput = {
    where: NominationScalarWhereInput
    data: XOR<NominationUpdateManyMutationInput, NominationUncheckedUpdateManyWithoutSubgroupInput>
  }

  export type NominationCreateManyAspirantInput = {
    id?: string
    nomineeName: string
    nomineeEmail: string
    nomineeContact: string
    nomineePosition: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    status?: $Enums.NominationStatus
    nomineeCollege: string
    nomineeDepartment: string
    nomineeDateOfBirth: Date | string
    nomineeHostel: string
    nomineeRoom: string
    nomineeSex: string
    nomineeCwa: string
    nomineeProgramme: string
    nomineeLevel: string
    nomineeParish: string
    nomineeNationality: string
    nomineeRegion: string
    nomineeSubgroups?: NominationCreatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationCreatenomineeEducationInput | string[]
    hasLeadershipPosition: boolean
    leadershipPositions?: NominationCreateleadershipPositionsInput | string[]
    hasServedCommittee: boolean
    committees?: NominationCreatecommitteesInput | string[]
    skills?: NominationCreateskillsInput | string[]
    visionForOffice?: NominationCreatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationCreateknowledgeAboutOfficeInput | string[]
    approvalCount?: number
    rejectionCount?: number
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    subgroupId?: string | null
  }

  export type EcReviewCreateManyReviewerInput = {
    id?: string
    nominationId: string
    approved: boolean
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type NominationCreateManyUserInput = {
    id?: string
    aspirantId: string
    nomineeName: string
    nomineeEmail: string
    nomineeContact: string
    nomineePosition: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    status?: $Enums.NominationStatus
    nomineeCollege: string
    nomineeDepartment: string
    nomineeDateOfBirth: Date | string
    nomineeHostel: string
    nomineeRoom: string
    nomineeSex: string
    nomineeCwa: string
    nomineeProgramme: string
    nomineeLevel: string
    nomineeParish: string
    nomineeNationality: string
    nomineeRegion: string
    nomineeSubgroups?: NominationCreatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationCreatenomineeEducationInput | string[]
    hasLeadershipPosition: boolean
    leadershipPositions?: NominationCreateleadershipPositionsInput | string[]
    hasServedCommittee: boolean
    committees?: NominationCreatecommitteesInput | string[]
    skills?: NominationCreateskillsInput | string[]
    visionForOffice?: NominationCreatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationCreateknowledgeAboutOfficeInput | string[]
    approvalCount?: number
    rejectionCount?: number
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subgroupId?: string | null
  }

  export type NominatorVerificationCreateManyUserInput = {
    id?: string
    nominationId: string
    name: string
    email: string
    contact: string
    programme: string
    level: string
    subgroup: string
    status?: string
    comments?: string | null
    verifiedAt?: Date | string | null
    declinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GuarantorVerificationCreateManyUserInput = {
    id?: string
    nominationId: string
    name: string
    email: string
    contact: string
    programme: string
    subgroup: string
    status?: string
    comments?: string | null
    verifiedAt?: Date | string | null
    declinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verificationTokenId?: string | null
  }

  export type EcReviewCreateManyUserInput = {
    id?: string
    nominationId: string
    reviewerId: string
    approved: boolean
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VotingSessionCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionId: string
    voterHash: string
    deviceFingerprint?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    status?: $Enums.VotingStatus
    startTime?: Date | string
    endTime?: Date | string | null
    expiresAt: Date | string
    isValid?: boolean
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    action: string
    entity: string
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type NominationUpdateWithoutAspirantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    nomineeEmail?: StringFieldUpdateOperationsInput | string
    nomineeContact?: StringFieldUpdateOperationsInput | string
    nomineePosition?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNominationStatusFieldUpdateOperationsInput | $Enums.NominationStatus
    nomineeCollege?: StringFieldUpdateOperationsInput | string
    nomineeDepartment?: StringFieldUpdateOperationsInput | string
    nomineeDateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nomineeHostel?: StringFieldUpdateOperationsInput | string
    nomineeRoom?: StringFieldUpdateOperationsInput | string
    nomineeSex?: StringFieldUpdateOperationsInput | string
    nomineeCwa?: StringFieldUpdateOperationsInput | string
    nomineeProgramme?: StringFieldUpdateOperationsInput | string
    nomineeLevel?: StringFieldUpdateOperationsInput | string
    nomineeParish?: StringFieldUpdateOperationsInput | string
    nomineeNationality?: StringFieldUpdateOperationsInput | string
    nomineeRegion?: StringFieldUpdateOperationsInput | string
    nomineeSubgroups?: NominationUpdatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationUpdatenomineeEducationInput | string[]
    hasLeadershipPosition?: BoolFieldUpdateOperationsInput | boolean
    leadershipPositions?: NominationUpdateleadershipPositionsInput | string[]
    hasServedCommittee?: BoolFieldUpdateOperationsInput | boolean
    committees?: NominationUpdatecommitteesInput | string[]
    skills?: NominationUpdateskillsInput | string[]
    visionForOffice?: NominationUpdatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationUpdateknowledgeAboutOfficeInput | string[]
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nominatorVerification?: NominatorVerificationUpdateOneWithoutNominationNestedInput
    guarantorVerifications?: GuarantorVerificationUpdateManyWithoutNominationNestedInput
    EcReview?: EcReviewUpdateManyWithoutNominationNestedInput
    candidate?: CandidateUpdateOneWithoutNominationNestedInput
    User?: UserUpdateOneWithoutNominationNestedInput
    Subgroup?: SubgroupUpdateOneWithoutNominationsNestedInput
  }

  export type NominationUncheckedUpdateWithoutAspirantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    nomineeEmail?: StringFieldUpdateOperationsInput | string
    nomineeContact?: StringFieldUpdateOperationsInput | string
    nomineePosition?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNominationStatusFieldUpdateOperationsInput | $Enums.NominationStatus
    nomineeCollege?: StringFieldUpdateOperationsInput | string
    nomineeDepartment?: StringFieldUpdateOperationsInput | string
    nomineeDateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nomineeHostel?: StringFieldUpdateOperationsInput | string
    nomineeRoom?: StringFieldUpdateOperationsInput | string
    nomineeSex?: StringFieldUpdateOperationsInput | string
    nomineeCwa?: StringFieldUpdateOperationsInput | string
    nomineeProgramme?: StringFieldUpdateOperationsInput | string
    nomineeLevel?: StringFieldUpdateOperationsInput | string
    nomineeParish?: StringFieldUpdateOperationsInput | string
    nomineeNationality?: StringFieldUpdateOperationsInput | string
    nomineeRegion?: StringFieldUpdateOperationsInput | string
    nomineeSubgroups?: NominationUpdatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationUpdatenomineeEducationInput | string[]
    hasLeadershipPosition?: BoolFieldUpdateOperationsInput | boolean
    leadershipPositions?: NominationUpdateleadershipPositionsInput | string[]
    hasServedCommittee?: BoolFieldUpdateOperationsInput | boolean
    committees?: NominationUpdatecommitteesInput | string[]
    skills?: NominationUpdateskillsInput | string[]
    visionForOffice?: NominationUpdatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationUpdateknowledgeAboutOfficeInput | string[]
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null
    nominatorVerification?: NominatorVerificationUncheckedUpdateOneWithoutNominationNestedInput
    guarantorVerifications?: GuarantorVerificationUncheckedUpdateManyWithoutNominationNestedInput
    EcReview?: EcReviewUncheckedUpdateManyWithoutNominationNestedInput
    candidate?: CandidateUncheckedUpdateOneWithoutNominationNestedInput
  }

  export type NominationUncheckedUpdateManyWithoutAspirantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    nomineeEmail?: StringFieldUpdateOperationsInput | string
    nomineeContact?: StringFieldUpdateOperationsInput | string
    nomineePosition?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNominationStatusFieldUpdateOperationsInput | $Enums.NominationStatus
    nomineeCollege?: StringFieldUpdateOperationsInput | string
    nomineeDepartment?: StringFieldUpdateOperationsInput | string
    nomineeDateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nomineeHostel?: StringFieldUpdateOperationsInput | string
    nomineeRoom?: StringFieldUpdateOperationsInput | string
    nomineeSex?: StringFieldUpdateOperationsInput | string
    nomineeCwa?: StringFieldUpdateOperationsInput | string
    nomineeProgramme?: StringFieldUpdateOperationsInput | string
    nomineeLevel?: StringFieldUpdateOperationsInput | string
    nomineeParish?: StringFieldUpdateOperationsInput | string
    nomineeNationality?: StringFieldUpdateOperationsInput | string
    nomineeRegion?: StringFieldUpdateOperationsInput | string
    nomineeSubgroups?: NominationUpdatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationUpdatenomineeEducationInput | string[]
    hasLeadershipPosition?: BoolFieldUpdateOperationsInput | boolean
    leadershipPositions?: NominationUpdateleadershipPositionsInput | string[]
    hasServedCommittee?: BoolFieldUpdateOperationsInput | boolean
    committees?: NominationUpdatecommitteesInput | string[]
    skills?: NominationUpdateskillsInput | string[]
    visionForOffice?: NominationUpdatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationUpdateknowledgeAboutOfficeInput | string[]
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EcReviewUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nomination?: NominationUpdateOneRequiredWithoutEcReviewNestedInput
    User?: UserUpdateOneWithoutEcReviewNestedInput
  }

  export type EcReviewUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    nominationId?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EcReviewUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    nominationId?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NominationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    nomineeEmail?: StringFieldUpdateOperationsInput | string
    nomineeContact?: StringFieldUpdateOperationsInput | string
    nomineePosition?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNominationStatusFieldUpdateOperationsInput | $Enums.NominationStatus
    nomineeCollege?: StringFieldUpdateOperationsInput | string
    nomineeDepartment?: StringFieldUpdateOperationsInput | string
    nomineeDateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nomineeHostel?: StringFieldUpdateOperationsInput | string
    nomineeRoom?: StringFieldUpdateOperationsInput | string
    nomineeSex?: StringFieldUpdateOperationsInput | string
    nomineeCwa?: StringFieldUpdateOperationsInput | string
    nomineeProgramme?: StringFieldUpdateOperationsInput | string
    nomineeLevel?: StringFieldUpdateOperationsInput | string
    nomineeParish?: StringFieldUpdateOperationsInput | string
    nomineeNationality?: StringFieldUpdateOperationsInput | string
    nomineeRegion?: StringFieldUpdateOperationsInput | string
    nomineeSubgroups?: NominationUpdatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationUpdatenomineeEducationInput | string[]
    hasLeadershipPosition?: BoolFieldUpdateOperationsInput | boolean
    leadershipPositions?: NominationUpdateleadershipPositionsInput | string[]
    hasServedCommittee?: BoolFieldUpdateOperationsInput | boolean
    committees?: NominationUpdatecommitteesInput | string[]
    skills?: NominationUpdateskillsInput | string[]
    visionForOffice?: NominationUpdatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationUpdateknowledgeAboutOfficeInput | string[]
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aspirant?: UserUpdateOneRequiredWithoutNominationsNestedInput
    nominatorVerification?: NominatorVerificationUpdateOneWithoutNominationNestedInput
    guarantorVerifications?: GuarantorVerificationUpdateManyWithoutNominationNestedInput
    EcReview?: EcReviewUpdateManyWithoutNominationNestedInput
    candidate?: CandidateUpdateOneWithoutNominationNestedInput
    Subgroup?: SubgroupUpdateOneWithoutNominationsNestedInput
  }

  export type NominationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    aspirantId?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    nomineeEmail?: StringFieldUpdateOperationsInput | string
    nomineeContact?: StringFieldUpdateOperationsInput | string
    nomineePosition?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNominationStatusFieldUpdateOperationsInput | $Enums.NominationStatus
    nomineeCollege?: StringFieldUpdateOperationsInput | string
    nomineeDepartment?: StringFieldUpdateOperationsInput | string
    nomineeDateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nomineeHostel?: StringFieldUpdateOperationsInput | string
    nomineeRoom?: StringFieldUpdateOperationsInput | string
    nomineeSex?: StringFieldUpdateOperationsInput | string
    nomineeCwa?: StringFieldUpdateOperationsInput | string
    nomineeProgramme?: StringFieldUpdateOperationsInput | string
    nomineeLevel?: StringFieldUpdateOperationsInput | string
    nomineeParish?: StringFieldUpdateOperationsInput | string
    nomineeNationality?: StringFieldUpdateOperationsInput | string
    nomineeRegion?: StringFieldUpdateOperationsInput | string
    nomineeSubgroups?: NominationUpdatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationUpdatenomineeEducationInput | string[]
    hasLeadershipPosition?: BoolFieldUpdateOperationsInput | boolean
    leadershipPositions?: NominationUpdateleadershipPositionsInput | string[]
    hasServedCommittee?: BoolFieldUpdateOperationsInput | boolean
    committees?: NominationUpdatecommitteesInput | string[]
    skills?: NominationUpdateskillsInput | string[]
    visionForOffice?: NominationUpdatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationUpdateknowledgeAboutOfficeInput | string[]
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null
    nominatorVerification?: NominatorVerificationUncheckedUpdateOneWithoutNominationNestedInput
    guarantorVerifications?: GuarantorVerificationUncheckedUpdateManyWithoutNominationNestedInput
    EcReview?: EcReviewUncheckedUpdateManyWithoutNominationNestedInput
    candidate?: CandidateUncheckedUpdateOneWithoutNominationNestedInput
  }

  export type NominationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    aspirantId?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    nomineeEmail?: StringFieldUpdateOperationsInput | string
    nomineeContact?: StringFieldUpdateOperationsInput | string
    nomineePosition?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNominationStatusFieldUpdateOperationsInput | $Enums.NominationStatus
    nomineeCollege?: StringFieldUpdateOperationsInput | string
    nomineeDepartment?: StringFieldUpdateOperationsInput | string
    nomineeDateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nomineeHostel?: StringFieldUpdateOperationsInput | string
    nomineeRoom?: StringFieldUpdateOperationsInput | string
    nomineeSex?: StringFieldUpdateOperationsInput | string
    nomineeCwa?: StringFieldUpdateOperationsInput | string
    nomineeProgramme?: StringFieldUpdateOperationsInput | string
    nomineeLevel?: StringFieldUpdateOperationsInput | string
    nomineeParish?: StringFieldUpdateOperationsInput | string
    nomineeNationality?: StringFieldUpdateOperationsInput | string
    nomineeRegion?: StringFieldUpdateOperationsInput | string
    nomineeSubgroups?: NominationUpdatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationUpdatenomineeEducationInput | string[]
    hasLeadershipPosition?: BoolFieldUpdateOperationsInput | boolean
    leadershipPositions?: NominationUpdateleadershipPositionsInput | string[]
    hasServedCommittee?: BoolFieldUpdateOperationsInput | boolean
    committees?: NominationUpdatecommitteesInput | string[]
    skills?: NominationUpdateskillsInput | string[]
    visionForOffice?: NominationUpdatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationUpdateknowledgeAboutOfficeInput | string[]
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NominatorVerificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nomination?: NominationUpdateOneRequiredWithoutNominatorVerificationNestedInput
    verificationToken?: VerificationTokenUpdateOneWithoutNominatorVerificationNestedInput
  }

  export type NominatorVerificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    nominationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationToken?: VerificationTokenUncheckedUpdateOneWithoutNominatorVerificationNestedInput
  }

  export type NominatorVerificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    nominationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuarantorVerificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    nomination?: NominationUpdateOneRequiredWithoutGuarantorVerificationsNestedInput
    verificationToken?: VerificationTokenUpdateOneWithoutGuarantorVerificationNestedInput
  }

  export type GuarantorVerificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    nominationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationToken?: VerificationTokenUncheckedUpdateOneWithoutGuarantorVerificationNestedInput
  }

  export type GuarantorVerificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    nominationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationTokenId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EcReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nomination?: NominationUpdateOneRequiredWithoutEcReviewNestedInput
    reviewer?: UserUpdateOneRequiredWithoutEcReviewsNestedInput
  }

  export type EcReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    nominationId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EcReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    nominationId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VotingSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
    voterHash?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVotingStatusFieldUpdateOperationsInput | $Enums.VotingStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValid?: BoolFieldUpdateOperationsInput | boolean
    votes?: VoteUpdateManyWithoutSessionNestedInput
  }

  export type VotingSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
    voterHash?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVotingStatusFieldUpdateOperationsInput | $Enums.VotingStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValid?: BoolFieldUpdateOperationsInput | boolean
    votes?: VoteUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type VotingSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
    voterHash?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVotingStatusFieldUpdateOperationsInput | $Enums.VotingStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GuarantorVerificationCreateManyNominationInput = {
    id?: string
    name: string
    email: string
    contact: string
    programme: string
    subgroup: string
    status?: string
    comments?: string | null
    verifiedAt?: Date | string | null
    declinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verificationTokenId?: string | null
    userId?: string | null
  }

  export type EcReviewCreateManyNominationInput = {
    id?: string
    reviewerId: string
    approved: boolean
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type GuarantorVerificationUpdateWithoutNominationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationToken?: VerificationTokenUpdateOneWithoutGuarantorVerificationNestedInput
    User?: UserUpdateOneWithoutGuarantorVerificationNestedInput
  }

  export type GuarantorVerificationUncheckedUpdateWithoutNominationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationToken?: VerificationTokenUncheckedUpdateOneWithoutGuarantorVerificationNestedInput
  }

  export type GuarantorVerificationUncheckedUpdateManyWithoutNominationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    programme?: StringFieldUpdateOperationsInput | string
    subgroup?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EcReviewUpdateWithoutNominationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewer?: UserUpdateOneRequiredWithoutEcReviewsNestedInput
    User?: UserUpdateOneWithoutEcReviewNestedInput
  }

  export type EcReviewUncheckedUpdateWithoutNominationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EcReviewUncheckedUpdateManyWithoutNominationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VoteCreateManySessionInput = {
    id?: string
    createdAt?: Date | string
    encryptedVote: string
    voterHash: string
    submissionTime?: Date | string
    deviceFingerprint?: string | null
    ipAddress?: string | null
    isValid?: boolean
  }

  export type VoteUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encryptedVote?: StringFieldUpdateOperationsInput | string
    voterHash?: StringFieldUpdateOperationsInput | string
    submissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VoteUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encryptedVote?: StringFieldUpdateOperationsInput | string
    voterHash?: StringFieldUpdateOperationsInput | string
    submissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VoteUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encryptedVote?: StringFieldUpdateOperationsInput | string
    voterHash?: StringFieldUpdateOperationsInput | string
    submissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateManySubgroupInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    programme?: string | null
    level?: string | null
    subgroup?: string | null
    college?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    isActive?: boolean
    hasVoted?: boolean
    inkVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NominationCreateManySubgroupInput = {
    id?: string
    aspirantId: string
    nomineeName: string
    nomineeEmail: string
    nomineeContact: string
    nomineePosition: $Enums.Candidate_Position
    photoUrl?: string | null
    photoPublicId?: string | null
    status?: $Enums.NominationStatus
    nomineeCollege: string
    nomineeDepartment: string
    nomineeDateOfBirth: Date | string
    nomineeHostel: string
    nomineeRoom: string
    nomineeSex: string
    nomineeCwa: string
    nomineeProgramme: string
    nomineeLevel: string
    nomineeParish: string
    nomineeNationality: string
    nomineeRegion: string
    nomineeSubgroups?: NominationCreatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationCreatenomineeEducationInput | string[]
    hasLeadershipPosition: boolean
    leadershipPositions?: NominationCreateleadershipPositionsInput | string[]
    hasServedCommittee: boolean
    committees?: NominationCreatecommitteesInput | string[]
    skills?: NominationCreateskillsInput | string[]
    visionForOffice?: NominationCreatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationCreateknowledgeAboutOfficeInput | string[]
    approvalCount?: number
    rejectionCount?: number
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type UserUpdateWithoutSubgroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nominations?: NominationUpdateManyWithoutAspirantNestedInput
    ecReviews?: EcReviewUpdateManyWithoutReviewerNestedInput
    Nomination?: NominationUpdateManyWithoutUserNestedInput
    NominatorVerification?: NominatorVerificationUpdateManyWithoutUserNestedInput
    GuarantorVerification?: GuarantorVerificationUpdateManyWithoutUserNestedInput
    EcReview?: EcReviewUpdateManyWithoutUserNestedInput
    VotingSession?: VotingSessionUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubgroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nominations?: NominationUncheckedUpdateManyWithoutAspirantNestedInput
    ecReviews?: EcReviewUncheckedUpdateManyWithoutReviewerNestedInput
    Nomination?: NominationUncheckedUpdateManyWithoutUserNestedInput
    NominatorVerification?: NominatorVerificationUncheckedUpdateManyWithoutUserNestedInput
    GuarantorVerification?: GuarantorVerificationUncheckedUpdateManyWithoutUserNestedInput
    EcReview?: EcReviewUncheckedUpdateManyWithoutUserNestedInput
    VotingSession?: VotingSessionUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSubgroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programme?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    subgroup?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasVoted?: BoolFieldUpdateOperationsInput | boolean
    inkVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NominationUpdateWithoutSubgroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    nomineeEmail?: StringFieldUpdateOperationsInput | string
    nomineeContact?: StringFieldUpdateOperationsInput | string
    nomineePosition?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNominationStatusFieldUpdateOperationsInput | $Enums.NominationStatus
    nomineeCollege?: StringFieldUpdateOperationsInput | string
    nomineeDepartment?: StringFieldUpdateOperationsInput | string
    nomineeDateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nomineeHostel?: StringFieldUpdateOperationsInput | string
    nomineeRoom?: StringFieldUpdateOperationsInput | string
    nomineeSex?: StringFieldUpdateOperationsInput | string
    nomineeCwa?: StringFieldUpdateOperationsInput | string
    nomineeProgramme?: StringFieldUpdateOperationsInput | string
    nomineeLevel?: StringFieldUpdateOperationsInput | string
    nomineeParish?: StringFieldUpdateOperationsInput | string
    nomineeNationality?: StringFieldUpdateOperationsInput | string
    nomineeRegion?: StringFieldUpdateOperationsInput | string
    nomineeSubgroups?: NominationUpdatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationUpdatenomineeEducationInput | string[]
    hasLeadershipPosition?: BoolFieldUpdateOperationsInput | boolean
    leadershipPositions?: NominationUpdateleadershipPositionsInput | string[]
    hasServedCommittee?: BoolFieldUpdateOperationsInput | boolean
    committees?: NominationUpdatecommitteesInput | string[]
    skills?: NominationUpdateskillsInput | string[]
    visionForOffice?: NominationUpdatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationUpdateknowledgeAboutOfficeInput | string[]
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aspirant?: UserUpdateOneRequiredWithoutNominationsNestedInput
    nominatorVerification?: NominatorVerificationUpdateOneWithoutNominationNestedInput
    guarantorVerifications?: GuarantorVerificationUpdateManyWithoutNominationNestedInput
    EcReview?: EcReviewUpdateManyWithoutNominationNestedInput
    candidate?: CandidateUpdateOneWithoutNominationNestedInput
    User?: UserUpdateOneWithoutNominationNestedInput
  }

  export type NominationUncheckedUpdateWithoutSubgroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    aspirantId?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    nomineeEmail?: StringFieldUpdateOperationsInput | string
    nomineeContact?: StringFieldUpdateOperationsInput | string
    nomineePosition?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNominationStatusFieldUpdateOperationsInput | $Enums.NominationStatus
    nomineeCollege?: StringFieldUpdateOperationsInput | string
    nomineeDepartment?: StringFieldUpdateOperationsInput | string
    nomineeDateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nomineeHostel?: StringFieldUpdateOperationsInput | string
    nomineeRoom?: StringFieldUpdateOperationsInput | string
    nomineeSex?: StringFieldUpdateOperationsInput | string
    nomineeCwa?: StringFieldUpdateOperationsInput | string
    nomineeProgramme?: StringFieldUpdateOperationsInput | string
    nomineeLevel?: StringFieldUpdateOperationsInput | string
    nomineeParish?: StringFieldUpdateOperationsInput | string
    nomineeNationality?: StringFieldUpdateOperationsInput | string
    nomineeRegion?: StringFieldUpdateOperationsInput | string
    nomineeSubgroups?: NominationUpdatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationUpdatenomineeEducationInput | string[]
    hasLeadershipPosition?: BoolFieldUpdateOperationsInput | boolean
    leadershipPositions?: NominationUpdateleadershipPositionsInput | string[]
    hasServedCommittee?: BoolFieldUpdateOperationsInput | boolean
    committees?: NominationUpdatecommitteesInput | string[]
    skills?: NominationUpdateskillsInput | string[]
    visionForOffice?: NominationUpdatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationUpdateknowledgeAboutOfficeInput | string[]
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    nominatorVerification?: NominatorVerificationUncheckedUpdateOneWithoutNominationNestedInput
    guarantorVerifications?: GuarantorVerificationUncheckedUpdateManyWithoutNominationNestedInput
    EcReview?: EcReviewUncheckedUpdateManyWithoutNominationNestedInput
    candidate?: CandidateUncheckedUpdateOneWithoutNominationNestedInput
  }

  export type NominationUncheckedUpdateManyWithoutSubgroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    aspirantId?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    nomineeEmail?: StringFieldUpdateOperationsInput | string
    nomineeContact?: StringFieldUpdateOperationsInput | string
    nomineePosition?: EnumCandidate_PositionFieldUpdateOperationsInput | $Enums.Candidate_Position
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNominationStatusFieldUpdateOperationsInput | $Enums.NominationStatus
    nomineeCollege?: StringFieldUpdateOperationsInput | string
    nomineeDepartment?: StringFieldUpdateOperationsInput | string
    nomineeDateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nomineeHostel?: StringFieldUpdateOperationsInput | string
    nomineeRoom?: StringFieldUpdateOperationsInput | string
    nomineeSex?: StringFieldUpdateOperationsInput | string
    nomineeCwa?: StringFieldUpdateOperationsInput | string
    nomineeProgramme?: StringFieldUpdateOperationsInput | string
    nomineeLevel?: StringFieldUpdateOperationsInput | string
    nomineeParish?: StringFieldUpdateOperationsInput | string
    nomineeNationality?: StringFieldUpdateOperationsInput | string
    nomineeRegion?: StringFieldUpdateOperationsInput | string
    nomineeSubgroups?: NominationUpdatenomineeSubgroupsInput | string[]
    nomineeEducation?: NominationUpdatenomineeEducationInput | string[]
    hasLeadershipPosition?: BoolFieldUpdateOperationsInput | boolean
    leadershipPositions?: NominationUpdateleadershipPositionsInput | string[]
    hasServedCommittee?: BoolFieldUpdateOperationsInput | boolean
    committees?: NominationUpdatecommitteesInput | string[]
    skills?: NominationUpdateskillsInput | string[]
    visionForOffice?: NominationUpdatevisionForOfficeInput | string[]
    knowledgeAboutOffice?: NominationUpdateknowledgeAboutOfficeInput | string[]
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}